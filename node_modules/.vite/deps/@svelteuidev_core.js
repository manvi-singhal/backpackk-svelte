import {
  X,
  i
} from "./chunk-VZDNJOXJ.js";
import {
  autoUpdate,
  computePosition
} from "./chunk-7JNU4ZHW.js";
import {
  arrow,
  flip,
  offset,
  shift
} from "./chunk-3YX4GA5S.js";
import "./chunk-SA3VOP2B.js";
import {
  tweened
} from "./chunk-CV5C3X5G.js";
import {
  writable
} from "./chunk-ZONHURS3.js";
import "./chunk-X7HCJ7ZS.js";
import {
  blur,
  draw,
  fade,
  fly,
  scale,
  slide
} from "./chunk-RUOX6FBL.js";
import {
  cubicOut,
  sineInOut
} from "./chunk-VFRMSNTO.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  action_destroyer,
  add_flush_callback,
  add_location,
  add_render_callback,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  beforeUpdate,
  bind,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_html_tag,
  claim_space,
  claim_svg_element,
  claim_text,
  component_subscribe,
  compute_rest_props,
  compute_slots,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_bidirectional_transition,
  create_component,
  create_in_transition,
  create_out_transition,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_svelte_dataset,
  globals,
  group_outros,
  head_selector,
  init,
  init_binding_group,
  insert_hydration_dev,
  is_function,
  listen,
  listen_dev,
  mount_component,
  noop,
  null_to_empty,
  onDestroy,
  onMount,
  outro_and_destroy_block,
  prevent_default,
  prop_dev,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  set_data_dev,
  set_dynamic_element_data,
  set_input_value,
  set_store_value,
  set_style,
  set_svg_attributes,
  space,
  src_url_equal,
  stop_propagation,
  subscribe,
  svg_element,
  text,
  tick,
  toggle_class,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_dynamic_element,
  validate_each_keys,
  validate_slots,
  validate_store,
  validate_void_dynamic_element
} from "./chunk-D4ORRFJZ.js";
import "./chunk-EKIRE5YT.js";
import {
  __export
} from "./chunk-25V3TAZK.js";

// node_modules/@svelteuidev/core/dist/internal/temp/actions/use-clipboard/use-clipboard.js
function clipboard(node, text2) {
  const click = async () => {
    if (text2)
      try {
        await navigator.clipboard.writeText(text2);
        node.dispatchEvent(new CustomEvent("useclipboard", { detail: text2 }));
      } catch (e) {
        node.dispatchEvent(new CustomEvent("useclipboard-error", { detail: e }));
      }
  };
  node.addEventListener("click", click, true);
  return {
    update: (t) => text2 = t,
    destroy: () => node.removeEventListener("click", click, true)
  };
}

// node_modules/@svelteuidev/core/dist/internal/errors/Error.svelte
var { Error: Error_1 } = globals;
function create_if_block(ctx8) {
  let html_tag;
  let raw_value = exception(
    /*component*/
    ctx8[1],
    /*code*/
    ctx8[2]
  ) + "";
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*component, code*/
      6 && raw_value !== (raw_value = exception(
        /*component*/
        ctx9[1],
        /*code*/
        ctx9[2]
      ) + ""))
        html_tag.p(raw_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(7:0) {#if observable}",
    ctx: ctx8
  });
  return block;
}
function create_fragment(ctx8) {
  let if_block_anchor;
  let if_block = (
    /*observable*/
    ctx8[0] && create_if_block(ctx8)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx9, [dirty]) {
      if (
        /*observable*/
        ctx9[0]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
        } else {
          if_block = create_if_block(ctx9);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Error", slots, []);
  let { observable = false } = $$props;
  let { component } = $$props;
  let { code } = $$props;
  $$self.$$.on_mount.push(function() {
    if (component === void 0 && !("component" in $$props || $$self.$$.bound[$$self.$$.props["component"]])) {
      console.warn("<Error> was created without expected prop 'component'");
    }
    if (code === void 0 && !("code" in $$props || $$self.$$.bound[$$self.$$.props["code"]])) {
      console.warn("<Error> was created without expected prop 'code'");
    }
  });
  const writable_props = ["observable", "component", "code"];
  Object.keys($$props).forEach((key3) => {
    if (!~writable_props.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<Error> was created with unknown prop '${key3}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("observable" in $$props2)
      $$invalidate(0, observable = $$props2.observable);
    if ("component" in $$props2)
      $$invalidate(1, component = $$props2.component);
    if ("code" in $$props2)
      $$invalidate(2, code = $$props2.code);
  };
  $$self.$capture_state = () => ({ exception, observable, component, code });
  $$self.$inject_state = ($$props2) => {
    if ("observable" in $$props2)
      $$invalidate(0, observable = $$props2.observable);
    if ("component" in $$props2)
      $$invalidate(1, component = $$props2.component);
    if ("code" in $$props2)
      $$invalidate(2, code = $$props2.code);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [observable, component, code];
}
var Error2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { observable: 0, component: 1, code: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Error",
      options,
      id: create_fragment.name
    });
  }
  get observable() {
    throw new Error_1("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set observable(value) {
    throw new Error_1("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error_1("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error_1("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get code() {
    throw new Error_1("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set code(value) {
    throw new Error_1("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Error_default = Error2;

// node_modules/@svelteuidev/core/dist/internal/errors/modules/browser.js
var isBrowser = () => typeof window !== "undefined";
var browser = isBrowser();

// node_modules/@svelteuidev/core/dist/internal/errors/assets/error-styles.js
var minifiedCss = ".modal-header{padding: 2px 16px;background-color: #339af0;color: white;}.modal-body{padding: 2px 16px;}.modal-footer{padding: 2px 16px;background-color: #339af0;color: white;}.modal-content{position: relative;background-color: #fefefe;margin: auto;padding: 0;border: 1px solid #888;width: 80%;box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);animation-name: animateTop;animation-duration: 0.4s;}@keyframes animateTop {from {top: -300px; opacity: 0}to {top: 0; opacity: 1}}";

// node_modules/@svelteuidev/core/dist/internal/errors/user-exception.js
var style = browser ? document.createElement("style") : void 0;
if (browser) {
  const s = style;
  s.textContent = minifiedCss;
  s.id = "svelteui-inject";
}
function UserException(component, message, solution) {
  if (browser)
    document.head.appendChild(style);
  const html = `
    <div class="modal-content">
        <div class="modal-header">
            <h2>[${component} Component Error]:</h2>
            <h3>${message}</h3>
        </div>
        <div class="modal-body">
            <pre>
                ${solution ? solution : ""}
            </pre>
        </div>
        <div class="modal-footer">
            <h3>Fix the code to dismiss this error.</h3>
        </div>
    </div>        
    `;
  return html;
}

// node_modules/@svelteuidev/core/dist/internal/errors/error-context.js
var errorCtx = {
  error: false,
  message: "",
  solution: ""
};

// node_modules/@svelteuidev/core/dist/internal/errors/exception.js
function exception(component, code) {
  const { message, solution } = code;
  if (solution) {
    return UserException(component, message, solution);
  }
  return UserException(component, message);
}

// node_modules/@svelteuidev/core/dist/internal/utils/forwarding/forward-actions.js
function useActions(node, actions) {
  const actionReturns = [];
  if (actions) {
    for (let i2 = 0; i2 < actions.length; i2++) {
      const actionEntry = actions[i2];
      const action = Array.isArray(actionEntry) ? actionEntry[0] : actionEntry;
      if (Array.isArray(actionEntry) && actionEntry.length > 1) {
        actionReturns.push(action(node, actionEntry[1]));
      } else {
        actionReturns.push(action(node));
      }
    }
  }
  return {
    update(actions2) {
      if ((actions2 && actions2.length || 0) != actionReturns.length) {
        throw new Error("You must not change the length of an actions array.");
      }
      if (actions2) {
        for (let i2 = 0; i2 < actions2.length; i2++) {
          const returnEntry = actionReturns[i2];
          if (returnEntry && returnEntry.update) {
            const actionEntry = actions2[i2];
            if (Array.isArray(actionEntry) && actionEntry.length > 1) {
              returnEntry.update(actionEntry[1]);
            } else {
              returnEntry.update();
            }
          }
        }
      }
    },
    destroy() {
      for (let i2 = 0; i2 < actionReturns.length; i2++) {
        const returnEntry = actionReturns[i2];
        if (returnEntry && returnEntry.destroy) {
          returnEntry.destroy();
        }
      }
    }
  };
}

// node_modules/@svelteuidev/core/dist/internal/utils/forwarding/forward-events.js
var MODIFIER_DIVIDER = "!";
var modifierRegex = new RegExp(`^[^${MODIFIER_DIVIDER}]+(?:${MODIFIER_DIVIDER}(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$`);
function createEventForwarder(component, except = []) {
  let $on;
  const events = [];
  component.$on = (fullEventType, callback) => {
    const eventType = fullEventType;
    let destructor = () => {
    };
    for (const exception2 of except) {
      if (typeof exception2 === "string" && exception2 === eventType) {
        const callbacks = component.$$.callbacks[eventType] || (component.$$.callbacks[eventType] = []);
        callbacks.push(callback);
        return () => {
          const index = callbacks.indexOf(callback);
          if (index !== -1)
            callbacks.splice(index, 1);
        };
      }
      if (typeof exception2 === "object" && exception2["name"] === eventType) {
        const oldCallback = callback;
        callback = (...props) => {
          if (!(typeof exception2 === "object" && exception2["shouldExclude"]())) {
            oldCallback(...props);
          }
        };
      }
    }
    if ($on) {
      destructor = $on(eventType, callback);
    } else {
      events.push([eventType, callback]);
    }
    return () => {
      destructor();
    };
  };
  function forward(e) {
    bubble(component, e);
  }
  return (node) => {
    const destructors = [];
    const forwardDestructors = {};
    $on = (fullEventType, callback) => {
      let eventType = fullEventType;
      let handler = callback;
      let options = false;
      const modifierMatch = eventType.match(modifierRegex);
      if (modifierMatch) {
        const parts = eventType.split(MODIFIER_DIVIDER);
        eventType = parts[0];
        const eventOptions = Object.fromEntries(parts.slice(1).map((mod) => [mod, true]));
        if (eventOptions.passive) {
          options = options || {};
          options.passive = true;
        }
        if (eventOptions.nonpassive) {
          options = options || {};
          options.passive = false;
        }
        if (eventOptions.capture) {
          options = options || {};
          options.capture = true;
        }
        if (eventOptions.once) {
          options = options || {};
          options.once = true;
        }
        if (eventOptions.preventDefault) {
          handler = prevent_default(handler);
        }
        if (eventOptions.stopPropagation) {
          handler = stop_propagation(handler);
        }
      }
      const off = listen(node, eventType, handler, options);
      const destructor = () => {
        off();
        const idx = destructors.indexOf(destructor);
        if (idx > -1) {
          destructors.splice(idx, 1);
        }
      };
      destructors.push(destructor);
      if (!(eventType in forwardDestructors)) {
        forwardDestructors[eventType] = listen(node, eventType, forward);
      }
      return destructor;
    };
    for (let i2 = 0; i2 < events.length; i2++) {
      $on(events[i2][0], events[i2][1]);
    }
    return {
      destroy: () => {
        for (let i2 = 0; i2 < destructors.length; i2++) {
          destructors[i2]();
        }
        for (const entry of Object.entries(forwardDestructors)) {
          entry[1]();
        }
      }
    };
  };
}

// node_modules/@svelteuidev/core/dist/internal/utils/environment.js
var isBrowser2 = () => typeof window !== "undefined";
var ENVIRONMENT = {
  browser: isBrowser2(),
  server: !isBrowser2()
};

// node_modules/@svelteuidev/core/dist/internal/utils/get-transition/get-transition.js
function getTransition(name) {
  let transition;
  if (typeof name === "function")
    return name;
  switch (name) {
    case "fade":
      transition = fade;
      break;
    case "blur":
      transition = blur;
      break;
    case "fly":
      transition = fly;
      break;
    case "slide":
      transition = slide;
      break;
    case "scale":
      transition = scale;
      break;
    case "draw":
      transition = draw;
      break;
    default:
      throw new Error("You must enter a valid transition name");
  }
  return transition;
}

// node_modules/@svelteuidev/core/dist/styles/theme/SvelteUIProvider/svelteui.provider.js
var key = {};
var globalStyles = (themeObserver) => {
  const globalStylesLight = `<style	id="svelteui-inject" type="text/css">body{background-color:white;color:black;}</style>`;
  const globalStylesDark = `<style	id="svelteui-inject" type="text/css">body{background-color:#1A1B1E;color:#C1C2C5;}</style>`;
  if (themeObserver === "light")
    return globalStylesLight;
  return globalStylesDark;
};
function useSvelteUIThemeContext() {
  return getContext(key);
}
function useSvelteUIDefaultProps(component, defaultProps, props) {
  var _a;
  const contextProps = (_a = useSvelteUIThemeContext().defaultProps) == null ? void 0 : _a[component];
  return { ...defaultProps, ...contextProps, ...props };
}

// node_modules/@svelteuidev/core/dist/styles/theme/SvelteUIProvider/svelteui.stores.js
var colorScheme = writable("light");

// node_modules/@svelteuidev/core/dist/styles/theme/default-colors.js
var colors = {
  primary: "#228be6",
  white: "#ffffff",
  black: "#000000",
  dark50: "#C1C2C5",
  dark100: "#A6A7AB",
  dark200: "#909296",
  dark300: "#5c5f66",
  dark400: "#373A40",
  dark500: "#2C2E33",
  dark600: "#25262b",
  dark700: "#1A1B1E",
  dark800: "#141517",
  dark900: "#101113",
  gray50: "#f8f9fa",
  gray100: "#f1f3f5",
  gray200: "#e9ecef",
  gray300: "#dee2e6",
  gray400: "#ced4da",
  gray500: "#adb5bd",
  gray600: "#868e96",
  gray700: "#495057",
  gray800: "#343a40",
  gray900: "#212529",
  red50: "#fff5f5",
  red100: "#ffe3e3",
  red200: "#ffc9c9",
  red300: "#ffa8a8",
  red400: "#ff8787",
  red500: "#ff6b6b",
  red600: "#fa5252",
  red700: "#f03e3e",
  red800: "#e03131",
  red900: "#c92a2a",
  pink50: "#fff0f6",
  pink100: "#ffdeeb",
  pink200: "#fcc2d7",
  pink300: "#faa2c1",
  pink400: "#f783ac",
  pink500: "#f06595",
  pink600: "#e64980",
  pink700: "#d6336c",
  pink800: "#c2255c",
  pink900: "#a61e4d",
  grape50: "#f8f0fc",
  grape100: "#f3d9fa",
  grape200: "#eebefa",
  grape300: "#e599f7",
  grape400: "#da77f2",
  grape500: "#cc5de8",
  grape600: "#be4bdb",
  grape700: "#ae3ec9",
  grape800: "#9c36b5",
  grape900: "#862e9c",
  violet50: "#f3f0ff",
  violet100: "#e5dbff",
  violet200: "#d0bfff",
  violet300: "#b197fc",
  violet400: "#9775fa",
  violet500: "#845ef7",
  violet600: "#7950f2",
  violet700: "#7048e8",
  violet800: "#6741d9",
  violet900: "#5f3dc4",
  indigo50: "#edf2ff",
  indigo100: "#dbe4ff",
  indigo200: "#bac8ff",
  indigo300: "#91a7ff",
  indigo400: "#748ffc",
  indigo500: "#5c7cfa",
  indigo600: "#4c6ef5",
  indigo700: "#4263eb",
  indigo800: "#3b5bdb",
  indigo900: "#364fc7",
  blue50: "#e7f5ff",
  blue100: "#d0ebff",
  blue200: "#a5d8ff",
  blue300: "#74c0fc",
  blue400: "#4dabf7",
  blue500: "#339af0",
  blue600: "#228be6",
  blue700: "#1c7ed6",
  blue800: "#1971c2",
  blue900: "#1864ab",
  cyan50: "#e3fafc",
  cyan100: "#c5f6fa",
  cyan200: "#99e9f2",
  cyan300: "#66d9e8",
  cyan400: "#3bc9db",
  cyan500: "#22b8cf",
  cyan600: "#15aabf",
  cyan700: "#1098ad",
  cyan800: "#0c8599",
  cyan900: "#0b7285",
  teal50: "#e6fcf5",
  teal100: "#c3fae8",
  teal200: "#96f2d7",
  teal300: "#63e6be",
  teal400: "#38d9a9",
  teal500: "#20c997",
  teal600: "#12b886",
  teal700: "#0ca678",
  teal800: "#099268",
  teal900: "#087f5b",
  green50: "#ebfbee",
  green100: "#d3f9d8",
  green200: "#b2f2bb",
  green300: "#8ce99a",
  green400: "#69db7c",
  green500: "#51cf66",
  green600: "#40c057",
  green700: "#37b24d",
  green800: "#2f9e44",
  green900: "#2b8a3e",
  lime50: "#f4fce3",
  lime100: "#e9fac8",
  lime200: "#d8f5a2",
  lime300: "#c0eb75",
  lime400: "#a9e34b",
  lime500: "#94d82d",
  lime600: "#82c91e",
  lime700: "#74b816",
  lime800: "#66a80f",
  lime900: "#5c940d",
  yellow50: "#fff9db",
  yellow100: "#fff3bf",
  yellow200: "#ffec99",
  yellow300: "#ffe066",
  yellow400: "#ffd43b",
  yellow500: "#fcc419",
  yellow600: "#fab005",
  yellow700: "#f59f00",
  yellow800: "#f08c00",
  yellow900: "#e67700",
  orange50: "#fff4e6",
  orange100: "#ffe8cc",
  orange200: "#ffd8a8",
  orange300: "#ffc078",
  orange400: "#ffa94d",
  orange500: "#ff922b",
  orange600: "#fd7e14",
  orange700: "#f76707",
  orange800: "#e8590c",
  orange900: "#d9480f"
};
var colorNameMap = {
  blue: "blue",
  cyan: "cyan",
  dark: "dark",
  grape: "grape",
  gray: "gray",
  green: "green",
  indigo: "indigo",
  lime: "lime",
  orange: "orange",
  pink: "pink",
  red: "red",
  teal: "teal",
  violet: "violet",
  yellow: "yellow"
};

// node_modules/@svelteuidev/core/dist/styles/stitches.config.js
var { css, globalCss, keyframes, getCssText, theme, createTheme, config, reset } = X({
  prefix: "svelteui",
  theme: {
    colors,
    space: {
      0: "0rem",
      xs: 10,
      sm: 12,
      md: 16,
      lg: 20,
      xl: 24,
      xsPX: "10px",
      smPX: "12px",
      mdPX: "16px",
      lgPX: "20px",
      xlPX: "24px",
      1: "0.125rem",
      2: "0.25rem",
      3: "0.375rem",
      4: "0.5rem",
      5: "0.625rem",
      6: "0.75rem",
      7: "0.875rem",
      8: "1rem",
      9: "1.25rem",
      10: "1.5rem",
      11: "1.75rem",
      12: "2rem",
      13: "2.25rem",
      14: "2.5rem",
      15: "2.75rem",
      16: "3rem",
      17: "3.5rem",
      18: "4rem",
      20: "5rem",
      24: "6rem",
      28: "7rem",
      32: "8rem",
      36: "9rem",
      40: "10rem",
      44: "11rem",
      48: "12rem",
      52: "13rem",
      56: "14rem",
      60: "15rem",
      64: "16rem",
      72: "18rem",
      80: "20rem",
      96: "24rem"
    },
    fontSizes: {
      xs: "12px",
      sm: "14px",
      md: "16px",
      lg: "18px",
      xl: "20px"
    },
    fonts: {
      standard: "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji",
      mono: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace",
      fallback: "Segoe UI, system-ui, sans-serif"
    },
    fontWeights: {
      thin: 100,
      extralight: 200,
      light: 300,
      normal: 400,
      medium: 500,
      semibold: 600,
      bold: 700,
      extrabold: 800
    },
    lineHeights: {
      xs: 1,
      sm: 1.25,
      md: 1.5,
      lg: 1.625,
      xl: 1.75
    },
    letterSpacings: {
      tighter: "-0.05em",
      tight: "-0.025em",
      normal: "0",
      wide: "0.025em",
      wider: "0.05em",
      widest: "0.1em"
    },
    sizes: {},
    radii: {
      xs: "2px",
      sm: "4px",
      md: "8px",
      lg: "16px",
      xl: "32px",
      squared: "33%",
      rounded: "50%",
      pill: "9999px"
    },
    shadows: {
      xs: "0 1px 3px rgba(0, 0, 0, 0.05), 0 1px 2px rgba(0, 0, 0, 0.1)",
      sm: "0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 10px 15px -5px, rgba(0, 0, 0, 0.04) 0px 7px 7px -5px",
      md: "0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 20px 25px -5px, rgba(0, 0, 0, 0.04) 0px 10px 10px -5px",
      lg: "0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 28px 23px -7px, rgba(0, 0, 0, 0.04) 0px 12px 12px -7px",
      xl: "0 1px 3px rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0px 36px 28px -7px, rgba(0, 0, 0, 0.04) 0px 17px 17px -7px"
    },
    zIndices: {
      1: "100",
      2: "200",
      3: "300",
      4: "400",
      5: "500",
      10: "1000",
      max: "9999"
    },
    borderWidths: {
      light: "1px",
      normal: "2px",
      bold: "3px",
      extrabold: "4px",
      black: "5px",
      xs: "1px",
      sm: "2px",
      md: "3px",
      lg: "4px",
      xl: "5px"
    },
    breakpoints: {
      xs: 576,
      sm: 768,
      md: 992,
      lg: 1200,
      xl: 1400
    },
    borderStyles: {},
    transitions: {}
  },
  media: {
    xs: "(min-width: 576px)",
    sm: "(min-width: 768px)",
    md: "(min-width: 992px)",
    lg: "(min-width: 1200px)",
    xl: "(min-width: 1400px)"
  },
  utils: {
    focusRing: (value) => ({
      WebkitTapHighlightColor: "transparent",
      "&:focus": {
        outlineOffset: 2,
        outline: value === "always" || value === "auto" ? "2px solid $primary" : "none"
      },
      "&:focus:not(:focus-visible)": {
        outline: value === "auto" || value === "never" ? "none" : void 0
      }
    }),
    /** padding top */
    p: (value) => ({
      padding: value
    }),
    pt: (value) => ({
      paddingTop: value
    }),
    pr: (value) => ({
      paddingRight: value
    }),
    pb: (value) => ({
      paddingBottom: value
    }),
    pl: (value) => ({
      paddingLeft: value
    }),
    px: (value) => ({
      paddingLeft: value,
      paddingRight: value
    }),
    py: (value) => ({
      paddingTop: value,
      paddingBottom: value
    }),
    /** margin */
    m: (value) => ({
      margin: value
    }),
    /** margin-top */
    mt: (value) => ({
      marginTop: value
    }),
    mr: (value) => ({
      marginRight: value
    }),
    mb: (value) => ({
      marginBottom: value
    }),
    ml: (value) => ({
      marginLeft: value
    }),
    mx: (value) => ({
      marginLeft: value,
      marginRight: value
    }),
    my: (value) => ({
      marginTop: value,
      marginBottom: value
    }),
    ta: (value) => ({
      textAlign: value
    }),
    tt: (value) => ({
      textTransform: value
    }),
    to: (value) => ({
      textOverflow: value
    }),
    d: (value) => ({ display: value }),
    dflex: (value) => ({
      display: "flex",
      alignItems: value,
      justifyContent: value
    }),
    fd: (value) => ({
      flexDirection: value
    }),
    fw: (value) => ({ flexWrap: value }),
    ai: (value) => ({
      alignItems: value
    }),
    ac: (value) => ({
      alignContent: value
    }),
    jc: (value) => ({
      justifyContent: value
    }),
    as: (value) => ({
      alignSelf: value
    }),
    fg: (value) => ({ flexGrow: value }),
    fs: (value) => ({
      fontSize: value
    }),
    fb: (value) => ({
      flexBasis: value
    }),
    bc: (value) => ({
      backgroundColor: value
    }),
    bf: (value) => ({
      backdropFilter: value
    }),
    bg: (value) => ({
      background: value
    }),
    bgBlur: (value) => ({
      bf: "saturate(180%) blur(10px)",
      bg: value
    }),
    bgColor: (value) => ({
      backgroundColor: value
    }),
    backgroundClip: (value) => ({
      WebkitBackgroundClip: value,
      backgroundClip: value
    }),
    bgClip: (value) => ({
      WebkitBackgroundClip: value,
      backgroundClip: value
    }),
    br: (value) => ({
      borderRadius: value
    }),
    bw: (value) => ({
      borderWidth: value
    }),
    btrr: (value) => ({
      borderTopRightRadius: value
    }),
    bbrr: (value) => ({
      borderBottomRightRadius: value
    }),
    bblr: (value) => ({
      borderBottomLeftRadius: value
    }),
    btlr: (value) => ({
      borderTopLeftRadius: value
    }),
    bs: (value) => ({
      boxShadow: value
    }),
    normalShadow: (value) => ({
      boxShadow: `0 4px 14px 0 $${value}`
    }),
    lh: (value) => ({
      lineHeight: value
    }),
    ov: (value) => ({ overflow: value }),
    ox: (value) => ({
      overflowX: value
    }),
    oy: (value) => ({
      overflowY: value
    }),
    pe: (value) => ({
      pointerEvents: value
    }),
    events: (value) => ({
      pointerEvents: value
    }),
    us: (value) => ({
      WebkitUserSelect: value,
      userSelect: value
    }),
    userSelect: (value) => ({
      WebkitUserSelect: value,
      userSelect: value
    }),
    w: (value) => ({ width: value }),
    h: (value) => ({
      height: value
    }),
    minW: (value) => ({
      minWidth: value
    }),
    minH: (value) => ({
      minWidth: value
    }),
    mw: (value) => ({
      maxWidth: value
    }),
    maxW: (value) => ({
      maxWidth: value
    }),
    mh: (value) => ({
      maxHeight: value
    }),
    maxH: (value) => ({
      maxHeight: value
    }),
    size: (value) => ({
      width: value,
      height: value
    }),
    minSize: (value) => ({
      minWidth: value,
      minHeight: value,
      width: value,
      height: value
    }),
    sizeMin: (value) => ({
      minWidth: value,
      minHeight: value,
      width: value,
      height: value
    }),
    maxSize: (value) => ({
      maxWidth: value,
      maxHeight: value
    }),
    sizeMax: (value) => ({
      maxWidth: value,
      maxHeight: value
    }),
    appearance: (value) => ({
      WebkitAppearance: value,
      appearance: value
    }),
    scale: (value) => ({
      transform: `scale(${value})`
    }),
    linearGradient: (value) => ({
      backgroundImage: `linear-gradient(${value})`
    }),
    tdl: (value) => ({
      textDecorationLine: value
    }),
    // Text gradient effect
    textGradient: (value) => ({
      backgroundImage: `linear-gradient(${value})`,
      WebkitBackgroundClip: "text",
      WebkitTextFillColor: "transparent"
    })
  },
  themeMap: {
    ...i,
    width: "space",
    height: "space",
    minWidth: "space",
    maxWidth: "space",
    minHeight: "space",
    maxHeight: "space",
    flexBasis: "space",
    gridTemplateColumns: "space",
    gridTemplateRows: "space",
    blockSize: "space",
    minBlockSize: "space",
    maxBlockSize: "space",
    inlineSize: "space",
    minInlineSize: "space",
    maxInlineSize: "space",
    borderWidth: "borderWeights"
  }
});
var dark = createTheme("dark-theme", {
  colors,
  shadows: {
    xs: "-4px 0 15px rgb(0 0 0 / 50%)",
    sm: "0 5px 20px -5px rgba(20, 20, 20, 0.1)",
    md: "0 8px 30px rgba(20, 20, 20, 0.15)",
    lg: "0 30px 60px rgba(20, 20, 20, 0.15)",
    xl: "0 40px 80px rgba(20, 20, 20, 0.25)"
  }
});
var SvelteUIGlobalCSS = globalCss({
  a: {
    focusRing: "auto"
  },
  body: {
    [`${dark.selector} &`]: {
      backgroundColor: "$dark700",
      color: "$dark50"
    },
    backgroundColor: "$white",
    color: "$black"
  }
});
var NormalizeCSS = globalCss({
  html: {
    fontFamily: "sans-serif",
    lineHeight: "1.15",
    textSizeAdjust: "100%",
    margin: 0
  },
  body: {
    margin: 0
  },
  "article, aside, footer, header, nav, section, figcaption, figure, main": {
    display: "block"
  },
  h1: {
    fontSize: "2em",
    margin: 0
  },
  hr: {
    boxSizing: "content-box",
    height: 0,
    overflow: "visible"
  },
  pre: {
    fontFamily: "monospace, monospace",
    fontSize: "1em"
  },
  a: {
    background: "transparent",
    textDecorationSkip: "objects"
  },
  "a:active, a:hover": {
    outlineWidth: 0
  },
  "abbr[title]": {
    borderBottom: "none",
    textDecoration: "underline"
  },
  "b, strong": {
    fontWeight: "bolder"
  },
  "code, kbp, samp": {
    fontFamily: "monospace, monospace",
    fontSize: "1em"
  },
  dfn: {
    fontStyle: "italic"
  },
  mark: {
    backgroundColor: "#ff0",
    color: "#000"
  },
  small: {
    fontSize: "80%"
  },
  "sub, sup": {
    fontSize: "75%",
    lineHeight: 0,
    position: "relative",
    verticalAlign: "baseline"
  },
  sup: {
    top: "-0.5em"
  },
  sub: {
    bottom: "-0.25em"
  },
  "audio, video": {
    display: "inline-block"
  },
  "audio:not([controls])": {
    display: "none",
    height: 0
  },
  img: {
    borderStyle: "none",
    verticalAlign: "middle"
  },
  "svg:not(:root)": {
    overflow: "hidden"
  },
  "button, input, optgroup, select, textarea": {
    fontFamily: "sans-serif",
    fontSize: "100%",
    lineHeight: "1.15",
    margin: 0
  },
  "button, input": {
    overflow: "visible"
  },
  "button, select": {
    textTransform: "none"
  },
  "button, [type=reset], [type=submit]": {
    WebkitAppearance: "button"
  },
  "button::-moz-focus-inner, [type=button]::-moz-focus-inner, [type=reset]::-moz-focus-inner, [type=submit]::-moz-focus-inner": {
    borderStyle: "none",
    padding: 0
  },
  "button:-moz-focusring, [type=button]:-moz-focusring, [type=reset]:-moz-focusring, [type=submit]:-moz-focusring": {
    outline: "1px dotted ButtonText"
  },
  legend: {
    boxSizing: "border-box",
    color: "inherit",
    display: "table",
    maxWidth: "100%",
    padding: 0,
    whiteSpace: "normal"
  },
  progress: {
    display: "inline-block",
    verticalAlign: "baseline"
  },
  textarea: {
    overflow: "auto"
  },
  "[type=checkbox], [type=radio]": {
    boxSizing: "border-box",
    padding: 0
  },
  "[type=number]::-webkit-inner-spin-button, [type=number]::-webkit-outer-spin-button": {
    height: "auto"
  },
  "[type=search]": {
    appearance: "textfield",
    outlineOffset: "-2px"
  },
  "[type=search]::-webkit-search-cancel-button, [type=search]::-webkit-search-decoration": {
    appearance: "none"
  },
  "::-webkit-file-upload-button": {
    appearance: "button",
    font: "inherit"
  },
  "details, menu": {
    display: "block"
  },
  summary: {
    display: "list-item"
  },
  canvas: {
    display: "inline-block"
  },
  template: {
    display: "none"
  },
  "[hidden]": {
    display: "none"
  }
});

// node_modules/@svelteuidev/core/dist/styles/theme/functions/fns/theme-color/theme-color.js
function themeColor(color, shade = 0) {
  var _a, _b;
  const theme4 = ((_a = useSvelteUIThemeContext()) == null ? void 0 : _a.theme) || useSvelteUITheme();
  let _shade = "50";
  if (!isSvelteUIColor(color))
    return color;
  if (shade !== Number(0))
    _shade = `${shade.toString()}00`;
  return (_b = theme4.colors[`${color}${_shade}`]) == null ? void 0 : _b.value;
}
function isSvelteUIColor(color) {
  let valid = false;
  switch (color) {
    case "dark":
      valid = true;
      break;
    case "gray":
      valid = true;
      break;
    case "red":
      valid = true;
      break;
    case "pink":
      valid = true;
      break;
    case "grape":
      valid = true;
      break;
    case "violet":
      valid = true;
      break;
    case "indigo":
      valid = true;
      break;
    case "blue":
      valid = true;
      break;
    case "cyan":
      valid = true;
      break;
    case "teal":
      valid = true;
      break;
    case "green":
      valid = true;
      break;
    case "lime":
      valid = true;
      break;
    case "yellow":
      valid = true;
      break;
    case "orange":
      valid = true;
      break;
    default:
      valid = false;
      break;
  }
  return valid;
}

// node_modules/@svelteuidev/core/dist/styles/theme/utils/rem/rem.js
function createConverter(units) {
  return (px) => {
    if (typeof px === "number") {
      return `${px / 16}${units}`;
    }
    if (typeof px === "string") {
      const replaced = px.replace("px", "");
      if (!Number.isNaN(Number(replaced))) {
        return `${Number(replaced) / 16}${units}`;
      }
    }
    return px;
  };
}
var rem = createConverter("rem");
var em = createConverter("em");

// node_modules/@svelteuidev/core/dist/styles/theme/functions/fns/cover/cover.js
function cover(offset2 = 0) {
  return {
    position: "absolute",
    top: rem(offset2),
    right: rem(offset2),
    left: rem(offset2),
    bottom: rem(offset2)
  };
}

// node_modules/@svelteuidev/core/dist/styles/theme/functions/fns/size/size.js
function size(props) {
  var _a, _b;
  if (typeof props.size === "number") {
    return props.size;
  }
  if (typeof props.sizes[props.size] === "number") {
    return props.sizes[props.size];
  }
  return +((_a = props.sizes[props.size]) == null ? void 0 : _a.value) || +((_b = props.sizes.md) == null ? void 0 : _b.value);
}

// node_modules/@svelteuidev/core/dist/styles/theme/functions/fns/radius/radius.js
function radius(radii2) {
  var _a;
  const theme4 = ((_a = useSvelteUIThemeContext()) == null ? void 0 : _a.theme) || useSvelteUITheme();
  if (typeof radii2 === "number") {
    return radii2;
  }
  return theme4.radii[radii2].value;
}

// node_modules/@svelteuidev/core/dist/styles/theme/utils/to-rgba/to-rgba.js
function isHexColor(hex) {
  const replaced = hex.replace("#", "");
  return typeof replaced === "string" && replaced.length === 6 && !Number.isNaN(Number(`0x${replaced}`));
}
function hexToRgba(color) {
  const replaced = color.replace("#", "");
  const parsed = parseInt(replaced, 16);
  const r = parsed >> 16 & 255;
  const g = parsed >> 8 & 255;
  const b = parsed & 255;
  return {
    r,
    g,
    b,
    a: 1
  };
}
function rgbStringToRgba(color) {
  const [r, g, b, a] = color.replace(/[^0-9,.]/g, "").split(",").map(Number);
  return { r, g, b, a: a || 1 };
}
function toRgba(color) {
  if (isHexColor(color)) {
    return hexToRgba(color);
  }
  if (color.startsWith("rgb")) {
    return rgbStringToRgba(color);
  }
  return {
    r: 0,
    g: 0,
    b: 0,
    a: 1
  };
}

// node_modules/@svelteuidev/core/dist/styles/theme/functions/fns/rgba/rgba.js
function rgba(color, alpha = 1) {
  if (typeof color !== "string" || alpha > 1 || alpha < 0) {
    return "rgba(0, 0, 0, 1)";
  }
  const { r, g, b } = toRgba(color);
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

// node_modules/@svelteuidev/core/dist/styles/theme/functions/fns/variant/variant.js
var DEFAULT_GRADIENT = {
  from: "indigo",
  to: "cyan",
  deg: 45
};
function variant({ variant: variant2, color, gradient }) {
  var _a;
  const theme4 = ((_a = useSvelteUIThemeContext()) == null ? void 0 : _a.theme) || useSvelteUITheme();
  const primaryShade = 6;
  if (variant2 === "light") {
    return {
      border: "transparent",
      background: [rgba(themeColor(color, 8), 0.35), rgba(themeColor(color, 0), 1)],
      color: [
        color === "dark" ? themeColor("dark", 0) : themeColor(color, 2),
        color === "dark" ? themeColor("dark", 9) : themeColor(color, primaryShade)
      ],
      // themeColor(color, theme.colorScheme === 'dark' ? 2 : getPrimaryShade('light')),
      hover: [rgba(themeColor(color, 7), 0.45), rgba(themeColor(color, 1), 0.65)]
    };
  }
  if (variant2 === "default") {
    return {
      border: [themeColor("dark", 5), themeColor("gray", 4)],
      background: [themeColor("dark", 5), theme4.colors.white.value],
      color: [theme4.colors.white.value, theme4.colors.black.value],
      hover: [themeColor("dark", 4), themeColor("gray", 0)]
    };
  }
  if (variant2 === "white") {
    return {
      border: "transparent",
      background: theme4.colors.white.value,
      color: themeColor(color, primaryShade),
      hover: null
    };
  }
  if (variant2 === "outline") {
    return {
      border: [themeColor(color, 4), themeColor(color, primaryShade)],
      background: "transparent",
      color: [themeColor(color, 4), themeColor(color, primaryShade)],
      hover: [rgba(themeColor(color, 4), 0.05), rgba(themeColor(color, 0), 0.35)]
    };
  }
  if (variant2 === "gradient") {
    const merged = {
      from: (gradient == null ? void 0 : gradient.from) || DEFAULT_GRADIENT.from,
      to: (gradient == null ? void 0 : gradient.to) || DEFAULT_GRADIENT.to,
      deg: (gradient == null ? void 0 : gradient.deg) || DEFAULT_GRADIENT.deg
    };
    return {
      background: `linear-gradient(${merged.deg}deg, ${themeColor(merged.from, primaryShade)} 0%, ${themeColor(merged.to, primaryShade)} 100%)`,
      color: theme4.colors.white.value,
      border: "transparent",
      hover: null
    };
  }
  if (variant2 === "subtle") {
    return {
      border: "transparent",
      background: "transparent",
      color: [
        color === "dark" ? themeColor("dark", 0) : themeColor(color, 2),
        color === "dark" ? themeColor("dark", 9) : themeColor(color, primaryShade)
      ],
      hover: [rgba(themeColor(color, 8), 0.35), rgba(themeColor(color, 0), 1)]
    };
  }
  return {
    border: "transparent",
    background: [themeColor(color, 8), themeColor(color, primaryShade)],
    color: theme4.colors.white.value,
    hover: themeColor(color, 7)
  };
}

// node_modules/@svelteuidev/core/dist/styles/theme/functions/fns/index.js
var fns = {
  cover,
  size,
  radius,
  themeColor,
  variant,
  rgba
};

// node_modules/@svelteuidev/core/dist/styles/theme/SvelteUIProvider/default-theme.js
function useSvelteUITheme() {
  var _a, _b;
  let observer;
  (_a = colorScheme) == null ? void 0 : _a.subscribe((mode) => {
    observer = mode;
  });
  const DEFAULT_THEME = {
    // @ts-ignore
    ...theme,
    colorNames: colorNameMap,
    colorScheme: observer,
    dark: (_b = dark) == null ? void 0 : _b.selector,
    fn: {
      cover: fns.cover,
      themeColor: fns.themeColor,
      size: fns.size,
      radius: fns.radius,
      rgba: fns.rgba,
      variant: fns.variant
    }
  };
  return DEFAULT_THEME;
}

// node_modules/@svelteuidev/core/dist/styles/theme/SvelteUIProvider/SvelteUIProvider.svelte
var file = "node_modules/@svelteuidev/core/dist/styles/theme/SvelteUIProvider/SvelteUIProvider.svelte";
function create_fragment2(ctx8) {
  let div;
  let div_class_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx8[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[18],
    null
  );
  let div_levels = [
    { id: "SVELTEUI_PROVIDER" },
    {
      class: div_class_value = /*cx*/
      ctx8[5](
        /*className*/
        ctx8[2],
        /*classes*/
        ctx8[4].root,
        /*currentTheme*/
        ctx8[3]
      )
    },
    /*$$restProps*/
    ctx8[7]
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign(div_data, div_levels[i2]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true, class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file, 49, 0, 1954);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx8[20](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div,
            /*use*/
            ctx8[1]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx8[6].call(null, div))
        ];
        mounted = true;
      }
    },
    p: function update(ctx9, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[18],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { id: "SVELTEUI_PROVIDER" },
        (!current || dirty & /*cx, className, classes, currentTheme*/
        60 && div_class_value !== (div_class_value = /*cx*/
        ctx9[5](
          /*className*/
          ctx9[2],
          /*classes*/
          ctx9[4].root,
          /*currentTheme*/
          ctx9[3]
        ))) && { class: div_class_value },
        dirty & /*$$restProps*/
        128 && /*$$restProps*/
        ctx9[7]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      2)
        useActions_action.update.call(
          null,
          /*use*/
          ctx9[1]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx8[20](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let overrides;
  let mergedTheme;
  let cx2;
  let classes;
  const omit_props_names = [
    "use",
    "class",
    "element",
    "theme",
    "styles",
    "defaultProps",
    "themeObserver",
    "withNormalizeCSS",
    "withGlobalStyles",
    "override",
    "inherit"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $colorScheme;
  validate_store(colorScheme, "colorScheme");
  component_subscribe($$self, colorScheme, ($$value) => $$invalidate(21, $colorScheme = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SvelteUIProvider", slots, ["default"]);
  let { use = [], class: className = "", element: element2 = void 0, theme: theme4 = useSvelteUITheme(), styles = {}, defaultProps = {}, themeObserver = "light", withNormalizeCSS = false, withGlobalStyles = false, override = {}, inherit = false } = $$props;
  beforeUpdate(() => {
    const htmlClassList = document.documentElement.classList;
    if ($colorScheme === "dark")
      htmlClassList.add(dark.className);
    if ($colorScheme === "light")
      htmlClassList.remove(dark.className);
  });
  const ctx8 = useSvelteUIThemeContext();
  const useStyles = createStyles(() => ({ root: {} }));
  const forwardEvents = createEventForwarder(get_current_component());
  const DEFAULT_THEME = useSvelteUITheme();
  let currentTheme = null;
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("theme" in $$new_props)
      $$invalidate(8, theme4 = $$new_props.theme);
    if ("styles" in $$new_props)
      $$invalidate(9, styles = $$new_props.styles);
    if ("defaultProps" in $$new_props)
      $$invalidate(10, defaultProps = $$new_props.defaultProps);
    if ("themeObserver" in $$new_props)
      $$invalidate(11, themeObserver = $$new_props.themeObserver);
    if ("withNormalizeCSS" in $$new_props)
      $$invalidate(12, withNormalizeCSS = $$new_props.withNormalizeCSS);
    if ("withGlobalStyles" in $$new_props)
      $$invalidate(13, withGlobalStyles = $$new_props.withGlobalStyles);
    if ("override" in $$new_props)
      $$invalidate(14, override = $$new_props.override);
    if ("inherit" in $$new_props)
      $$invalidate(15, inherit = $$new_props.inherit);
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    beforeUpdate,
    get_current_component,
    mergeTheme,
    useSvelteUITheme,
    colorScheme,
    key,
    useSvelteUIThemeContext,
    createStyles,
    dark,
    NormalizeCSS,
    SvelteUIGlobalCSS,
    createEventForwarder,
    useActions,
    use,
    className,
    element: element2,
    theme: theme4,
    styles,
    defaultProps,
    themeObserver,
    withNormalizeCSS,
    withGlobalStyles,
    override,
    inherit,
    ctx: ctx8,
    useStyles,
    forwardEvents,
    DEFAULT_THEME,
    currentTheme,
    classes,
    cx: cx2,
    overrides,
    mergedTheme,
    $colorScheme
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("theme" in $$props)
      $$invalidate(8, theme4 = $$new_props.theme);
    if ("styles" in $$props)
      $$invalidate(9, styles = $$new_props.styles);
    if ("defaultProps" in $$props)
      $$invalidate(10, defaultProps = $$new_props.defaultProps);
    if ("themeObserver" in $$props)
      $$invalidate(11, themeObserver = $$new_props.themeObserver);
    if ("withNormalizeCSS" in $$props)
      $$invalidate(12, withNormalizeCSS = $$new_props.withNormalizeCSS);
    if ("withGlobalStyles" in $$props)
      $$invalidate(13, withGlobalStyles = $$new_props.withGlobalStyles);
    if ("override" in $$props)
      $$invalidate(14, override = $$new_props.override);
    if ("inherit" in $$props)
      $$invalidate(15, inherit = $$new_props.inherit);
    if ("currentTheme" in $$props)
      $$invalidate(3, currentTheme = $$new_props.currentTheme);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(5, cx2 = $$new_props.cx);
    if ("overrides" in $$props)
      $$invalidate(16, overrides = $$new_props.overrides);
    if ("mergedTheme" in $$props)
      $$invalidate(17, mergedTheme = $$new_props.mergedTheme);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*inherit, theme, styles, defaultProps*/
    34560) {
      $:
        $$invalidate(16, overrides = {
          themeOverride: inherit ? { ...ctx8.theme, ...theme4 } : theme4,
          styles: inherit ? { ...ctx8.styles, ...styles } : styles,
          defaultProps: inherit ? { ...ctx8.styles, ...defaultProps } : defaultProps
        });
    }
    if ($$self.$$.dirty & /*overrides*/
    65536) {
      $:
        $$invalidate(17, mergedTheme = mergeTheme(DEFAULT_THEME, overrides.themeOverride));
    }
    if ($$self.$$.dirty & /*themeObserver, mergedTheme*/
    133120) {
      $: {
        if (themeObserver !== null) {
          $$invalidate(3, currentTheme = themeObserver === "light" ? mergedTheme : dark);
        }
      }
    }
    if ($$self.$$.dirty & /*withGlobalStyles*/
    8192) {
      $:
        if (withGlobalStyles)
          SvelteUIGlobalCSS();
    }
    if ($$self.$$.dirty & /*withNormalizeCSS*/
    4096) {
      $:
        if (withNormalizeCSS)
          NormalizeCSS();
    }
    if ($$self.$$.dirty & /*overrides*/
    65536) {
      $:
        setContext(key, {
          theme: overrides.themeOverride,
          styles: {},
          defaultProps: {}
        });
    }
    if ($$self.$$.dirty & /*themeObserver*/
    2048) {
      $:
        colorScheme.set(themeObserver);
    }
    if ($$self.$$.dirty & /*override*/
    16384) {
      $:
        $$invalidate(5, { cx: cx2, classes } = useStyles(null, { override }), cx2, ($$invalidate(4, classes), $$invalidate(14, override)));
    }
  };
  return [
    element2,
    use,
    className,
    currentTheme,
    classes,
    cx2,
    forwardEvents,
    $$restProps,
    theme4,
    styles,
    defaultProps,
    themeObserver,
    withNormalizeCSS,
    withGlobalStyles,
    override,
    inherit,
    overrides,
    mergedTheme,
    $$scope,
    slots,
    div_binding
  ];
}
var SvelteUIProvider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      use: 1,
      class: 2,
      element: 0,
      theme: 8,
      styles: 9,
      defaultProps: 10,
      themeObserver: 11,
      withNormalizeCSS: 12,
      withGlobalStyles: 13,
      override: 14,
      inherit: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SvelteUIProvider",
      options,
      id: create_fragment2.name
    });
  }
  get use() {
    throw new Error("<SvelteUIProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<SvelteUIProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SvelteUIProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SvelteUIProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<SvelteUIProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<SvelteUIProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<SvelteUIProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<SvelteUIProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get styles() {
    throw new Error("<SvelteUIProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set styles(value) {
    throw new Error("<SvelteUIProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get defaultProps() {
    throw new Error("<SvelteUIProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultProps(value) {
    throw new Error("<SvelteUIProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get themeObserver() {
    throw new Error("<SvelteUIProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set themeObserver(value) {
    throw new Error("<SvelteUIProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withNormalizeCSS() {
    throw new Error("<SvelteUIProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withNormalizeCSS(value) {
    throw new Error("<SvelteUIProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withGlobalStyles() {
    throw new Error("<SvelteUIProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withGlobalStyles(value) {
    throw new Error("<SvelteUIProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<SvelteUIProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<SvelteUIProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inherit() {
    throw new Error("<SvelteUIProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inherit(value) {
    throw new Error("<SvelteUIProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SvelteUIProvider_default = SvelteUIProvider;

// node_modules/@svelteuidev/core/dist/styles/theme/utils/get-size/get-size.js
function getSize({ size: size3, sizes: sizes15, units }) {
  if (size3 in sizes15) {
    return sizes15[size3];
  }
  if (typeof size3 === "number") {
    return units === "em" ? em(size3) : rem(size3);
  }
  return size3 || sizes15.md;
}

// node_modules/@svelteuidev/core/dist/styles/theme/utils/get-variant-theme/get-variant-theme.js
var vFunc = (color, gradient) => {
  const { themeColor: themeColor2, rgba: rgba4 } = fns;
  const variants = {
    /** Filled variant */
    filled: {
      [`${dark.selector} &`]: {
        backgroundColor: themeColor2(color, 8)
      },
      border: "transparent",
      backgroundColor: themeColor2(color, 6),
      color: "White",
      "&:hover": { backgroundColor: themeColor2(color, 7) }
    },
    /** Light variant */
    light: {
      [`${dark.selector} &`]: {
        backgroundColor: rgba4(themeColor2(color, 8), 0.35),
        color: color === "dark" ? themeColor2("dark", 0) : themeColor2(color, 2),
        "&:hover": { backgroundColor: rgba4(themeColor2(color, 7), 0.45) }
      },
      border: "transparent",
      backgroundColor: themeColor2(color, 0),
      color: color === "dark" ? themeColor2("dark", 9) : themeColor2(color, 6),
      "&:hover": { backgroundColor: themeColor2(color, 1) }
    },
    /** Outline variant */
    outline: {
      [`${dark.selector} &`]: {
        border: `1px solid ${themeColor2(color, 4)}`,
        color: `${themeColor2(color, 4)}`,
        "&:hover": { backgroundColor: rgba4(themeColor2(color, 4), 0.05) }
      },
      border: `1px solid ${themeColor2(color, 7)}`,
      backgroundColor: "transparent",
      color: themeColor2(color, 7),
      "&:hover": {
        backgroundColor: rgba4(themeColor2(color, 0), 0.35)
      }
    },
    /** Subtle variant */
    subtle: {
      [`${dark.selector} &`]: {
        color: color === "dark" ? themeColor2("dark", 0) : themeColor2(color, 2),
        "&:hover": { backgroundColor: rgba4(themeColor2(color, 8), 0.35) }
      },
      border: "transparent",
      backgroundColor: "transparent",
      color: color === "dark" ? themeColor2("dark", 9) : themeColor2(color, 6),
      "&:hover": {
        backgroundColor: themeColor2(color, 0)
      }
    },
    /** Default variant */
    default: {
      [`${dark.selector} &`]: {
        border: `1px solid ${themeColor2("dark", 5)}`,
        backgroundColor: themeColor2("dark", 5),
        color: "White",
        "&:hover": { backgroundColor: themeColor2("dark", 4) }
      },
      border: `1px solid ${themeColor2("gray", 4)}`,
      backgroundColor: "White",
      color: "Black",
      "&:hover": { backgroundColor: themeColor2("gray", 0) }
    },
    /** White variant */
    white: {
      border: "transparent",
      backgroundColor: "White",
      color: themeColor2(color, 7),
      "&:hover": { backgroundColor: "White" }
    },
    gradient: {}
  };
  if (gradient) {
    variants.gradient = {
      border: "transparent",
      background: `linear-gradient(${gradient.deg}deg, $${gradient.from}600 0%, $${gradient.to}600 100%)`,
      color: "White"
    };
  }
  return variants;
};

// node_modules/@svelteuidev/core/dist/styles/theme/utils/random-id/random-id.js
function randomID(prefix = "svelteui") {
  return `${prefix}-${Math.random().toString(36).substring(2, 10)}`;
}

// node_modules/@svelteuidev/core/dist/styles/theme/utils/merge-theme/merge-theme.js
function mergeTheme(currentTheme, themeOverride) {
  if (!themeOverride) {
    return currentTheme;
  }
  return Object.keys(currentTheme).reduce((acc, key3) => {
    acc[key3] = typeof themeOverride[key3] === "object" ? { ...currentTheme[key3], ...themeOverride[key3] } : typeof themeOverride[key3] === "number" ? themeOverride[key3] : themeOverride[key3] || currentTheme[key3];
    return acc;
  }, {});
}

// node_modules/@svelteuidev/core/dist/styles/engine/css.js
var hasOwn = {}.hasOwnProperty;
function cx(...args) {
  const classes = [];
  for (let i2 = 0; i2 < args.length; i2++) {
    const arg = args[i2];
    if (!arg)
      continue;
    const argType = typeof arg;
    if (argType === "string" || argType === "number") {
      classes.push(arg);
    } else if (Array.isArray(arg)) {
      if (arg.length) {
        const inner = { ...arg };
        if (inner) {
          classes.push(inner);
        }
      }
    } else if (argType === "object") {
      if (arg.toString === Object.prototype.toString) {
        for (const key3 in arg) {
          if (hasOwn.call(arg, key3) && arg[key3]) {
            classes.push(key3);
          }
        }
      } else {
        classes.push(arg.toString());
      }
    }
  }
  return classes.join(" ");
}
function cssFactory() {
  return { cx };
}

// node_modules/@svelteuidev/core/dist/styles/engine/utils/from-entries/from-entries.js
function fromEntries(entries) {
  const o = {};
  Object.keys(entries).forEach((key3) => {
    const [k, v] = entries[key3];
    o[k] = v;
  });
  return o;
}

// node_modules/@svelteuidev/core/dist/styles/engine/create-styles.js
var CLASS_KEY = "svelteui";
function createRef(refName) {
  return `__svelteui-ref-${refName || ""}`;
}
function sanitizeCss(object, theme4) {
  const refs = [];
  const classMap = {};
  const _sanitizeVariants = (obj) => {
    const variantsObject = obj.variation ?? obj;
    const variants = Object.keys(variantsObject);
    for (const variant2 of variants) {
      _sanitize(variantsObject[variant2]);
    }
  };
  const _sanitize = (obj) => {
    Object.keys(obj).map((value) => {
      if (value === "variants") {
        _sanitizeVariants(obj[value]);
        return;
      }
      if (value === "ref") {
        refs.push(obj.ref);
      }
      if (value === "darkMode") {
        obj[`${theme4.dark} &`] = obj.darkMode;
      }
      if (obj[value] === null || typeof obj[value] !== "object")
        return;
      _sanitize(obj[value]);
      if (value === "darkMode") {
        delete obj[value];
      } else if (value.startsWith("@media")) {
      } else if (!value.startsWith("&") && !value.startsWith(theme4.dark)) {
        const getStyles = css(obj[value]);
        classMap[value] = getStyles().toString();
        obj[`& .${getStyles().toString()}`] = obj[value];
        delete obj[value];
      }
    });
  };
  _sanitize(object);
  delete object["& .root"];
  return { classMap, refs: Array.from(new Set(refs)) };
}
function createStyles(input) {
  const getCssObject = typeof input === "function" ? input : () => input;
  function useStyles(params = {}, options) {
    var _a;
    const theme4 = ((_a = useSvelteUIThemeContext()) == null ? void 0 : _a.theme) || useSvelteUITheme();
    const { cx: cx2 } = cssFactory();
    const { override, name } = options || {};
    const dirtyCssObject = getCssObject(theme4, params, createRef);
    const sanitizedCss = Object.assign({}, dirtyCssObject);
    const { classMap, refs } = sanitizeCss(sanitizedCss, theme4);
    const root = dirtyCssObject["root"] ?? void 0;
    const cssObjectClean = root !== void 0 ? { ...root, ...sanitizedCss } : dirtyCssObject;
    const getStyles = css(cssObjectClean);
    const classes = fromEntries(Object.keys(dirtyCssObject).map((keys) => {
      const ref = refs.find((r) => r.includes(keys)) ?? "";
      const getRefName = (ref == null ? void 0 : ref.split("-")) ?? [];
      const keyIsRef = (ref == null ? void 0 : ref.split("-")[(getRefName == null ? void 0 : getRefName.length) - 1]) === keys;
      const value = keys.toString();
      let transformedClasses = classMap[value] ?? value;
      if (ref && keyIsRef) {
        transformedClasses = `${transformedClasses} ${ref}`;
      }
      if (keys === "root") {
        transformedClasses = getStyles({ css: override }).toString();
      }
      let libClass = `${CLASS_KEY}-${keys.toString()}`;
      if (name) {
        libClass = `${CLASS_KEY}-${name}-${keys.toString()}`;
        transformedClasses = `${transformedClasses} ${libClass}`;
      }
      return [keys, transformedClasses];
    }));
    return {
      cx: cx2,
      theme: theme4,
      classes,
      getStyles: css(cssObjectClean)
    };
  }
  return useStyles;
}

// node_modules/@svelteuidev/core/dist/styles/ssr.js
var prepareStylesSSR = async ({ event, resolve }) => {
  return await resolve(event, {
    transformPageChunk: ({ html }) => {
      const headEndIndex = html.indexOf("</head>");
      const returnHtml = html.slice(0, headEndIndex) + `<style id="stitches">${getCssText()}</style>` + html.slice(headEndIndex);
      return returnHtml;
    }
  });
};

// node_modules/@svelteuidev/core/dist/components/Box/context/get-system-styles/get-system-styles.js
var SYSTEM_PROPS = {
  mt: "marginTop",
  mb: "marginBottom",
  ml: "marginLeft",
  mr: "marginRight",
  pt: "paddingTop",
  pb: "paddingBottom",
  pl: "paddingLeft",
  pr: "paddingRight"
};
var NEGATIVE_VALUES = ["-xs", "-sm", "-md", "-lg", "-xl"];
function isValidSizeValue(margin) {
  return typeof margin === "string" || typeof margin === "number";
}
function getSizeValue(margin, theme4) {
  if (NEGATIVE_VALUES.includes(margin)) {
    return theme4.fn.size({ size: margin.replace("-", ""), sizes: theme4.space }) * -1;
  }
  return theme4.fn.size({ size: margin, sizes: theme4.space });
}
function getSystemStyles(systemStyles, theme4) {
  const styles = {};
  if (isValidSizeValue(systemStyles.p)) {
    const value = getSizeValue(systemStyles.p, theme4);
    styles.padding = value;
  }
  if (isValidSizeValue(systemStyles.m)) {
    const value = getSizeValue(systemStyles.m, theme4);
    styles.margin = value;
  }
  if (isValidSizeValue(systemStyles.py)) {
    const value = getSizeValue(systemStyles.py, theme4);
    styles.paddingTop = value;
    styles.paddingBottom = value;
  }
  if (isValidSizeValue(systemStyles.px)) {
    const value = getSizeValue(systemStyles.px, theme4);
    styles.paddingLeft = value;
    styles.paddingRight = value;
  }
  if (isValidSizeValue(systemStyles.my)) {
    const value = getSizeValue(systemStyles.my, theme4);
    styles.marginTop = value;
    styles.marginBottom = value;
  }
  if (isValidSizeValue(systemStyles.mx)) {
    const value = getSizeValue(systemStyles.mx, theme4);
    styles.marginLeft = value;
    styles.marginRight = value;
  }
  Object.keys(SYSTEM_PROPS).forEach((property) => {
    if (isValidSizeValue(systemStyles[property])) {
      styles[SYSTEM_PROPS[property]] = theme4.fn.size({
        size: getSizeValue(systemStyles[property], theme4),
        sizes: theme4.space
      });
    }
  });
  return styles;
}

// node_modules/@svelteuidev/core/dist/components/Box/Box.svelte
var file2 = "node_modules/@svelteuidev/core/dist/components/Box/Box.svelte";
function create_else_block(ctx8) {
  let div;
  let div_class_value;
  let forwardEvents_action;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx8[28].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[32],
    null
  );
  let div_levels = [
    {
      class: div_class_value = /*className*/
      ctx8[2] + " " + /*BoxStyles*/
      ctx8[7]({
        css: {
          .../*getCSSStyles*/
          ctx8[8](
            /*theme*/
            ctx8[11]
          ),
          .../*systemStyles*/
          ctx8[6]
        }
      })
    },
    /*$$restProps*/
    ctx8[12]
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign(div_data, div_levels[i2]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file2, 74, 1, 2266);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx8[31](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx8[9].call(null, div)),
          action_destroyer(useActions_action = useActions.call(
            null,
            div,
            /*use*/
            ctx8[1]
          ))
        ];
        mounted = true;
      }
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[32],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[32]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[32],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*className, BoxStyles, getCSSStyles, systemStyles*/
        452 && div_class_value !== (div_class_value = /*className*/
        ctx9[2] + " " + /*BoxStyles*/
        ctx9[7]({
          css: {
            .../*getCSSStyles*/
            ctx9[8](
              /*theme*/
              ctx9[11]
            ),
            .../*systemStyles*/
            ctx9[6]
          }
        }))) && { class: div_class_value },
        dirty[0] & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx9[12]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/
      2)
        useActions_action.update.call(
          null,
          /*use*/
          ctx9[1]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx8[31](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(74:0) {:else}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_1(ctx8) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    {
      use: [
        /*forwardEvents*/
        ctx8[9],
        [
          useActions,
          /*use*/
          ctx8[1]
        ]
      ]
    },
    {
      class: (
        /*className*/
        ctx8[2] + " " + /*BoxStyles*/
        ctx8[7]({
          css: {
            .../*getCSSStyles*/
            ctx8[8](
              /*theme*/
              ctx8[11]
            ),
            .../*systemStyles*/
            ctx8[6]
          }
        })
      )
    },
    /*$$restProps*/
    ctx8[12]
  ];
  var switch_value = (
    /*root*/
    ctx8[3]
  );
  function switch_props(ctx9, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx: ctx9 }
    };
    for (let i2 = 0; i2 < switch_instance_spread_levels.length; i2 += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i2]);
    }
    if (dirty !== void 0 && dirty[0] & /*forwardEvents, use, className, BoxStyles, getCSSStyles, theme, systemStyles, $$restProps*/
    7110) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
        dirty[0] & /*forwardEvents, use*/
        514 && {
          use: [
            /*forwardEvents*/
            ctx9[9],
            [
              useActions,
              /*use*/
              ctx9[1]
            ]
          ]
        },
        dirty[0] & /*className, BoxStyles, getCSSStyles, theme, systemStyles*/
        2500 && {
          class: (
            /*className*/
            ctx9[2] + " " + /*BoxStyles*/
            ctx9[7]({
              css: {
                .../*getCSSStyles*/
                ctx9[8](
                  /*theme*/
                  ctx9[11]
                ),
                .../*systemStyles*/
                ctx9[6]
              }
            })
          )
        },
        dirty[0] & /*$$restProps*/
        4096 && get_spread_object(
          /*$$restProps*/
          ctx9[12]
        )
      ]));
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx8));
    ctx8[30](switch_instance);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*root*/
      8 && switch_value !== (switch_value = /*root*/
      ctx9[3])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx9, dirty));
          ctx9[30](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty[0] & /*forwardEvents, use, className, BoxStyles, getCSSStyles, theme, systemStyles, $$restProps*/
        7110 ? get_spread_update(switch_instance_spread_levels, [
          dirty[0] & /*forwardEvents, use*/
          514 && {
            use: [
              /*forwardEvents*/
              ctx9[9],
              [
                useActions,
                /*use*/
                ctx9[1]
              ]
            ]
          },
          dirty[0] & /*className, BoxStyles, getCSSStyles, theme, systemStyles*/
          2500 && {
            class: (
              /*className*/
              ctx9[2] + " " + /*BoxStyles*/
              ctx9[7]({
                css: {
                  .../*getCSSStyles*/
                  ctx9[8](
                    /*theme*/
                    ctx9[11]
                  ),
                  .../*systemStyles*/
                  ctx9[6]
                }
              })
            )
          },
          dirty[0] & /*$$restProps*/
          4096 && get_spread_object(
            /*$$restProps*/
            ctx9[12]
          )
        ]) : {};
        if (dirty[1] & /*$$scope*/
        2) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx9 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      ctx8[30](null);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(64:50) ",
    ctx: ctx8
  });
  return block;
}
function create_if_block2(ctx8) {
  let current;
  validate_dynamic_element(
    /*castRoot*/
    ctx8[10]()
  );
  validate_void_dynamic_element(
    /*castRoot*/
    ctx8[10]()
  );
  let svelte_element = (
    /*castRoot*/
    ctx8[10]() && create_dynamic_element(ctx8)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (
        /*castRoot*/
        ctx9[10]()
      ) {
        svelte_element.p(ctx9, dirty);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(52:0) {#if isHTMLElement}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[28].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[32],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[32],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[32]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[32],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: '(65:1) <svelte:component   this={root}   bind:this={element}   use={[forwardEvents, [useActions, use]]}   class=\\"{className} {BoxStyles({ css: { ...getCSSStyles(theme), ...systemStyles } })}\\"   {...$$restProps}  >',
    ctx: ctx8
  });
  return block;
}
function create_dynamic_element(ctx8) {
  let svelte_element;
  let svelte_element_class_value;
  let forwardEvents_action;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx8[28].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[32],
    null
  );
  let svelte_element_levels = [
    {
      class: svelte_element_class_value = /*className*/
      ctx8[2] + " " + /*BoxStyles*/
      ctx8[7]({
        css: {
          .../*getCSSStyles*/
          ctx8[8](
            /*theme*/
            ctx8[11]
          ),
          .../*systemStyles*/
          ctx8[6]
        }
      })
    },
    /*$$restProps*/
    ctx8[12]
  ];
  let svelte_element_data = {};
  for (let i2 = 0; i2 < svelte_element_levels.length; i2 += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i2]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*castRoot*/
        ctx8[10]()
      );
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*castRoot*/
        (ctx8[10]() || "null").toUpperCase(),
        { class: true }
      );
      var svelte_element_nodes = children(svelte_element);
      if (default_slot)
        default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_dynamic_element_data(
        /*castRoot*/
        ctx8[10]()
      )(svelte_element, svelte_element_data);
      add_location(svelte_element, file2, 53, 1, 1722);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      ctx8[29](svelte_element);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx8[9].call(null, svelte_element)),
          action_destroyer(useActions_action = useActions.call(
            null,
            svelte_element,
            /*use*/
            ctx8[1]
          ))
        ];
        mounted = true;
      }
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[32],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[32]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[32],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_dynamic_element_data(
        /*castRoot*/
        ctx9[10]()
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty[0] & /*className, BoxStyles, getCSSStyles, systemStyles*/
        452 && svelte_element_class_value !== (svelte_element_class_value = /*className*/
        ctx9[2] + " " + /*BoxStyles*/
        ctx9[7]({
          css: {
            .../*getCSSStyles*/
            ctx9[8](
              /*theme*/
              ctx9[11]
            ),
            .../*systemStyles*/
            ctx9[6]
          }
        }))) && { class: svelte_element_class_value },
        dirty[0] & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx9[12]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/
      2)
        useActions_action.update.call(
          null,
          /*use*/
          ctx9[1]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx8[29](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element.name,
    type: "child_dynamic_element",
    source: '(54:1) <svelte:element   bind:this={element}   this={castRoot()}   use:forwardEvents   use:useActions={use}   class=\\"{className} {BoxStyles({ css: {...getCSSStyles(theme), ...systemStyles} })}\\"   {...$$restProps}  >',
    ctx: ctx8
  });
  return block;
}
function create_fragment3(ctx8) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block2, create_if_block_1, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx9, dirty) {
    if (
      /*isHTMLElement*/
      ctx9[4]
    )
      return 0;
    if (
      /*isComponent*/
      ctx9[5] && typeof /*root*/
      ctx9[3] !== "string"
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx8, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx8);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx9, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx9, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx9);
          if_block.c();
        } else {
          if_block.p(ctx9, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  var _a;
  let getCSSStyles;
  let BoxStyles;
  let systemStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "css",
    "root",
    "m",
    "my",
    "mx",
    "mt",
    "mb",
    "ml",
    "mr",
    "p",
    "py",
    "px",
    "pt",
    "pb",
    "pl",
    "pr"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Box", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", css: css2 = {}, root = void 0, m = void 0, my = void 0, mx = void 0, mt = void 0, mb = void 0, ml = void 0, mr = void 0, p = void 0, py = void 0, px = void 0, pt = void 0, pb = void 0, pl = void 0, pr = void 0 } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  const castRoot = () => root;
  const theme4 = ((_a = useSvelteUIThemeContext()) == null ? void 0 : _a.theme) || useSvelteUITheme();
  let isHTMLElement;
  let isComponent;
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("css" in $$new_props)
      $$invalidate(13, css2 = $$new_props.css);
    if ("root" in $$new_props)
      $$invalidate(3, root = $$new_props.root);
    if ("m" in $$new_props)
      $$invalidate(14, m = $$new_props.m);
    if ("my" in $$new_props)
      $$invalidate(15, my = $$new_props.my);
    if ("mx" in $$new_props)
      $$invalidate(16, mx = $$new_props.mx);
    if ("mt" in $$new_props)
      $$invalidate(17, mt = $$new_props.mt);
    if ("mb" in $$new_props)
      $$invalidate(18, mb = $$new_props.mb);
    if ("ml" in $$new_props)
      $$invalidate(19, ml = $$new_props.ml);
    if ("mr" in $$new_props)
      $$invalidate(20, mr = $$new_props.mr);
    if ("p" in $$new_props)
      $$invalidate(21, p = $$new_props.p);
    if ("py" in $$new_props)
      $$invalidate(22, py = $$new_props.py);
    if ("px" in $$new_props)
      $$invalidate(23, px = $$new_props.px);
    if ("pt" in $$new_props)
      $$invalidate(24, pt = $$new_props.pt);
    if ("pb" in $$new_props)
      $$invalidate(25, pb = $$new_props.pb);
    if ("pl" in $$new_props)
      $$invalidate(26, pl = $$new_props.pl);
    if ("pr" in $$new_props)
      $$invalidate(27, pr = $$new_props.pr);
    if ("$$scope" in $$new_props)
      $$invalidate(32, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getSystemStyles,
    _css: css,
    useSvelteUITheme,
    useSvelteUIThemeContext,
    createEventForwarder,
    useActions,
    get_current_component,
    use,
    element: element2,
    className,
    css: css2,
    root,
    m,
    my,
    mx,
    mt,
    mb,
    ml,
    mr,
    p,
    py,
    px,
    pt,
    pb,
    pl,
    pr,
    forwardEvents,
    castRoot,
    theme: theme4,
    isHTMLElement,
    isComponent,
    systemStyles,
    BoxStyles,
    getCSSStyles
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("css" in $$props)
      $$invalidate(13, css2 = $$new_props.css);
    if ("root" in $$props)
      $$invalidate(3, root = $$new_props.root);
    if ("m" in $$props)
      $$invalidate(14, m = $$new_props.m);
    if ("my" in $$props)
      $$invalidate(15, my = $$new_props.my);
    if ("mx" in $$props)
      $$invalidate(16, mx = $$new_props.mx);
    if ("mt" in $$props)
      $$invalidate(17, mt = $$new_props.mt);
    if ("mb" in $$props)
      $$invalidate(18, mb = $$new_props.mb);
    if ("ml" in $$props)
      $$invalidate(19, ml = $$new_props.ml);
    if ("mr" in $$props)
      $$invalidate(20, mr = $$new_props.mr);
    if ("p" in $$props)
      $$invalidate(21, p = $$new_props.p);
    if ("py" in $$props)
      $$invalidate(22, py = $$new_props.py);
    if ("px" in $$props)
      $$invalidate(23, px = $$new_props.px);
    if ("pt" in $$props)
      $$invalidate(24, pt = $$new_props.pt);
    if ("pb" in $$props)
      $$invalidate(25, pb = $$new_props.pb);
    if ("pl" in $$props)
      $$invalidate(26, pl = $$new_props.pl);
    if ("pr" in $$props)
      $$invalidate(27, pr = $$new_props.pr);
    if ("isHTMLElement" in $$props)
      $$invalidate(4, isHTMLElement = $$new_props.isHTMLElement);
    if ("isComponent" in $$props)
      $$invalidate(5, isComponent = $$new_props.isComponent);
    if ("systemStyles" in $$props)
      $$invalidate(6, systemStyles = $$new_props.systemStyles);
    if ("BoxStyles" in $$props)
      $$invalidate(7, BoxStyles = $$new_props.BoxStyles);
    if ("getCSSStyles" in $$props)
      $$invalidate(8, getCSSStyles = $$new_props.getCSSStyles);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*css*/
    8192) {
      $:
        $$invalidate(8, getCSSStyles = typeof css2 === "function" ? css2 : () => css2);
    }
    if ($$self.$$.dirty[0] & /*root*/
    8) {
      $: {
        $$invalidate(4, isHTMLElement = root && typeof root === "string");
        $$invalidate(5, isComponent = root && typeof root === "function");
      }
    }
    if ($$self.$$.dirty[0] & /*m, my, mx, mt, mb, ml, mr, p, py, px, pt, pb, pl, pr*/
    268419072) {
      $:
        $$invalidate(6, systemStyles = getSystemStyles(
          {
            m,
            my,
            mx,
            mt,
            mb,
            ml,
            mr,
            p,
            py,
            px,
            pt,
            pb,
            pl,
            pr
          },
          theme4
        ));
    }
  };
  $:
    $$invalidate(7, BoxStyles = css({}));
  return [
    element2,
    use,
    className,
    root,
    isHTMLElement,
    isComponent,
    systemStyles,
    BoxStyles,
    getCSSStyles,
    forwardEvents,
    castRoot,
    theme4,
    $$restProps,
    css2,
    m,
    my,
    mx,
    mt,
    mb,
    ml,
    mr,
    p,
    py,
    px,
    pt,
    pb,
    pl,
    pr,
    slots,
    svelte_element_binding,
    switch_instance_binding,
    div_binding,
    $$scope
  ];
}
var Box = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        use: 1,
        element: 0,
        class: 2,
        css: 13,
        root: 3,
        m: 14,
        my: 15,
        mx: 16,
        mt: 17,
        mb: 18,
        ml: 19,
        mr: 20,
        p: 21,
        py: 22,
        px: 23,
        pt: 24,
        pb: 25,
        pl: 26,
        pr: 27
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Box",
      options,
      id: create_fragment3.name
    });
  }
  get use() {
    throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get css() {
    throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set css(value) {
    throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get root() {
    throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set root(value) {
    throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get m() {
    throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set m(value) {
    throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get my() {
    throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set my(value) {
    throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mx() {
    throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mx(value) {
    throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mt() {
    throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mt(value) {
    throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mb() {
    throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mb(value) {
    throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ml() {
    throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ml(value) {
    throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mr() {
    throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mr(value) {
    throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get p() {
    throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set p(value) {
    throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get py() {
    throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set py(value) {
    throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get px() {
    throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set px(value) {
    throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pt() {
    throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pt(value) {
    throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pb() {
    throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pb(value) {
    throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pl() {
    throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pl(value) {
    throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pr() {
    throw new Error("<Box>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pr(value) {
    throw new Error("<Box>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Box_default = Box;

// node_modules/@svelteuidev/core/dist/components/Accordion/key.js
var key2 = Symbol();

// node_modules/@svelteuidev/core/dist/components/Accordion/Chevron/Chevron.svelte
var file3 = "node_modules/@svelteuidev/core/dist/components/Accordion/Chevron/Chevron.svelte";
function create_fragment4(ctx8) {
  let svg;
  let path;
  let svg_levels = [
    { viewBox: "0 0 15 15" },
    { fill: "none" },
    { xmlns: "http://www.w3.org/2000/svg" },
    { width: (
      /*size*/
      ctx8[1]
    ) },
    { height: (
      /*size*/
      ctx8[1]
    ) },
    /*$$restProps*/
    ctx8[2]
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign(svg_data, svg_levels[i2]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        viewBox: true,
        fill: true,
        xmlns: true,
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", {
        d: true,
        "fill-rule": true,
        "clip-rule": true,
        fill: true
      });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3.13523 6.15803C3.3241 5.95657 3.64052 5.94637 3.84197 6.13523L7.5 9.56464L11.158 6.13523C11.3595 5.94637 11.6759 5.95657 11.8648 6.15803C12.0536 6.35949 12.0434 6.67591 11.842 6.86477L7.84197 10.6148C7.64964 10.7951 7.35036 10.7951 7.15803 10.6148L3.15803 6.86477C2.95657 6.67591 2.94637 6.35949 3.13523 6.15803Z");
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "clip-rule", "evenodd");
      attr_dev(
        path,
        "fill",
        /*color*/
        ctx8[0]
      );
      add_location(path, file3, 13, 2, 210);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file3, 5, 0, 79);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx9, [dirty]) {
      if (dirty & /*color*/
      1) {
        attr_dev(
          path,
          "fill",
          /*color*/
          ctx9[0]
        );
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { viewBox: "0 0 15 15" },
        { fill: "none" },
        { xmlns: "http://www.w3.org/2000/svg" },
        dirty & /*size*/
        2 && { width: (
          /*size*/
          ctx9[1]
        ) },
        dirty & /*size*/
        2 && { height: (
          /*size*/
          ctx9[1]
        ) },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx9[2]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  const omit_props_names = ["color", "size"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Chevron", slots, []);
  let { color = "currentColor" } = $$props;
  let { size: size3 = 15 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("color" in $$new_props)
      $$invalidate(0, color = $$new_props.color);
    if ("size" in $$new_props)
      $$invalidate(1, size3 = $$new_props.size);
  };
  $$self.$capture_state = () => ({ color, size: size3 });
  $$self.$inject_state = ($$new_props) => {
    if ("color" in $$props)
      $$invalidate(0, color = $$new_props.color);
    if ("size" in $$props)
      $$invalidate(1, size3 = $$new_props.size);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [color, size3, $$restProps];
}
var Chevron = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { color: 0, size: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Chevron",
      options,
      id: create_fragment4.name
    });
  }
  get color() {
    throw new Error("<Chevron>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Chevron>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Chevron>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Chevron>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Chevron_default = Chevron;

// node_modules/@svelteuidev/core/dist/components/Accordion/Accordion.styles.js
var Accordion_styles_default = createStyles((theme4, { radius: radius2, variant: variant2 }) => {
  return {
    root: {}
  };
});

// node_modules/@svelteuidev/core/dist/components/Accordion/Accordion.svelte
function create_default_slot2(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[22].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[24],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16777216)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[24],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[24]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[24],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(107:0) <Box  class={cx(className, classes.root, getStyles({ css: override }))}  bind:element  {use}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment5(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    {
      class: (
        /*cx*/
        ctx8[6](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[5].root,
          /*getStyles*/
          ctx8[4]({ css: (
            /*override*/
            ctx8[3]
          ) })
        )
      )
    },
    { use: (
      /*use*/
      ctx8[1]
    ) },
    /*$$restProps*/
    ctx8[7]
  ];
  function box_element_binding(value) {
    ctx8[23](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot2] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*cx, className, classes, getStyles, override, use, $$restProps*/
      254 ? get_spread_update(box_spread_levels, [
        dirty & /*cx, className, classes, getStyles, override*/
        124 && {
          class: (
            /*cx*/
            ctx9[6](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[5].root,
              /*getStyles*/
              ctx9[4]({ css: (
                /*override*/
                ctx9[3]
              ) })
            )
          )
        },
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*$$restProps*/
        128 && get_spread_object(
          /*$$restProps*/
          ctx9[7]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      16777216) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "variant",
    "value",
    "defaultValue",
    "radius",
    "order",
    "multiple",
    "id",
    "chevron",
    "chevronPosition",
    "chevronSize",
    "disableChevronRotation",
    "transitionDuration"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Accordion", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, variant: variant2 = "default", value = void 0, defaultValue = void 0, radius: radius2 = "sm", order = void 0, multiple = false, id = randomID(), chevron = Chevron_default, chevronPosition = "right", chevronSize = 24, disableChevronRotation = false, transitionDuration = 200 } = $$props;
  const dispatch = createEventDispatcher();
  let _value;
  let stateContent = {
    variant: variant2,
    order,
    radius: radius2,
    chevron,
    chevronPosition,
    chevronSize,
    disableChevronRotation,
    transitionDuration,
    updateActive,
    isItemActive
  };
  const state = writable(stateContent);
  function updateActive(itemValue) {
    if (!multiple) {
      $$invalidate(20, _value = _value === itemValue ? void 0 : itemValue);
      dispatch("change", _value);
      return;
    }
    let values = _value || [];
    if (values.includes(itemValue)) {
      values = values.filter((v) => v !== itemValue);
    } else {
      values.push(itemValue);
    }
    $$invalidate(20, _value = values);
    dispatch("change", _value);
  }
  function isItemActive(itemValue) {
    return multiple ? _value.includes(itemValue) : _value === itemValue;
  }
  function getControlsId(itemValue) {
    return `${id}-${itemValue}-panel`;
  }
  function getRegionId(itemValue) {
    return `${id}-${itemValue}-region`;
  }
  setContext(key2, state);
  function box_element_binding(value2) {
    element2 = value2;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("variant" in $$new_props)
      $$invalidate(8, variant2 = $$new_props.variant);
    if ("value" in $$new_props)
      $$invalidate(9, value = $$new_props.value);
    if ("defaultValue" in $$new_props)
      $$invalidate(10, defaultValue = $$new_props.defaultValue);
    if ("radius" in $$new_props)
      $$invalidate(11, radius2 = $$new_props.radius);
    if ("order" in $$new_props)
      $$invalidate(12, order = $$new_props.order);
    if ("multiple" in $$new_props)
      $$invalidate(13, multiple = $$new_props.multiple);
    if ("id" in $$new_props)
      $$invalidate(14, id = $$new_props.id);
    if ("chevron" in $$new_props)
      $$invalidate(15, chevron = $$new_props.chevron);
    if ("chevronPosition" in $$new_props)
      $$invalidate(16, chevronPosition = $$new_props.chevronPosition);
    if ("chevronSize" in $$new_props)
      $$invalidate(17, chevronSize = $$new_props.chevronSize);
    if ("disableChevronRotation" in $$new_props)
      $$invalidate(18, disableChevronRotation = $$new_props.disableChevronRotation);
    if ("transitionDuration" in $$new_props)
      $$invalidate(19, transitionDuration = $$new_props.transitionDuration);
    if ("$$scope" in $$new_props)
      $$invalidate(24, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    setContext,
    writable,
    randomID,
    Box: Box_default,
    key: key2,
    Chevron: Chevron_default,
    useStyles: Accordion_styles_default,
    use,
    element: element2,
    className,
    override,
    variant: variant2,
    value,
    defaultValue,
    radius: radius2,
    order,
    multiple,
    id,
    chevron,
    chevronPosition,
    chevronSize,
    disableChevronRotation,
    transitionDuration,
    dispatch,
    _value,
    stateContent,
    state,
    updateActive,
    isItemActive,
    getControlsId,
    getRegionId,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("variant" in $$props)
      $$invalidate(8, variant2 = $$new_props.variant);
    if ("value" in $$props)
      $$invalidate(9, value = $$new_props.value);
    if ("defaultValue" in $$props)
      $$invalidate(10, defaultValue = $$new_props.defaultValue);
    if ("radius" in $$props)
      $$invalidate(11, radius2 = $$new_props.radius);
    if ("order" in $$props)
      $$invalidate(12, order = $$new_props.order);
    if ("multiple" in $$props)
      $$invalidate(13, multiple = $$new_props.multiple);
    if ("id" in $$props)
      $$invalidate(14, id = $$new_props.id);
    if ("chevron" in $$props)
      $$invalidate(15, chevron = $$new_props.chevron);
    if ("chevronPosition" in $$props)
      $$invalidate(16, chevronPosition = $$new_props.chevronPosition);
    if ("chevronSize" in $$props)
      $$invalidate(17, chevronSize = $$new_props.chevronSize);
    if ("disableChevronRotation" in $$props)
      $$invalidate(18, disableChevronRotation = $$new_props.disableChevronRotation);
    if ("transitionDuration" in $$props)
      $$invalidate(19, transitionDuration = $$new_props.transitionDuration);
    if ("_value" in $$props)
      $$invalidate(20, _value = $$new_props._value);
    if ("stateContent" in $$props)
      $$invalidate(21, stateContent = $$new_props.stateContent);
    if ("getStyles" in $$props)
      $$invalidate(4, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(5, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(6, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value, defaultValue*/
    1536) {
      $:
        $$invalidate(20, _value = value || defaultValue);
    }
    if ($$self.$$.dirty & /*multiple, _value*/
    1056768) {
      $: {
        if (multiple && !Array.isArray(_value)) {
          $$invalidate(20, _value = _value ? [_value] : []);
        }
      }
    }
    if ($$self.$$.dirty & /*_value, variant, order, radius, chevron, chevronPosition, chevronSize, disableChevronRotation, transitionDuration, stateContent*/
    4167936) {
      $: {
        $$invalidate(21, stateContent = {
          currentValue: _value,
          variant: variant2,
          order,
          radius: radius2,
          chevron,
          chevronPosition,
          chevronSize,
          disableChevronRotation,
          transitionDuration,
          updateActive,
          isItemActive,
          getControlsId,
          getRegionId
        });
        state.set(stateContent);
      }
    }
    if ($$self.$$.dirty & /*radius, variant*/
    2304) {
      $:
        $$invalidate(6, { cx: cx2, classes, getStyles } = Accordion_styles_default({ radius: radius2, variant: variant2 }, { name: "Accordion" }), cx2, ($$invalidate(5, classes), $$invalidate(11, radius2), $$invalidate(8, variant2)), ($$invalidate(4, getStyles), $$invalidate(11, radius2), $$invalidate(8, variant2)));
    }
  };
  return [
    element2,
    use,
    className,
    override,
    getStyles,
    classes,
    cx2,
    $$restProps,
    variant2,
    value,
    defaultValue,
    radius2,
    order,
    multiple,
    id,
    chevron,
    chevronPosition,
    chevronSize,
    disableChevronRotation,
    transitionDuration,
    _value,
    stateContent,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Accordion = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      variant: 8,
      value: 9,
      defaultValue: 10,
      radius: 11,
      order: 12,
      multiple: 13,
      id: 14,
      chevron: 15,
      chevronPosition: 16,
      chevronSize: 17,
      disableChevronRotation: 18,
      transitionDuration: 19
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Accordion",
      options,
      id: create_fragment5.name
    });
  }
  get use() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get defaultValue() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultValue(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get order() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set order(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiple() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chevron() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chevron(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chevronPosition() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chevronPosition(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chevronSize() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chevronSize(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableChevronRotation() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableChevronRotation(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionDuration() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionDuration(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Accordion_default = Accordion;

// node_modules/@svelteuidev/core/dist/components/Button/Button.styles.js
var sizes = {
  xs: {
    height: 30,
    padding: "0px 14px"
  },
  sm: {
    height: 36,
    padding: "0px 18px"
  },
  md: {
    height: 42,
    padding: "0px 22px"
  },
  lg: {
    height: 50,
    padding: "0px 26px"
  },
  xl: {
    height: 60,
    padding: "0px 32px"
  },
  "compact-xs": {
    height: 22,
    padding: "0 7px"
  },
  "compact-sm": {
    height: 26,
    padding: "0 8px"
  },
  "compact-md": {
    height: 30,
    padding: "0 10px"
  },
  "compact-lg": {
    height: 34,
    padding: "0 12px"
  },
  "compact-xl": {
    height: 40,
    padding: "0 14px"
  }
};
var Button_styles_default = createStyles((theme4, { color, compact, fullSize, gradient, radius: radius2, size: size3, variant: variant2 }) => {
  return {
    root: {
      focusRing: "auto",
      cursor: "pointer",
      position: "relative",
      boxSizing: "border-box",
      textDecoration: "none",
      outline: "none",
      userSelect: "none",
      appearance: "none",
      textAlign: "center",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      background: null,
      borderRadius: typeof radius2 === "number" ? radius2 : `$${radius2}`,
      height: typeof size3 === "number" ? `${size3}px` : sizes[compact ? `compact-${size3}` : size3].height,
      padding: typeof size3 === "number" ? `0px ${size3}px` : sizes[compact ? `compact-${size3}` : size3].padding,
      fontFamily: theme4.fonts.standard.value ?? "sans-serif",
      fontWeight: "$semibold",
      fontSize: `$${size3}`,
      lineHeight: 1,
      flexGrow: 0,
      width: fullSize ? "100%" : "fit-content",
      "&:hover": {
        backgroundColor: variant2 === "gradient" ? null : theme4.fn.themeColor(color, 7),
        backgroundSize: variant2 === "gradient" ? "200%" : null
      },
      "&:active": {
        transform: "translateY(1px)"
      },
      "&:disabled": {
        pointerEvents: "none",
        borderColor: "transparent",
        background: theme4.fn.themeColor("gray", 2),
        backgroundColor: theme4.fn.themeColor("gray", 2),
        color: theme4.fn.themeColor("gray", 5),
        cursor: "not-allowed",
        darkMode: {
          borderColor: "transparent",
          backgroundColor: theme4.fn.themeColor("dark", 4),
          color: theme4.fn.themeColor("dark", 6)
        }
      }
    },
    disabled: {
      pointerEvents: "none",
      borderColor: "transparent",
      background: theme4.fn.themeColor("gray", 2),
      backgroundColor: theme4.fn.themeColor("gray", 2),
      color: theme4.fn.themeColor("gray", 5),
      cursor: "not-allowed",
      darkMode: {
        backgroundColor: theme4.fn.themeColor("dark", 4),
        color: theme4.fn.themeColor("dark", 6)
      }
    },
    loading: {
      pointerEvents: "none",
      "&::before": {
        content: '""',
        position: "absolute",
        inset: -1,
        backgroundColor: "rgba(255, 255, 255, .5)",
        borderRadius: `$${radius2}`,
        cursor: "not-allowed"
      },
      darkMode: {
        "&::before": {
          backgroundColor: theme4.fn.rgba(theme4.fn.themeColor("dark", 7), 0.5)
        }
      }
    },
    variants: {
      variation: vFunc(color, gradient),
      // Used to override the disable style when using anchor HTML element
      disabled: {
        true: {
          pointerEvents: "none",
          borderColor: "transparent",
          background: theme4.fn.themeColor("gray", 2),
          backgroundColor: theme4.fn.themeColor("gray", 2),
          color: theme4.fn.themeColor("gray", 5),
          cursor: "not-allowed",
          [`${dark.selector} &`]: {
            borderColor: "transparent",
            backgroundColor: theme4.fn.themeColor("dark", 4),
            color: theme4.fn.themeColor("dark", 6)
          }
        }
      }
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Button/Button.errors.js
var Button_errors_exports = {};
__export(Button_errors_exports, {
  ButtonErrors: () => ButtonErrors
});
var ButtonErrors = Object.freeze([
  {
    error: true,
    message: "If using the disabled prop, a loading cannot be set at the same time",
    solution: `
                If your component looks like this:
                
                &lt;Button disabled loading ...&gt; Button Text &lt;/Button&gt;
                         ^^^^^^^^ ^^^^^^^ - Try removing one of these
                `
  },
  {
    error: true,
    message: "If using the external prop, a href prop must be associated with it. If you have an href prop there must be content inside.",
    solution: `
                If your component looks like this:
                
                &lt;Button external ...&gt; Button Text &lt;/Button&gt;
                         ^^^^^^^^ - Try adding the href prop too
                `
  }
]);

// node_modules/@svelteuidev/core/dist/components/Loader/loaders/Circle.svelte
var file4 = "node_modules/@svelteuidev/core/dist/components/Loader/loaders/Circle.svelte";
function create_fragment6(ctx8) {
  let svg;
  let g1;
  let g0;
  let circle;
  let path;
  let animateTransform;
  let svg_width_value;
  let svg_height_value;
  let useActions_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      g1 = svg_element("g");
      g0 = svg_element("g");
      circle = svg_element("circle");
      path = svg_element("path");
      animateTransform = svg_element("animateTransform");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        xmlns: true,
        stroke: true,
        class: true
      });
      var svg_nodes = children(svg);
      g1 = claim_svg_element(svg_nodes, "g", { fill: true, "fill-rule": true });
      var g1_nodes = children(g1);
      g0 = claim_svg_element(g1_nodes, "g", { transform: true, "stroke-width": true });
      var g0_nodes = children(g0);
      circle = claim_svg_element(g0_nodes, "circle", {
        "stroke-opacity": true,
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      path = claim_svg_element(g0_nodes, "path", { d: true });
      var path_nodes = children(path);
      animateTransform = claim_svg_element(path_nodes, "animateTransform", {
        attributeName: true,
        type: true,
        from: true,
        to: true,
        dur: true,
        repeatCount: true
      });
      children(animateTransform).forEach(detach_dev);
      path_nodes.forEach(detach_dev);
      g0_nodes.forEach(detach_dev);
      g1_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "stroke-opacity", ".5");
      attr_dev(circle, "cx", "16");
      attr_dev(circle, "cy", "16");
      attr_dev(circle, "r", "16");
      add_location(circle, file4, 19, 3, 453);
      attr_dev(animateTransform, "attributeName", "transform");
      attr_dev(animateTransform, "type", "rotate");
      attr_dev(animateTransform, "from", "0 16 16");
      attr_dev(animateTransform, "to", "360 16 16");
      attr_dev(animateTransform, "dur", "1s");
      attr_dev(animateTransform, "repeatCount", "indefinite");
      add_location(animateTransform, file4, 21, 4, 553);
      attr_dev(path, "d", "M32 16c0-9.94-8.06-16-16-16");
      add_location(path, file4, 20, 3, 510);
      attr_dev(g0, "transform", "translate(2.5 2.5)");
      attr_dev(g0, "stroke-width", "5");
      add_location(g0, file4, 18, 2, 398);
      attr_dev(g1, "fill", "none");
      attr_dev(g1, "fill-rule", "evenodd");
      add_location(g1, file4, 17, 1, 360);
      attr_dev(svg, "width", svg_width_value = `${/*size*/
      ctx8[1]}px`);
      attr_dev(svg, "height", svg_height_value = `${/*size*/
      ctx8[1]}px`);
      attr_dev(svg, "viewBox", "0 0 38 38");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "stroke",
        /*color*/
        ctx8[2]
      );
      attr_dev(
        svg,
        "class",
        /*className*/
        ctx8[3]
      );
      add_location(svg, file4, 8, 0, 195);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, g1);
      append_hydration_dev(g1, g0);
      append_hydration_dev(g0, circle);
      append_hydration_dev(g0, path);
      append_hydration_dev(path, animateTransform);
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          svg,
          /*use*/
          ctx8[0]
        ));
        mounted = true;
      }
    },
    p: function update(ctx9, [dirty]) {
      if (dirty & /*size*/
      2 && svg_width_value !== (svg_width_value = `${/*size*/
      ctx9[1]}px`)) {
        attr_dev(svg, "width", svg_width_value);
      }
      if (dirty & /*size*/
      2 && svg_height_value !== (svg_height_value = `${/*size*/
      ctx9[1]}px`)) {
        attr_dev(svg, "height", svg_height_value);
      }
      if (dirty & /*color*/
      4) {
        attr_dev(
          svg,
          "stroke",
          /*color*/
          ctx9[2]
        );
      }
      if (dirty & /*className*/
      8) {
        attr_dev(
          svg,
          "class",
          /*className*/
          ctx9[3]
        );
      }
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx9[0]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Circle", slots, []);
  let { use = [] } = $$props;
  let { size: size3 = 25 } = $$props;
  let { color = "blue" } = $$props;
  let { class: className = "" } = $$props;
  const writable_props = ["use", "size", "color", "class"];
  Object.keys($$props).forEach((key3) => {
    if (!~writable_props.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<Circle> was created with unknown prop '${key3}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("use" in $$props2)
      $$invalidate(0, use = $$props2.use);
    if ("size" in $$props2)
      $$invalidate(1, size3 = $$props2.size);
    if ("color" in $$props2)
      $$invalidate(2, color = $$props2.color);
    if ("class" in $$props2)
      $$invalidate(3, className = $$props2.class);
  };
  $$self.$capture_state = () => ({ useActions, use, size: size3, color, className });
  $$self.$inject_state = ($$props2) => {
    if ("use" in $$props2)
      $$invalidate(0, use = $$props2.use);
    if ("size" in $$props2)
      $$invalidate(1, size3 = $$props2.size);
    if ("color" in $$props2)
      $$invalidate(2, color = $$props2.color);
    if ("className" in $$props2)
      $$invalidate(3, className = $$props2.className);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [use, size3, color, className];
}
var Circle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { use: 0, size: 1, color: 2, class: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Circle",
      options,
      id: create_fragment6.name
    });
  }
  get use() {
    throw new Error("<Circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Circle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Circle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Circle_default = Circle;

// node_modules/@svelteuidev/core/dist/components/Loader/loaders/Bars.svelte
var file5 = "node_modules/@svelteuidev/core/dist/components/Loader/loaders/Bars.svelte";
function create_fragment7(ctx8) {
  let svg;
  let rect0;
  let animate0;
  let animate1;
  let rect1;
  let animate2;
  let animate3;
  let rect2;
  let animate4;
  let animate5;
  let rect3;
  let animate6;
  let animate7;
  let rect4;
  let animate8;
  let animate9;
  let svg_width_value;
  let useActions_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect0 = svg_element("rect");
      animate0 = svg_element("animate");
      animate1 = svg_element("animate");
      rect1 = svg_element("rect");
      animate2 = svg_element("animate");
      animate3 = svg_element("animate");
      rect2 = svg_element("rect");
      animate4 = svg_element("animate");
      animate5 = svg_element("animate");
      rect3 = svg_element("rect");
      animate6 = svg_element("animate");
      animate7 = svg_element("animate");
      rect4 = svg_element("rect");
      animate8 = svg_element("animate");
      animate9 = svg_element("animate");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        viewBox: true,
        xmlns: true,
        fill: true,
        width: true,
        class: true
      });
      var svg_nodes = children(svg);
      rect0 = claim_svg_element(svg_nodes, "rect", {
        y: true,
        width: true,
        height: true,
        rx: true
      });
      var rect0_nodes = children(rect0);
      animate0 = claim_svg_element(rect0_nodes, "animate", {
        attributeName: true,
        begin: true,
        dur: true,
        values: true,
        calcMode: true,
        repeatCount: true
      });
      children(animate0).forEach(detach_dev);
      animate1 = claim_svg_element(rect0_nodes, "animate", {
        attributeName: true,
        begin: true,
        dur: true,
        values: true,
        calcMode: true,
        repeatCount: true
      });
      children(animate1).forEach(detach_dev);
      rect0_nodes.forEach(detach_dev);
      rect1 = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true
      });
      var rect1_nodes = children(rect1);
      animate2 = claim_svg_element(rect1_nodes, "animate", {
        attributeName: true,
        begin: true,
        dur: true,
        values: true,
        calcMode: true,
        repeatCount: true
      });
      children(animate2).forEach(detach_dev);
      animate3 = claim_svg_element(rect1_nodes, "animate", {
        attributeName: true,
        begin: true,
        dur: true,
        values: true,
        calcMode: true,
        repeatCount: true
      });
      children(animate3).forEach(detach_dev);
      rect1_nodes.forEach(detach_dev);
      rect2 = claim_svg_element(svg_nodes, "rect", {
        x: true,
        width: true,
        height: true,
        rx: true
      });
      var rect2_nodes = children(rect2);
      animate4 = claim_svg_element(rect2_nodes, "animate", {
        attributeName: true,
        begin: true,
        dur: true,
        values: true,
        calcMode: true,
        repeatCount: true
      });
      children(animate4).forEach(detach_dev);
      animate5 = claim_svg_element(rect2_nodes, "animate", {
        attributeName: true,
        begin: true,
        dur: true,
        values: true,
        calcMode: true,
        repeatCount: true
      });
      children(animate5).forEach(detach_dev);
      rect2_nodes.forEach(detach_dev);
      rect3 = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true
      });
      var rect3_nodes = children(rect3);
      animate6 = claim_svg_element(rect3_nodes, "animate", {
        attributeName: true,
        begin: true,
        dur: true,
        values: true,
        calcMode: true,
        repeatCount: true
      });
      children(animate6).forEach(detach_dev);
      animate7 = claim_svg_element(rect3_nodes, "animate", {
        attributeName: true,
        begin: true,
        dur: true,
        values: true,
        calcMode: true,
        repeatCount: true
      });
      children(animate7).forEach(detach_dev);
      rect3_nodes.forEach(detach_dev);
      rect4 = claim_svg_element(svg_nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true
      });
      var rect4_nodes = children(rect4);
      animate8 = claim_svg_element(rect4_nodes, "animate", {
        attributeName: true,
        begin: true,
        dur: true,
        values: true,
        calcMode: true,
        repeatCount: true
      });
      children(animate8).forEach(detach_dev);
      animate9 = claim_svg_element(rect4_nodes, "animate", {
        attributeName: true,
        begin: true,
        dur: true,
        values: true,
        calcMode: true,
        repeatCount: true
      });
      children(animate9).forEach(detach_dev);
      rect4_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(animate0, "attributeName", "height");
      attr_dev(animate0, "begin", "0.5s");
      attr_dev(animate0, "dur", "1s");
      attr_dev(animate0, "values", "120;110;100;90;80;70;60;50;40;140;120");
      attr_dev(animate0, "calcMode", "linear");
      attr_dev(animate0, "repeatCount", "indefinite");
      add_location(animate0, file5, 17, 2, 385);
      attr_dev(animate1, "attributeName", "y");
      attr_dev(animate1, "begin", "0.5s");
      attr_dev(animate1, "dur", "1s");
      attr_dev(animate1, "values", "10;15;20;25;30;35;40;45;50;0;10");
      attr_dev(animate1, "calcMode", "linear");
      attr_dev(animate1, "repeatCount", "indefinite");
      add_location(animate1, file5, 25, 2, 554);
      attr_dev(rect0, "y", "10");
      attr_dev(rect0, "width", "15");
      attr_dev(rect0, "height", "120");
      attr_dev(rect0, "rx", "6");
      add_location(rect0, file5, 16, 1, 338);
      attr_dev(animate2, "attributeName", "height");
      attr_dev(animate2, "begin", "0.25s");
      attr_dev(animate2, "dur", "1s");
      attr_dev(animate2, "values", "120;110;100;90;80;70;60;50;40;140;120");
      attr_dev(animate2, "calcMode", "linear");
      attr_dev(animate2, "repeatCount", "indefinite");
      add_location(animate2, file5, 35, 2, 774);
      attr_dev(animate3, "attributeName", "y");
      attr_dev(animate3, "begin", "0.25s");
      attr_dev(animate3, "dur", "1s");
      attr_dev(animate3, "values", "10;15;20;25;30;35;40;45;50;0;10");
      attr_dev(animate3, "calcMode", "linear");
      attr_dev(animate3, "repeatCount", "indefinite");
      add_location(animate3, file5, 43, 2, 944);
      attr_dev(rect1, "x", "30");
      attr_dev(rect1, "y", "10");
      attr_dev(rect1, "width", "15");
      attr_dev(rect1, "height", "120");
      attr_dev(rect1, "rx", "6");
      add_location(rect1, file5, 34, 1, 720);
      attr_dev(animate4, "attributeName", "height");
      attr_dev(animate4, "begin", "0s");
      attr_dev(animate4, "dur", "1s");
      attr_dev(animate4, "values", "120;110;100;90;80;70;60;50;40;140;120");
      attr_dev(animate4, "calcMode", "linear");
      attr_dev(animate4, "repeatCount", "indefinite");
      add_location(animate4, file5, 53, 2, 1158);
      attr_dev(animate5, "attributeName", "y");
      attr_dev(animate5, "begin", "0s");
      attr_dev(animate5, "dur", "1s");
      attr_dev(animate5, "values", "10;15;20;25;30;35;40;45;50;0;10");
      attr_dev(animate5, "calcMode", "linear");
      attr_dev(animate5, "repeatCount", "indefinite");
      add_location(animate5, file5, 61, 2, 1325);
      attr_dev(rect2, "x", "60");
      attr_dev(rect2, "width", "15");
      attr_dev(rect2, "height", "140");
      attr_dev(rect2, "rx", "6");
      add_location(rect2, file5, 52, 1, 1111);
      attr_dev(animate6, "attributeName", "height");
      attr_dev(animate6, "begin", "0.25s");
      attr_dev(animate6, "dur", "1s");
      attr_dev(animate6, "values", "120;110;100;90;80;70;60;50;40;140;120");
      attr_dev(animate6, "calcMode", "linear");
      attr_dev(animate6, "repeatCount", "indefinite");
      add_location(animate6, file5, 71, 2, 1543);
      attr_dev(animate7, "attributeName", "y");
      attr_dev(animate7, "begin", "0.25s");
      attr_dev(animate7, "dur", "1s");
      attr_dev(animate7, "values", "10;15;20;25;30;35;40;45;50;0;10");
      attr_dev(animate7, "calcMode", "linear");
      attr_dev(animate7, "repeatCount", "indefinite");
      add_location(animate7, file5, 79, 2, 1713);
      attr_dev(rect3, "x", "90");
      attr_dev(rect3, "y", "10");
      attr_dev(rect3, "width", "15");
      attr_dev(rect3, "height", "120");
      attr_dev(rect3, "rx", "6");
      add_location(rect3, file5, 70, 1, 1489);
      attr_dev(animate8, "attributeName", "height");
      attr_dev(animate8, "begin", "0.5s");
      attr_dev(animate8, "dur", "1s");
      attr_dev(animate8, "values", "120;110;100;90;80;70;60;50;40;140;120");
      attr_dev(animate8, "calcMode", "linear");
      attr_dev(animate8, "repeatCount", "indefinite");
      add_location(animate8, file5, 89, 2, 1935);
      attr_dev(animate9, "attributeName", "y");
      attr_dev(animate9, "begin", "0.5s");
      attr_dev(animate9, "dur", "1s");
      attr_dev(animate9, "values", "10;15;20;25;30;35;40;45;50;0;10");
      attr_dev(animate9, "calcMode", "linear");
      attr_dev(animate9, "repeatCount", "indefinite");
      add_location(animate9, file5, 97, 2, 2104);
      attr_dev(rect4, "x", "120");
      attr_dev(rect4, "y", "10");
      attr_dev(rect4, "width", "15");
      attr_dev(rect4, "height", "120");
      attr_dev(rect4, "rx", "6");
      add_location(rect4, file5, 88, 1, 1880);
      attr_dev(svg, "viewBox", "0 0 135 140");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "fill",
        /*color*/
        ctx8[2]
      );
      attr_dev(svg, "width", svg_width_value = `${/*size*/
      ctx8[1]}px`);
      attr_dev(
        svg,
        "class",
        /*className*/
        ctx8[3]
      );
      add_location(svg, file5, 8, 0, 195);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect0);
      append_hydration_dev(rect0, animate0);
      append_hydration_dev(rect0, animate1);
      append_hydration_dev(svg, rect1);
      append_hydration_dev(rect1, animate2);
      append_hydration_dev(rect1, animate3);
      append_hydration_dev(svg, rect2);
      append_hydration_dev(rect2, animate4);
      append_hydration_dev(rect2, animate5);
      append_hydration_dev(svg, rect3);
      append_hydration_dev(rect3, animate6);
      append_hydration_dev(rect3, animate7);
      append_hydration_dev(svg, rect4);
      append_hydration_dev(rect4, animate8);
      append_hydration_dev(rect4, animate9);
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          svg,
          /*use*/
          ctx8[0]
        ));
        mounted = true;
      }
    },
    p: function update(ctx9, [dirty]) {
      if (dirty & /*color*/
      4) {
        attr_dev(
          svg,
          "fill",
          /*color*/
          ctx9[2]
        );
      }
      if (dirty & /*size*/
      2 && svg_width_value !== (svg_width_value = `${/*size*/
      ctx9[1]}px`)) {
        attr_dev(svg, "width", svg_width_value);
      }
      if (dirty & /*className*/
      8) {
        attr_dev(
          svg,
          "class",
          /*className*/
          ctx9[3]
        );
      }
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx9[0]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Bars", slots, []);
  let { use = [] } = $$props;
  let { size: size3 = 25 } = $$props;
  let { color = "blue" } = $$props;
  let { class: className = "" } = $$props;
  const writable_props = ["use", "size", "color", "class"];
  Object.keys($$props).forEach((key3) => {
    if (!~writable_props.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<Bars> was created with unknown prop '${key3}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("use" in $$props2)
      $$invalidate(0, use = $$props2.use);
    if ("size" in $$props2)
      $$invalidate(1, size3 = $$props2.size);
    if ("color" in $$props2)
      $$invalidate(2, color = $$props2.color);
    if ("class" in $$props2)
      $$invalidate(3, className = $$props2.class);
  };
  $$self.$capture_state = () => ({ useActions, use, size: size3, color, className });
  $$self.$inject_state = ($$props2) => {
    if ("use" in $$props2)
      $$invalidate(0, use = $$props2.use);
    if ("size" in $$props2)
      $$invalidate(1, size3 = $$props2.size);
    if ("color" in $$props2)
      $$invalidate(2, color = $$props2.color);
    if ("className" in $$props2)
      $$invalidate(3, className = $$props2.className);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [use, size3, color, className];
}
var Bars = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { use: 0, size: 1, color: 2, class: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Bars",
      options,
      id: create_fragment7.name
    });
  }
  get use() {
    throw new Error("<Bars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Bars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Bars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Bars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Bars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Bars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Bars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Bars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Bars_default = Bars;

// node_modules/@svelteuidev/core/dist/components/Loader/loaders/Dots.svelte
var file6 = "node_modules/@svelteuidev/core/dist/components/Loader/loaders/Dots.svelte";
function create_fragment8(ctx8) {
  let svg;
  let circle0;
  let animate0;
  let animate1;
  let circle1;
  let animate2;
  let animate3;
  let circle2;
  let animate4;
  let animate5;
  let svg_width_value;
  let svg_height_value;
  let useActions_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      circle0 = svg_element("circle");
      animate0 = svg_element("animate");
      animate1 = svg_element("animate");
      circle1 = svg_element("circle");
      animate2 = svg_element("animate");
      animate3 = svg_element("animate");
      circle2 = svg_element("circle");
      animate4 = svg_element("animate");
      animate5 = svg_element("animate");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        xmlns: true,
        fill: true,
        class: true
      });
      var svg_nodes = children(svg);
      circle0 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      var circle0_nodes = children(circle0);
      animate0 = claim_svg_element(circle0_nodes, "animate", {
        attributeName: true,
        from: true,
        to: true,
        begin: true,
        dur: true,
        values: true,
        calcMode: true,
        repeatCount: true
      });
      children(animate0).forEach(detach_dev);
      animate1 = claim_svg_element(circle0_nodes, "animate", {
        attributeName: true,
        from: true,
        to: true,
        begin: true,
        dur: true,
        values: true,
        calcMode: true,
        repeatCount: true
      });
      children(animate1).forEach(detach_dev);
      circle0_nodes.forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", {
        cx: true,
        cy: true,
        r: true,
        "fill-opacity": true
      });
      var circle1_nodes = children(circle1);
      animate2 = claim_svg_element(circle1_nodes, "animate", {
        attributeName: true,
        from: true,
        to: true,
        begin: true,
        dur: true,
        values: true,
        calcMode: true,
        repeatCount: true
      });
      children(animate2).forEach(detach_dev);
      animate3 = claim_svg_element(circle1_nodes, "animate", {
        attributeName: true,
        from: true,
        to: true,
        begin: true,
        dur: true,
        values: true,
        calcMode: true,
        repeatCount: true
      });
      children(animate3).forEach(detach_dev);
      circle1_nodes.forEach(detach_dev);
      circle2 = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      var circle2_nodes = children(circle2);
      animate4 = claim_svg_element(circle2_nodes, "animate", {
        attributeName: true,
        from: true,
        to: true,
        begin: true,
        dur: true,
        values: true,
        calcMode: true,
        repeatCount: true
      });
      children(animate4).forEach(detach_dev);
      animate5 = claim_svg_element(circle2_nodes, "animate", {
        attributeName: true,
        from: true,
        to: true,
        begin: true,
        dur: true,
        values: true,
        calcMode: true,
        repeatCount: true
      });
      children(animate5).forEach(detach_dev);
      circle2_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(animate0, "attributeName", "r");
      attr_dev(animate0, "from", "15");
      attr_dev(animate0, "to", "15");
      attr_dev(animate0, "begin", "0s");
      attr_dev(animate0, "dur", "0.8s");
      attr_dev(animate0, "values", "15;9;15");
      attr_dev(animate0, "calcMode", "linear");
      attr_dev(animate0, "repeatCount", "indefinite");
      add_location(animate0, file6, 18, 2, 405);
      attr_dev(animate1, "attributeName", "fill-opacity");
      attr_dev(animate1, "from", "1");
      attr_dev(animate1, "to", "1");
      attr_dev(animate1, "begin", "0s");
      attr_dev(animate1, "dur", "0.8s");
      attr_dev(animate1, "values", "1;.5;1");
      attr_dev(animate1, "calcMode", "linear");
      attr_dev(animate1, "repeatCount", "indefinite");
      add_location(animate1, file6, 28, 2, 563);
      attr_dev(circle0, "cx", "15");
      attr_dev(circle0, "cy", "15");
      attr_dev(circle0, "r", "15");
      add_location(circle0, file6, 17, 1, 371);
      attr_dev(animate2, "attributeName", "r");
      attr_dev(animate2, "from", "9");
      attr_dev(animate2, "to", "9");
      attr_dev(animate2, "begin", "0s");
      attr_dev(animate2, "dur", "0.8s");
      attr_dev(animate2, "values", "9;15;9");
      attr_dev(animate2, "calcMode", "linear");
      attr_dev(animate2, "repeatCount", "indefinite");
      add_location(animate2, file6, 40, 2, 791);
      attr_dev(animate3, "attributeName", "fill-opacity");
      attr_dev(animate3, "from", "0.5");
      attr_dev(animate3, "to", "0.5");
      attr_dev(animate3, "begin", "0s");
      attr_dev(animate3, "dur", "0.8s");
      attr_dev(animate3, "values", ".5;1;.5");
      attr_dev(animate3, "calcMode", "linear");
      attr_dev(animate3, "repeatCount", "indefinite");
      add_location(animate3, file6, 50, 2, 946);
      attr_dev(circle1, "cx", "60");
      attr_dev(circle1, "cy", "15");
      attr_dev(circle1, "r", "9");
      attr_dev(circle1, "fill-opacity", "0.3");
      add_location(circle1, file6, 39, 1, 739);
      attr_dev(animate4, "attributeName", "r");
      attr_dev(animate4, "from", "15");
      attr_dev(animate4, "to", "15");
      attr_dev(animate4, "begin", "0s");
      attr_dev(animate4, "dur", "0.8s");
      attr_dev(animate4, "values", "15;9;15");
      attr_dev(animate4, "calcMode", "linear");
      attr_dev(animate4, "repeatCount", "indefinite");
      add_location(animate4, file6, 62, 2, 1162);
      attr_dev(animate5, "attributeName", "fill-opacity");
      attr_dev(animate5, "from", "1");
      attr_dev(animate5, "to", "1");
      attr_dev(animate5, "begin", "0s");
      attr_dev(animate5, "dur", "0.8s");
      attr_dev(animate5, "values", "1;.5;1");
      attr_dev(animate5, "calcMode", "linear");
      attr_dev(animate5, "repeatCount", "indefinite");
      add_location(animate5, file6, 72, 2, 1320);
      attr_dev(circle2, "cx", "105");
      attr_dev(circle2, "cy", "15");
      attr_dev(circle2, "r", "15");
      add_location(circle2, file6, 61, 1, 1127);
      attr_dev(svg, "width", svg_width_value = `${/*size*/
      ctx8[1]}px`);
      attr_dev(svg, "height", svg_height_value = `${Number(
        /*size*/
        ctx8[1]
      ) / 4}px`);
      attr_dev(svg, "viewBox", "0 0 120 30");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(
        svg,
        "fill",
        /*color*/
        ctx8[2]
      );
      attr_dev(
        svg,
        "class",
        /*className*/
        ctx8[3]
      );
      add_location(svg, file6, 8, 0, 195);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(circle0, animate0);
      append_hydration_dev(circle0, animate1);
      append_hydration_dev(svg, circle1);
      append_hydration_dev(circle1, animate2);
      append_hydration_dev(circle1, animate3);
      append_hydration_dev(svg, circle2);
      append_hydration_dev(circle2, animate4);
      append_hydration_dev(circle2, animate5);
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          svg,
          /*use*/
          ctx8[0]
        ));
        mounted = true;
      }
    },
    p: function update(ctx9, [dirty]) {
      if (dirty & /*size*/
      2 && svg_width_value !== (svg_width_value = `${/*size*/
      ctx9[1]}px`)) {
        attr_dev(svg, "width", svg_width_value);
      }
      if (dirty & /*size*/
      2 && svg_height_value !== (svg_height_value = `${Number(
        /*size*/
        ctx9[1]
      ) / 4}px`)) {
        attr_dev(svg, "height", svg_height_value);
      }
      if (dirty & /*color*/
      4) {
        attr_dev(
          svg,
          "fill",
          /*color*/
          ctx9[2]
        );
      }
      if (dirty & /*className*/
      8) {
        attr_dev(
          svg,
          "class",
          /*className*/
          ctx9[3]
        );
      }
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx9[0]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Dots", slots, []);
  let { use = [] } = $$props;
  let { size: size3 = 25 } = $$props;
  let { color = "blue" } = $$props;
  let { class: className = "" } = $$props;
  const writable_props = ["use", "size", "color", "class"];
  Object.keys($$props).forEach((key3) => {
    if (!~writable_props.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<Dots> was created with unknown prop '${key3}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("use" in $$props2)
      $$invalidate(0, use = $$props2.use);
    if ("size" in $$props2)
      $$invalidate(1, size3 = $$props2.size);
    if ("color" in $$props2)
      $$invalidate(2, color = $$props2.color);
    if ("class" in $$props2)
      $$invalidate(3, className = $$props2.class);
  };
  $$self.$capture_state = () => ({ useActions, use, size: size3, color, className });
  $$self.$inject_state = ($$props2) => {
    if ("use" in $$props2)
      $$invalidate(0, use = $$props2.use);
    if ("size" in $$props2)
      $$invalidate(1, size3 = $$props2.size);
    if ("color" in $$props2)
      $$invalidate(2, color = $$props2.color);
    if ("className" in $$props2)
      $$invalidate(3, className = $$props2.className);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [use, size3, color, className];
}
var Dots = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { use: 0, size: 1, color: 2, class: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Dots",
      options,
      id: create_fragment8.name
    });
  }
  get use() {
    throw new Error("<Dots>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Dots>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Dots>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Dots>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Dots>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Dots>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Dots>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Dots>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Dots_default = Dots;

// node_modules/@svelteuidev/core/dist/components/Loader/Loader.styles.js
var LOADER_SIZES = {
  xs: 18,
  sm: 22,
  md: 36,
  lg: 44,
  xl: 58
};
var getCorrectShade = (color, dark2 = false) => {
  return theme.colors[dark2 ? `${color}400` : `${color}600`].value;
};

// node_modules/@svelteuidev/core/dist/components/Loader/Loader.svelte
function create_fragment9(ctx8) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    {
      use: [
        /*forwardEvents*/
        ctx8[5],
        [
          useActions,
          /*use*/
          ctx8[1]
        ]
      ]
    },
    {
      color: (
        /*color*/
        ctx8[4] === "white" ? "white" : getCorrectShade(
          /*color*/
          ctx8[4]
        )
      )
    },
    {
      size: LOADER_SIZES[
        /*size*/
        ctx8[3]
      ] || /*size*/
      ctx8[3]
    },
    { class: (
      /*className*/
      ctx8[2]
    ) },
    /*$$restProps*/
    ctx8[8]
  ];
  var switch_value = (
    /*LOADERS*/
    ctx8[6][
      /*defaultLoader*/
      ctx8[7]
    ]
  );
  function switch_props(ctx9, dirty) {
    let switch_instance_props = {};
    for (let i2 = 0; i2 < switch_instance_spread_levels.length; i2 += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i2]);
    }
    if (dirty !== void 0 && dirty & /*forwardEvents, use, color, size, className, $$restProps*/
    318) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
        dirty & /*forwardEvents, use*/
        34 && {
          use: [
            /*forwardEvents*/
            ctx9[5],
            [
              useActions,
              /*use*/
              ctx9[1]
            ]
          ]
        },
        dirty & /*color*/
        16 && {
          color: (
            /*color*/
            ctx9[4] === "white" ? "white" : getCorrectShade(
              /*color*/
              ctx9[4]
            )
          )
        },
        dirty & /*size*/
        8 && {
          size: LOADER_SIZES[
            /*size*/
            ctx9[3]
          ] || /*size*/
          ctx9[3]
        },
        dirty & /*className*/
        4 && { class: (
          /*className*/
          ctx9[2]
        ) },
        dirty & /*$$restProps*/
        256 && get_spread_object(
          /*$$restProps*/
          ctx9[8]
        )
      ]));
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx8));
    ctx8[10](switch_instance);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      if (switch_value !== (switch_value = /*LOADERS*/
      ctx9[6][
        /*defaultLoader*/
        ctx9[7]
      ])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx9, dirty));
          ctx9[10](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*forwardEvents, use, color, size, className, $$restProps*/
        318 ? get_spread_update(switch_instance_spread_levels, [
          dirty & /*forwardEvents, use*/
          34 && {
            use: [
              /*forwardEvents*/
              ctx9[5],
              [
                useActions,
                /*use*/
                ctx9[1]
              ]
            ]
          },
          dirty & /*color*/
          16 && {
            color: (
              /*color*/
              ctx9[4] === "white" ? "white" : getCorrectShade(
                /*color*/
                ctx9[4]
              )
            )
          },
          dirty & /*size*/
          8 && {
            size: LOADER_SIZES[
              /*size*/
              ctx9[3]
            ] || /*size*/
            ctx9[3]
          },
          dirty & /*className*/
          4 && { class: (
            /*className*/
            ctx9[2]
          ) },
          dirty & /*$$restProps*/
          256 && get_spread_object(
            /*$$restProps*/
            ctx9[8]
          )
        ]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      ctx8[10](null);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "element", "class", "size", "color", "variant"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Loader", slots, []);
  let { use = [], element: element2 = void 0, class: className = "", size: size3 = "md", color = "blue", variant: variant2 = "circle" } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  const LOADERS = { bars: Bars_default, circle: Circle_default, dots: Dots_default };
  const defaultLoader = variant2 in LOADERS ? variant2 : "circle";
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("size" in $$new_props)
      $$invalidate(3, size3 = $$new_props.size);
    if ("color" in $$new_props)
      $$invalidate(4, color = $$new_props.color);
    if ("variant" in $$new_props)
      $$invalidate(9, variant2 = $$new_props.variant);
  };
  $$self.$capture_state = () => ({
    get_current_component,
    createEventForwarder,
    useActions,
    Circle: Circle_default,
    Bars: Bars_default,
    Dots: Dots_default,
    LOADER_SIZES,
    getCorrectShade,
    use,
    element: element2,
    className,
    size: size3,
    color,
    variant: variant2,
    forwardEvents,
    LOADERS,
    defaultLoader
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("size" in $$props)
      $$invalidate(3, size3 = $$new_props.size);
    if ("color" in $$props)
      $$invalidate(4, color = $$new_props.color);
    if ("variant" in $$props)
      $$invalidate(9, variant2 = $$new_props.variant);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    use,
    className,
    size3,
    color,
    forwardEvents,
    LOADERS,
    defaultLoader,
    $$restProps,
    variant2,
    switch_instance_binding
  ];
}
var Loader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      size: 3,
      color: 4,
      variant: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Loader",
      options,
      id: create_fragment9.name
    });
  }
  get use() {
    throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Loader_default = Loader;

// node_modules/@svelteuidev/core/dist/components/Button/Ripple.svelte
var { console: console_1 } = globals;
var file7 = "node_modules/@svelteuidev/core/dist/components/Button/Ripple.svelte";
function add_css(target) {
  append_styles(target, "svelte-3pkhve", ".ripple.svelte-3pkhve{display:block;position:absolute;top:0;left:0;right:0;bottom:0;overflow:hidden;border-radius:inherit;color:inherit;pointer-events:none;z-index:0;contain:strict}.ripple.svelte-3pkhve .animation{color:inherit;position:absolute;top:0;left:0;border-radius:50%;opacity:0;pointer-events:none;overflow:hidden;will-change:transform, opacity}.ripple.svelte-3pkhve .animation-enter{transition:none}.ripple.svelte-3pkhve .animation-in{transition:opacity 0.1s cubic-bezier(0.4, 0, 0.2, 1);transition:transform 0.25s cubic-bezier(0.4, 0, 0.2, 1),\n			opacity 0.1s cubic-bezier(0.4, 0, 0.2, 1)}.ripple.svelte-3pkhve .animation-out{transition:opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmlwcGxlLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyIvVXNlcnMvbWFudmlzaW5naGFsL0RvY3VtZW50cy9HaXRIdWIvYmFja3BhY2trLXN2ZWx0ZS9ub2RlX21vZHVsZXMvQHN2ZWx0ZXVpZGV2L2NvcmUvZGlzdC9jb21wb25lbnRzL0J1dHRvbi9SaXBwbGUuc3ZlbHRlIl19 */");
}
function create_fragment10(ctx8) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "ripple svelte-3pkhve");
      add_location(div, file7, 150, 0, 4661);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      ctx8[4](div);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      ctx8[4](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function isTouchEvent(e) {
  return e.constructor.name === "TouchEvent";
}
function transform(el, value) {
  el.style["transform"] = value;
  el.style["webkitTransform"] = value;
}
function opacity(el, value) {
  el.style["opacity"] = value.toString();
}
var calculate = (e, el) => {
  const offset2 = el.getBoundingClientRect();
  const target = isTouchEvent(e) ? e.touches[e.touches.length - 1] : e;
  const localX = target.clientX - offset2.left;
  const localY = target.clientY - offset2.top;
  let radius2 = 0;
  let scale2 = 0.3;
  const center = el.dataset.center;
  const circle = el.dataset.circle;
  if (circle) {
    scale2 = 0.15;
    radius2 = el.clientWidth / 2;
    radius2 = center ? radius2 : radius2 + Math.sqrt((localX - radius2) ** 2 + (localY - radius2) ** 2) / 4;
  } else {
    radius2 = Math.sqrt(el.clientWidth ** 2 + el.clientHeight ** 2) / 2;
  }
  const centerX = `${(el.clientWidth - radius2 * 2) / 2}px`;
  const centerY = `${(el.clientHeight - radius2 * 2) / 2}px`;
  const x = center ? centerX : `${localX - radius2}px`;
  const y = center ? centerY : `${localY - radius2}px`;
  return { radius: radius2, scale: scale2, x, y, centerX, centerY };
};
var startRipple = function(eventType, event) {
  const hideEvents = ["touchcancel", "mouseleave", "dragstart"];
  let container = event.currentTarget || event.target;
  if (container && !container.classList.contains("ripple")) {
    container = container.querySelector(".ripple");
  }
  if (!container) {
    return;
  }
  const prev = container.dataset.event;
  if (prev && prev !== eventType) {
    return;
  }
  container.dataset.event = eventType;
  const wave = document.createElement("span");
  const { radius: radius2, scale: scale2, x, y, centerX, centerY } = calculate(event, container);
  const color = container.dataset.color;
  const size3 = `${radius2 * 2}px`;
  wave.className = "animation";
  wave.style.width = size3;
  wave.style.height = size3;
  wave.style.background = color;
  wave.classList.add("animation-enter");
  wave.classList.add("animation--visible");
  transform(wave, `translate(${x}, ${y}) scale3d(${scale2},${scale2},${scale2})`);
  opacity(wave, 0);
  wave.dataset.activated = String(performance.now());
  container.appendChild(wave);
  setTimeout(
    () => {
      wave.classList.remove("animation-enter");
      wave.classList.add("animation-in");
      transform(wave, `translate(${centerX}, ${centerY}) scale3d(1,1,1)`);
      opacity(wave, 0.25);
    },
    0
  );
  const releaseEvent = eventType === "mousedown" ? "mouseup" : "touchend";
  const onRelease = function() {
    document.removeEventListener(releaseEvent, onRelease);
    hideEvents.forEach((name) => {
      document.removeEventListener(name, onRelease);
    });
    const diff = performance.now() - Number(wave.dataset.activated);
    const delay = Math.max(250 - diff, 0);
    setTimeout(
      () => {
        wave.classList.remove("animation-in");
        wave.classList.add("animation-out");
        opacity(wave, 0);
        setTimeout(
          () => {
            wave && container.removeChild(wave);
            if (container.children.length === 0) {
              delete container.dataset.event;
            }
          },
          300
        );
      },
      delay
    );
  };
  document.addEventListener(releaseEvent, onRelease);
  hideEvents.forEach((name) => {
    document.addEventListener(name, onRelease, { passive: true });
  });
};
var onMouseDown = function(e) {
  if (e.button === 0) {
    startRipple(e.type, e);
  }
};
var onTouchStart = function(e) {
  if (e.changedTouches) {
    for (let i2 = 0; i2 < e.changedTouches.length; ++i2) {
      startRipple(e.type, e.changedTouches[i2]);
    }
  }
};
function instance10($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Ripple", slots, []);
  let { center = false } = $$props;
  let { circle = false } = $$props;
  let { color = "currentColor" } = $$props;
  let el;
  let trigEl;
  onMount(async () => {
    await tick();
    try {
      if (center) {
        $$invalidate(0, el.dataset.center = "true", el);
      }
      if (circle) {
        $$invalidate(0, el.dataset.circle = "true", el);
      }
      $$invalidate(0, el.dataset.color = color, el);
      trigEl = el.parentElement;
    } catch (err) {
    }
    if (!trigEl) {
      console.error("Ripple: Trigger element not found.");
      return;
    }
    let style2 = window.getComputedStyle(trigEl);
    if (style2.position.length === 0 || style2.position === "static") {
      trigEl.style.position = "relative";
    }
    trigEl.addEventListener("touchstart", onTouchStart, { passive: true });
    trigEl.addEventListener("mousedown", onMouseDown, { passive: true });
  });
  onDestroy(() => {
    if (!trigEl) {
      return;
    }
    trigEl.removeEventListener("mousedown", onMouseDown);
    trigEl.removeEventListener("touchstart", onTouchStart);
  });
  const writable_props = ["center", "circle", "color"];
  Object.keys($$props).forEach((key3) => {
    if (!~writable_props.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console_1.warn(`<Ripple> was created with unknown prop '${key3}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("center" in $$props2)
      $$invalidate(1, center = $$props2.center);
    if ("circle" in $$props2)
      $$invalidate(2, circle = $$props2.circle);
    if ("color" in $$props2)
      $$invalidate(3, color = $$props2.color);
  };
  $$self.$capture_state = () => ({
    isTouchEvent,
    transform,
    opacity,
    calculate,
    startRipple,
    onMouseDown,
    onTouchStart,
    center,
    circle,
    color,
    tick,
    onMount,
    onDestroy,
    el,
    trigEl
  });
  $$self.$inject_state = ($$props2) => {
    if ("center" in $$props2)
      $$invalidate(1, center = $$props2.center);
    if ("circle" in $$props2)
      $$invalidate(2, circle = $$props2.circle);
    if ("color" in $$props2)
      $$invalidate(3, color = $$props2.color);
    if ("el" in $$props2)
      $$invalidate(0, el = $$props2.el);
    if ("trigEl" in $$props2)
      trigEl = $$props2.trigEl;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [el, center, circle, color, div_binding];
}
var Ripple = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, { center: 1, circle: 2, color: 3 }, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Ripple",
      options,
      id: create_fragment10.name
    });
  }
  get center() {
    throw new Error("<Ripple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set center(value) {
    throw new Error("<Ripple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get circle() {
    throw new Error("<Ripple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set circle(value) {
    throw new Error("<Ripple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Ripple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Ripple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Ripple_default = Ripple;

// node_modules/@svelteuidev/core/dist/components/Button/Button.svelte
var { Error: Error_12 } = globals;
var file8 = "node_modules/@svelteuidev/core/dist/components/Button/Button.svelte";
function add_css2(target) {
  append_styles(target, "svelte-5xpm5q", ".uppercase.svelte-5xpm5q{text-transform:uppercase}.left-section.svelte-5xpm5q{margin-right:10px;display:flex;align-items:center;justify-content:center}.right-section.svelte-5xpm5q{margin-left:10px;display:flex;align-items:center;justify-content:center}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQnV0dG9uLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyIvVXNlcnMvbWFudmlzaW5naGFsL0RvY3VtZW50cy9HaXRIdWIvYmFja3BhY2trLXN2ZWx0ZS9ub2RlX21vZHVsZXMvQHN2ZWx0ZXVpZGV2L2NvcmUvZGlzdC9jb21wb25lbnRzL0J1dHRvbi9CdXR0b24uc3ZlbHRlIl19 */");
}
var get_rightIcon_slot_changes_1 = (dirty) => ({});
var get_rightIcon_slot_context_1 = (ctx8) => ({});
var get_leftIcon_slot_changes_1 = (dirty) => ({});
var get_leftIcon_slot_context_1 = (ctx8) => ({});
var get_rightIcon_slot_changes = (dirty) => ({});
var get_rightIcon_slot_context = (ctx8) => ({});
var get_leftIcon_slot_changes = (dirty) => ({});
var get_leftIcon_slot_context = (ctx8) => ({});
function create_else_block2(ctx8) {
  let button;
  let current_block_type_index;
  let if_block0;
  let t0;
  let t1;
  let t2;
  let current_block_type_index_1;
  let if_block2;
  let button_class_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_9, create_if_block_10];
  const if_blocks = [];
  function select_block_type_3(ctx9, dirty) {
    if (
      /*loading*/
      ctx9[11] && /*loaderPosition*/
      ctx9[5] === "left"
    )
      return 0;
    if (
      /*$$slots*/
      ctx9[21].leftIcon
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_3(ctx8, -1))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx8);
  }
  const default_slot_template = (
    /*#slots*/
    ctx8[28].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[27],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block_4(ctx8);
  let if_block1 = (
    /*ripple*/
    ctx8[13] && create_if_block_8(ctx8)
  );
  const if_block_creators_1 = [create_if_block_6, create_if_block_7];
  const if_blocks_1 = [];
  function select_block_type_4(ctx9, dirty) {
    if (
      /*loading*/
      ctx9[11] && /*loaderPosition*/
      ctx9[5] === "right"
    )
      return 0;
    if (
      /*$$slots*/
      ctx9[21].rightIcon
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index_1 = select_block_type_4(ctx8, -1))) {
    if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx8);
  }
  let button_levels = [
    {
      class: button_class_value = /*cx*/
      ctx8[18](
        /*className*/
        ctx8[3],
        /*classes*/
        ctx8[17].root,
        /*getStyles*/
        ctx8[16]({
          css: (
            /*override*/
            ctx8[1]
          ),
          variation: (
            /*variant*/
            ctx8[4]
          )
        }),
        {
          [
            /*classes*/
            ctx8[17].disabled
          ]: (
            /*disabled*/
            ctx8[9]
          ),
          [
            /*classes*/
            ctx8[17].loading
          ]: (
            /*loading*/
            ctx8[11]
          )
        }
      )
    },
    { disabled: (
      /*disabled*/
      ctx8[9]
    ) },
    /*$$restProps*/
    ctx8[20],
    { tabindex: "0" }
  ];
  let button_data = {};
  for (let i2 = 0; i2 < button_levels.length; i2 += 1) {
    button_data = assign(button_data, button_levels[i2]);
  }
  const block = {
    c: function create() {
      button = element("button");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true, tabindex: true });
      var button_nodes = children(button);
      if (if_block0)
        if_block0.l(button_nodes);
      t0 = claim_space(button_nodes);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(button_nodes);
      t1 = claim_space(button_nodes);
      if (if_block1)
        if_block1.l(button_nodes);
      t2 = claim_space(button_nodes);
      if (if_block2)
        if_block2.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      toggle_class(
        button,
        "compact",
        /*compact*/
        ctx8[10]
      );
      toggle_class(
        button,
        "uppercase",
        /*uppercase*/
        ctx8[12]
      );
      toggle_class(button, "svelte-5xpm5q", true);
      add_location(button, file8, 96, 1, 3085);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(button, null);
      }
      append_hydration_dev(button, t0);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(button, null);
      }
      append_hydration_dev(button, t1);
      if (if_block1)
        if_block1.m(button, null);
      append_hydration_dev(button, t2);
      if (~current_block_type_index_1) {
        if_blocks_1[current_block_type_index_1].m(button, null);
      }
      if (button.autofocus)
        button.focus();
      ctx8[30](button);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            button,
            /*use*/
            ctx8[2]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx8[19].call(null, button))
        ];
        mounted = true;
      }
    },
    p: function update(ctx9, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_3(ctx9, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx9, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx9);
            if_block0.c();
          } else {
            if_block0.p(ctx9, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(button, t0);
        } else {
          if_block0 = null;
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[27]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[27],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*ripple*/
        ctx9[13]
      ) {
        if (if_block1) {
          if (dirty & /*ripple*/
          8192) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_8(ctx9);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(button, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      let previous_block_index_1 = current_block_type_index_1;
      current_block_type_index_1 = select_block_type_4(ctx9, dirty);
      if (current_block_type_index_1 === previous_block_index_1) {
        if (~current_block_type_index_1) {
          if_blocks_1[current_block_type_index_1].p(ctx9, dirty);
        }
      } else {
        if (if_block2) {
          group_outros();
          transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
            if_blocks_1[previous_block_index_1] = null;
          });
          check_outros();
        }
        if (~current_block_type_index_1) {
          if_block2 = if_blocks_1[current_block_type_index_1];
          if (!if_block2) {
            if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx9);
            if_block2.c();
          } else {
            if_block2.p(ctx9, dirty);
          }
          transition_in(if_block2, 1);
          if_block2.m(button, null);
        } else {
          if_block2 = null;
        }
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        (!current || dirty & /*cx, className, classes, getStyles, override, variant, disabled, loading*/
        461338 && button_class_value !== (button_class_value = /*cx*/
        ctx9[18](
          /*className*/
          ctx9[3],
          /*classes*/
          ctx9[17].root,
          /*getStyles*/
          ctx9[16]({
            css: (
              /*override*/
              ctx9[1]
            ),
            variation: (
              /*variant*/
              ctx9[4]
            )
          }),
          {
            [
              /*classes*/
              ctx9[17].disabled
            ]: (
              /*disabled*/
              ctx9[9]
            ),
            [
              /*classes*/
              ctx9[17].loading
            ]: (
              /*loading*/
              ctx9[11]
            )
          }
        ))) && { class: button_class_value },
        (!current || dirty & /*disabled*/
        512) && { disabled: (
          /*disabled*/
          ctx9[9]
        ) },
        dirty & /*$$restProps*/
        1048576 && /*$$restProps*/
        ctx9[20],
        { tabindex: "0" }
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      4)
        useActions_action.update.call(
          null,
          /*use*/
          ctx9[2]
        );
      toggle_class(
        button,
        "compact",
        /*compact*/
        ctx9[10]
      );
      toggle_class(
        button,
        "uppercase",
        /*uppercase*/
        ctx9[12]
      );
      toggle_class(button, "svelte-5xpm5q", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(default_slot_or_fallback, local);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(default_slot_or_fallback, local);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      if (if_block1)
        if_block1.d();
      if (~current_block_type_index_1) {
        if_blocks_1[current_block_type_index_1].d();
      }
      ctx8[30](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(96:0) {:else}",
    ctx: ctx8
  });
  return block;
}
function create_if_block3(ctx8) {
  let a;
  let current_block_type_index;
  let if_block0;
  let t0;
  let t1;
  let t2;
  let current_block_type_index_1;
  let if_block2;
  let a_class_value;
  let a_target_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_4, create_if_block_5];
  const if_blocks = [];
  function select_block_type_1(ctx9, dirty) {
    if (
      /*loading*/
      ctx9[11] && /*loaderPosition*/
      ctx9[5] === "left"
    )
      return 0;
    if (
      /*$$slots*/
      ctx9[21].leftIcon
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx8, -1))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx8);
  }
  const default_slot_template = (
    /*#slots*/
    ctx8[28].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[27],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block_1(ctx8);
  let if_block1 = (
    /*ripple*/
    ctx8[13] && create_if_block_3(ctx8)
  );
  const if_block_creators_1 = [create_if_block_12, create_if_block_2];
  const if_blocks_1 = [];
  function select_block_type_2(ctx9, dirty) {
    if (
      /*loading*/
      ctx9[11] && /*loaderPosition*/
      ctx9[5] === "right"
    )
      return 0;
    if (
      /*$$slots*/
      ctx9[21].rightIcon
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index_1 = select_block_type_2(ctx8, -1))) {
    if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx8);
  }
  let a_levels = [
    { href: (
      /*href*/
      ctx8[7]
    ) },
    {
      class: a_class_value = /*cx*/
      ctx8[18](
        /*className*/
        ctx8[3],
        /*classes*/
        ctx8[17].root,
        /*getStyles*/
        ctx8[16]({
          css: (
            /*override*/
            ctx8[1]
          ),
          variation: (
            /*variant*/
            ctx8[4]
          ),
          disabled: (
            /*disabled*/
            ctx8[9]
          )
        }),
        {
          [
            /*classes*/
            ctx8[17].disabled
          ]: (
            /*disabled*/
            ctx8[9]
          ),
          [
            /*classes*/
            ctx8[17].loading
          ]: (
            /*loading*/
            ctx8[11]
          )
        }
      )
    },
    { role: "button" },
    { rel: "noreferrer noopener" },
    {
      target: a_target_value = /*external*/
      ctx8[8] ? "_blank" : "_self"
    },
    /*$$restProps*/
    ctx8[20],
    { tabindex: "0" }
  ];
  let a_data = {};
  for (let i2 = 0; i2 < a_levels.length; i2 += 1) {
    a_data = assign(a_data, a_levels[i2]);
  }
  const block = {
    c: function create() {
      a = element("a");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", {
        href: true,
        class: true,
        role: true,
        rel: true,
        target: true,
        tabindex: true
      });
      var a_nodes = children(a);
      if (if_block0)
        if_block0.l(a_nodes);
      t0 = claim_space(a_nodes);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(a_nodes);
      t1 = claim_space(a_nodes);
      if (if_block1)
        if_block1.l(a_nodes);
      t2 = claim_space(a_nodes);
      if (if_block2)
        if_block2.l(a_nodes);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(a, a_data);
      toggle_class(
        a,
        "compact",
        /*compact*/
        ctx8[10]
      );
      toggle_class(
        a,
        "uppercase",
        /*uppercase*/
        ctx8[12]
      );
      toggle_class(a, "svelte-5xpm5q", true);
      add_location(a, file8, 55, 1, 1981);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(a, null);
      }
      append_hydration_dev(a, t0);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(a, null);
      }
      append_hydration_dev(a, t1);
      if (if_block1)
        if_block1.m(a, null);
      append_hydration_dev(a, t2);
      if (~current_block_type_index_1) {
        if_blocks_1[current_block_type_index_1].m(a, null);
      }
      ctx8[29](a);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            a,
            /*use*/
            ctx8[2]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx8[19].call(null, a))
        ];
        mounted = true;
      }
    },
    p: function update(ctx9, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx9, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx9, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx9);
            if_block0.c();
          } else {
            if_block0.p(ctx9, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(a, t0);
        } else {
          if_block0 = null;
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[27]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[27],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*ripple*/
        ctx9[13]
      ) {
        if (if_block1) {
          if (dirty & /*ripple*/
          8192) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_3(ctx9);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(a, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      let previous_block_index_1 = current_block_type_index_1;
      current_block_type_index_1 = select_block_type_2(ctx9, dirty);
      if (current_block_type_index_1 === previous_block_index_1) {
        if (~current_block_type_index_1) {
          if_blocks_1[current_block_type_index_1].p(ctx9, dirty);
        }
      } else {
        if (if_block2) {
          group_outros();
          transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
            if_blocks_1[previous_block_index_1] = null;
          });
          check_outros();
        }
        if (~current_block_type_index_1) {
          if_block2 = if_blocks_1[current_block_type_index_1];
          if (!if_block2) {
            if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx9);
            if_block2.c();
          } else {
            if_block2.p(ctx9, dirty);
          }
          transition_in(if_block2, 1);
          if_block2.m(a, null);
        } else {
          if_block2 = null;
        }
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*href*/
        128) && { href: (
          /*href*/
          ctx9[7]
        ) },
        (!current || dirty & /*cx, className, classes, getStyles, override, variant, disabled, loading*/
        461338 && a_class_value !== (a_class_value = /*cx*/
        ctx9[18](
          /*className*/
          ctx9[3],
          /*classes*/
          ctx9[17].root,
          /*getStyles*/
          ctx9[16]({
            css: (
              /*override*/
              ctx9[1]
            ),
            variation: (
              /*variant*/
              ctx9[4]
            ),
            disabled: (
              /*disabled*/
              ctx9[9]
            )
          }),
          {
            [
              /*classes*/
              ctx9[17].disabled
            ]: (
              /*disabled*/
              ctx9[9]
            ),
            [
              /*classes*/
              ctx9[17].loading
            ]: (
              /*loading*/
              ctx9[11]
            )
          }
        ))) && { class: a_class_value },
        { role: "button" },
        { rel: "noreferrer noopener" },
        (!current || dirty & /*external*/
        256 && a_target_value !== (a_target_value = /*external*/
        ctx9[8] ? "_blank" : "_self")) && { target: a_target_value },
        dirty & /*$$restProps*/
        1048576 && /*$$restProps*/
        ctx9[20],
        { tabindex: "0" }
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      4)
        useActions_action.update.call(
          null,
          /*use*/
          ctx9[2]
        );
      toggle_class(
        a,
        "compact",
        /*compact*/
        ctx9[10]
      );
      toggle_class(
        a,
        "uppercase",
        /*uppercase*/
        ctx9[12]
      );
      toggle_class(a, "svelte-5xpm5q", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(default_slot_or_fallback, local);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(default_slot_or_fallback, local);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      if (if_block1)
        if_block1.d();
      if (~current_block_type_index_1) {
        if_blocks_1[current_block_type_index_1].d();
      }
      ctx8[29](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(55:0) {#if href}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_10(ctx8) {
  let span;
  let current;
  const leftIcon_slot_template = (
    /*#slots*/
    ctx8[28].leftIcon
  );
  const leftIcon_slot = create_slot(
    leftIcon_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[27],
    get_leftIcon_slot_context_1
  );
  const leftIcon_slot_or_fallback = leftIcon_slot || fallback_block_5(ctx8);
  const block = {
    c: function create() {
      span = element("span");
      if (leftIcon_slot_or_fallback)
        leftIcon_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (leftIcon_slot_or_fallback)
        leftIcon_slot_or_fallback.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "left-section svelte-5xpm5q");
      add_location(span, file8, 115, 3, 3615);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (leftIcon_slot_or_fallback) {
        leftIcon_slot_or_fallback.m(span, null);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (leftIcon_slot) {
        if (leftIcon_slot.p && (!current || dirty & /*$$scope*/
        134217728)) {
          update_slot_base(
            leftIcon_slot,
            leftIcon_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[27]
            ) : get_slot_changes(
              leftIcon_slot_template,
              /*$$scope*/
              ctx9[27],
              dirty,
              get_leftIcon_slot_changes_1
            ),
            get_leftIcon_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(leftIcon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(leftIcon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (leftIcon_slot_or_fallback)
        leftIcon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: "(115:29) ",
    ctx: ctx8
  });
  return block;
}
function create_if_block_9(ctx8) {
  let span;
  let loader;
  let current;
  loader = new Loader_default({
    props: {
      variant: (
        /*loaderProps*/
        ctx8[6].variant
      ),
      size: (
        /*loaderProps*/
        ctx8[6].size
      ),
      color: (
        /*loaderProps*/
        ctx8[6].color
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      span = element("span");
      create_component(loader.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(loader.$$.fragment, span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "left-section svelte-5xpm5q");
      add_location(span, file8, 111, 3, 3448);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      mount_component(loader, span, null);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const loader_changes = {};
      if (dirty & /*loaderProps*/
      64)
        loader_changes.variant = /*loaderProps*/
        ctx9[6].variant;
      if (dirty & /*loaderProps*/
      64)
        loader_changes.size = /*loaderProps*/
        ctx9[6].size;
      if (dirty & /*loaderProps*/
      64)
        loader_changes.color = /*loaderProps*/
        ctx9[6].color;
      loader.$set(loader_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      destroy_component(loader);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: "(111:2) {#if loading && loaderPosition === 'left'}",
    ctx: ctx8
  });
  return block;
}
function fallback_block_5(ctx8) {
  let t;
  const block = {
    c: function create() {
      t = text("X");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "X");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_5.name,
    type: "fallback",
    source: "(117:26) X",
    ctx: ctx8
  });
  return block;
}
function fallback_block_4(ctx8) {
  let t;
  const block = {
    c: function create() {
      t = text("Button");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Button");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_4.name,
    type: "fallback",
    source: "(120:8) Button",
    ctx: ctx8
  });
  return block;
}
function create_if_block_8(ctx8) {
  let ripple_1;
  let current;
  ripple_1 = new Ripple_default({
    props: { center: false, circle: false },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(ripple_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(ripple_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(ripple_1, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(ripple_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(ripple_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(ripple_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(121:2) {#if ripple}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_7(ctx8) {
  let span;
  let current;
  const rightIcon_slot_template = (
    /*#slots*/
    ctx8[28].rightIcon
  );
  const rightIcon_slot = create_slot(
    rightIcon_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[27],
    get_rightIcon_slot_context_1
  );
  const rightIcon_slot_or_fallback = rightIcon_slot || fallback_block_3(ctx8);
  const block = {
    c: function create() {
      span = element("span");
      if (rightIcon_slot_or_fallback)
        rightIcon_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (rightIcon_slot_or_fallback)
        rightIcon_slot_or_fallback.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "right-section svelte-5xpm5q");
      add_location(span, file8, 128, 3, 4004);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (rightIcon_slot_or_fallback) {
        rightIcon_slot_or_fallback.m(span, null);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (rightIcon_slot) {
        if (rightIcon_slot.p && (!current || dirty & /*$$scope*/
        134217728)) {
          update_slot_base(
            rightIcon_slot,
            rightIcon_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[27]
            ) : get_slot_changes(
              rightIcon_slot_template,
              /*$$scope*/
              ctx9[27],
              dirty,
              get_rightIcon_slot_changes_1
            ),
            get_rightIcon_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rightIcon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rightIcon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (rightIcon_slot_or_fallback)
        rightIcon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(128:30) ",
    ctx: ctx8
  });
  return block;
}
function create_if_block_6(ctx8) {
  let span;
  let loader;
  let current;
  loader = new Loader_default({
    props: {
      variant: (
        /*loaderProps*/
        ctx8[6].variant
      ),
      size: (
        /*loaderProps*/
        ctx8[6].size
      ),
      color: (
        /*loaderProps*/
        ctx8[6].color
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      span = element("span");
      create_component(loader.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(loader.$$.fragment, span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "right-section svelte-5xpm5q");
      add_location(span, file8, 124, 3, 3835);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      mount_component(loader, span, null);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const loader_changes = {};
      if (dirty & /*loaderProps*/
      64)
        loader_changes.variant = /*loaderProps*/
        ctx9[6].variant;
      if (dirty & /*loaderProps*/
      64)
        loader_changes.size = /*loaderProps*/
        ctx9[6].size;
      if (dirty & /*loaderProps*/
      64)
        loader_changes.color = /*loaderProps*/
        ctx9[6].color;
      loader.$set(loader_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      destroy_component(loader);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(124:2) {#if loading && loaderPosition === 'right'}",
    ctx: ctx8
  });
  return block;
}
function fallback_block_3(ctx8) {
  let t;
  const block = {
    c: function create() {
      t = text("X");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "X");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_3.name,
    type: "fallback",
    source: "(130:27) X",
    ctx: ctx8
  });
  return block;
}
function create_if_block_5(ctx8) {
  let span;
  let current;
  const leftIcon_slot_template = (
    /*#slots*/
    ctx8[28].leftIcon
  );
  const leftIcon_slot = create_slot(
    leftIcon_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[27],
    get_leftIcon_slot_context
  );
  const leftIcon_slot_or_fallback = leftIcon_slot || fallback_block_2(ctx8);
  const block = {
    c: function create() {
      span = element("span");
      if (leftIcon_slot_or_fallback)
        leftIcon_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (leftIcon_slot_or_fallback)
        leftIcon_slot_or_fallback.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "left-section svelte-5xpm5q");
      add_location(span, file8, 77, 3, 2597);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (leftIcon_slot_or_fallback) {
        leftIcon_slot_or_fallback.m(span, null);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (leftIcon_slot) {
        if (leftIcon_slot.p && (!current || dirty & /*$$scope*/
        134217728)) {
          update_slot_base(
            leftIcon_slot,
            leftIcon_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[27]
            ) : get_slot_changes(
              leftIcon_slot_template,
              /*$$scope*/
              ctx9[27],
              dirty,
              get_leftIcon_slot_changes
            ),
            get_leftIcon_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(leftIcon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(leftIcon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (leftIcon_slot_or_fallback)
        leftIcon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(77:29) ",
    ctx: ctx8
  });
  return block;
}
function create_if_block_4(ctx8) {
  let span;
  let loader;
  let current;
  loader = new Loader_default({
    props: {
      variant: (
        /*loaderProps*/
        ctx8[6].variant
      ),
      size: (
        /*loaderProps*/
        ctx8[6].size
      ),
      color: (
        /*loaderProps*/
        ctx8[6].color
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      span = element("span");
      create_component(loader.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(loader.$$.fragment, span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "left-section svelte-5xpm5q");
      add_location(span, file8, 73, 3, 2430);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      mount_component(loader, span, null);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const loader_changes = {};
      if (dirty & /*loaderProps*/
      64)
        loader_changes.variant = /*loaderProps*/
        ctx9[6].variant;
      if (dirty & /*loaderProps*/
      64)
        loader_changes.size = /*loaderProps*/
        ctx9[6].size;
      if (dirty & /*loaderProps*/
      64)
        loader_changes.color = /*loaderProps*/
        ctx9[6].color;
      loader.$set(loader_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      destroy_component(loader);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(73:2) {#if loading && loaderPosition === 'left'}",
    ctx: ctx8
  });
  return block;
}
function fallback_block_2(ctx8) {
  let t;
  const block = {
    c: function create() {
      t = text("X");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "X");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_2.name,
    type: "fallback",
    source: "(79:26) X",
    ctx: ctx8
  });
  return block;
}
function fallback_block_1(ctx8) {
  let t;
  const block = {
    c: function create() {
      t = text("Button");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Button");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(82:8) Button",
    ctx: ctx8
  });
  return block;
}
function create_if_block_3(ctx8) {
  let ripple_1;
  let current;
  ripple_1 = new Ripple_default({
    props: { center: false, circle: false },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(ripple_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(ripple_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(ripple_1, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(ripple_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(ripple_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(ripple_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(83:2) {#if ripple}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_2(ctx8) {
  let span;
  let current;
  const rightIcon_slot_template = (
    /*#slots*/
    ctx8[28].rightIcon
  );
  const rightIcon_slot = create_slot(
    rightIcon_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[27],
    get_rightIcon_slot_context
  );
  const rightIcon_slot_or_fallback = rightIcon_slot || fallback_block(ctx8);
  const block = {
    c: function create() {
      span = element("span");
      if (rightIcon_slot_or_fallback)
        rightIcon_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (rightIcon_slot_or_fallback)
        rightIcon_slot_or_fallback.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "right-section svelte-5xpm5q");
      add_location(span, file8, 90, 3, 2986);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (rightIcon_slot_or_fallback) {
        rightIcon_slot_or_fallback.m(span, null);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (rightIcon_slot) {
        if (rightIcon_slot.p && (!current || dirty & /*$$scope*/
        134217728)) {
          update_slot_base(
            rightIcon_slot,
            rightIcon_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[27]
            ) : get_slot_changes(
              rightIcon_slot_template,
              /*$$scope*/
              ctx9[27],
              dirty,
              get_rightIcon_slot_changes
            ),
            get_rightIcon_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rightIcon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rightIcon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (rightIcon_slot_or_fallback)
        rightIcon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(90:30) ",
    ctx: ctx8
  });
  return block;
}
function create_if_block_12(ctx8) {
  let span;
  let loader;
  let current;
  loader = new Loader_default({
    props: {
      variant: (
        /*loaderProps*/
        ctx8[6].variant
      ),
      size: (
        /*loaderProps*/
        ctx8[6].size
      ),
      color: (
        /*loaderProps*/
        ctx8[6].color
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      span = element("span");
      create_component(loader.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(loader.$$.fragment, span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "right-section svelte-5xpm5q");
      add_location(span, file8, 86, 3, 2817);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      mount_component(loader, span, null);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const loader_changes = {};
      if (dirty & /*loaderProps*/
      64)
        loader_changes.variant = /*loaderProps*/
        ctx9[6].variant;
      if (dirty & /*loaderProps*/
      64)
        loader_changes.size = /*loaderProps*/
        ctx9[6].size;
      if (dirty & /*loaderProps*/
      64)
        loader_changes.color = /*loaderProps*/
        ctx9[6].color;
      loader.$set(loader_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      destroy_component(loader);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(86:2) {#if loading && loaderPosition === 'right'}",
    ctx: ctx8
  });
  return block;
}
function fallback_block(ctx8) {
  let t;
  const block = {
    c: function create() {
      t = text("X");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "X");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(92:27) X",
    ctx: ctx8
  });
  return block;
}
function create_fragment11(ctx8) {
  let error;
  let t;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  error = new Error_default({
    props: {
      observable: (
        /*observable*/
        ctx8[14]
      ),
      component: "Button",
      code: (
        /*err*/
        ctx8[15]
      )
    },
    $$inline: true
  });
  const if_block_creators = [create_if_block3, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx9, dirty) {
    if (
      /*href*/
      ctx9[7]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx8, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx8);
  const block = {
    c: function create() {
      create_component(error.$$.fragment);
      t = space();
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(error.$$.fragment, nodes);
      t = claim_space(nodes);
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(error, target, anchor);
      insert_hydration_dev(target, t, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const error_changes = {};
      if (dirty & /*observable*/
      16384)
        error_changes.observable = /*observable*/
        ctx9[14];
      if (dirty & /*err*/
      32768)
        error_changes.code = /*err*/
        ctx9[15];
      error.$set(error_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx9, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx9, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx9);
          if_block.c();
        } else {
          if_block.p(ctx9, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(error.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(error.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(if_block_anchor);
      }
      destroy_component(error, detaching);
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "variant",
    "color",
    "size",
    "radius",
    "gradient",
    "loaderPosition",
    "loaderProps",
    "href",
    "external",
    "disabled",
    "compact",
    "loading",
    "uppercase",
    "fullSize",
    "ripple"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Button", slots, ["leftIcon", "default", "rightIcon"]);
  const $$slots = compute_slots(slots);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, variant: variant2 = "filled", color = "blue", size: size3 = "sm", radius: radius2 = "sm", gradient = { from: "indigo", to: "cyan", deg: 45 }, loaderPosition = "left", loaderProps = {
    size: "xs",
    color: "white",
    variant: "circle"
  }, href = null, external = false, disabled = false, compact = false, loading = false, uppercase = false, fullSize = false, ripple = false } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  let observable = false;
  let err;
  if (disabled && loading) {
    observable = true;
    err = ButtonErrors[0];
  }
  if (external && typeof href !== "string" || (href == null ? void 0 : href.length) < 1) {
    observable = true;
    err = ButtonErrors[1];
  }
  function a_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(20, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(1, override = $$new_props.override);
    if ("variant" in $$new_props)
      $$invalidate(4, variant2 = $$new_props.variant);
    if ("color" in $$new_props)
      $$invalidate(22, color = $$new_props.color);
    if ("size" in $$new_props)
      $$invalidate(23, size3 = $$new_props.size);
    if ("radius" in $$new_props)
      $$invalidate(24, radius2 = $$new_props.radius);
    if ("gradient" in $$new_props)
      $$invalidate(25, gradient = $$new_props.gradient);
    if ("loaderPosition" in $$new_props)
      $$invalidate(5, loaderPosition = $$new_props.loaderPosition);
    if ("loaderProps" in $$new_props)
      $$invalidate(6, loaderProps = $$new_props.loaderProps);
    if ("href" in $$new_props)
      $$invalidate(7, href = $$new_props.href);
    if ("external" in $$new_props)
      $$invalidate(8, external = $$new_props.external);
    if ("disabled" in $$new_props)
      $$invalidate(9, disabled = $$new_props.disabled);
    if ("compact" in $$new_props)
      $$invalidate(10, compact = $$new_props.compact);
    if ("loading" in $$new_props)
      $$invalidate(11, loading = $$new_props.loading);
    if ("uppercase" in $$new_props)
      $$invalidate(12, uppercase = $$new_props.uppercase);
    if ("fullSize" in $$new_props)
      $$invalidate(26, fullSize = $$new_props.fullSize);
    if ("ripple" in $$new_props)
      $$invalidate(13, ripple = $$new_props.ripple);
    if ("$$scope" in $$new_props)
      $$invalidate(27, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: Button_styles_default,
    get_current_component,
    createEventForwarder,
    useActions,
    ButtonErrors,
    Error: Error_default,
    Loader: Loader_default,
    Ripple: Ripple_default,
    use,
    element: element2,
    className,
    override,
    variant: variant2,
    color,
    size: size3,
    radius: radius2,
    gradient,
    loaderPosition,
    loaderProps,
    href,
    external,
    disabled,
    compact,
    loading,
    uppercase,
    fullSize,
    ripple,
    forwardEvents,
    observable,
    err,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(1, override = $$new_props.override);
    if ("variant" in $$props)
      $$invalidate(4, variant2 = $$new_props.variant);
    if ("color" in $$props)
      $$invalidate(22, color = $$new_props.color);
    if ("size" in $$props)
      $$invalidate(23, size3 = $$new_props.size);
    if ("radius" in $$props)
      $$invalidate(24, radius2 = $$new_props.radius);
    if ("gradient" in $$props)
      $$invalidate(25, gradient = $$new_props.gradient);
    if ("loaderPosition" in $$props)
      $$invalidate(5, loaderPosition = $$new_props.loaderPosition);
    if ("loaderProps" in $$props)
      $$invalidate(6, loaderProps = $$new_props.loaderProps);
    if ("href" in $$props)
      $$invalidate(7, href = $$new_props.href);
    if ("external" in $$props)
      $$invalidate(8, external = $$new_props.external);
    if ("disabled" in $$props)
      $$invalidate(9, disabled = $$new_props.disabled);
    if ("compact" in $$props)
      $$invalidate(10, compact = $$new_props.compact);
    if ("loading" in $$props)
      $$invalidate(11, loading = $$new_props.loading);
    if ("uppercase" in $$props)
      $$invalidate(12, uppercase = $$new_props.uppercase);
    if ("fullSize" in $$props)
      $$invalidate(26, fullSize = $$new_props.fullSize);
    if ("ripple" in $$props)
      $$invalidate(13, ripple = $$new_props.ripple);
    if ("observable" in $$props)
      $$invalidate(14, observable = $$new_props.observable);
    if ("err" in $$props)
      $$invalidate(15, err = $$new_props.err);
    if ("getStyles" in $$props)
      $$invalidate(16, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(17, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(18, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*observable*/
    16384) {
      $:
        if (observable)
          $$invalidate(1, override = { display: "none" });
    }
    if ($$self.$$.dirty & /*color, compact, fullSize, gradient, radius, size, variant*/
    130024464) {
      $:
        $$invalidate(
          18,
          { cx: cx2, classes, getStyles } = Button_styles_default(
            {
              color,
              compact,
              fullSize,
              gradient,
              radius: radius2,
              size: size3,
              variant: variant2
            },
            { name: "Button" }
          ),
          cx2,
          ($$invalidate(17, classes), $$invalidate(22, color), $$invalidate(10, compact), $$invalidate(26, fullSize), $$invalidate(25, gradient), $$invalidate(24, radius2), $$invalidate(23, size3), $$invalidate(4, variant2)),
          ($$invalidate(16, getStyles), $$invalidate(22, color), $$invalidate(10, compact), $$invalidate(26, fullSize), $$invalidate(25, gradient), $$invalidate(24, radius2), $$invalidate(23, size3), $$invalidate(4, variant2))
        );
    }
  };
  return [
    element2,
    override,
    use,
    className,
    variant2,
    loaderPosition,
    loaderProps,
    href,
    external,
    disabled,
    compact,
    loading,
    uppercase,
    ripple,
    observable,
    err,
    getStyles,
    classes,
    cx2,
    forwardEvents,
    $$restProps,
    $$slots,
    color,
    size3,
    radius2,
    gradient,
    fullSize,
    $$scope,
    slots,
    a_binding,
    button_binding
  ];
}
var Button = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance11,
      create_fragment11,
      safe_not_equal,
      {
        use: 2,
        element: 0,
        class: 3,
        override: 1,
        variant: 4,
        color: 22,
        size: 23,
        radius: 24,
        gradient: 25,
        loaderPosition: 5,
        loaderProps: 6,
        href: 7,
        external: 8,
        disabled: 9,
        compact: 10,
        loading: 11,
        uppercase: 12,
        fullSize: 26,
        ripple: 13
      },
      add_css2
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Button",
      options,
      id: create_fragment11.name
    });
  }
  get use() {
    throw new Error_12("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error_12("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error_12("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error_12("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error_12("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error_12("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error_12("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error_12("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error_12("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error_12("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error_12("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error_12("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error_12("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error_12("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error_12("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error_12("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gradient() {
    throw new Error_12("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gradient(value) {
    throw new Error_12("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loaderPosition() {
    throw new Error_12("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loaderPosition(value) {
    throw new Error_12("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loaderProps() {
    throw new Error_12("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loaderProps(value) {
    throw new Error_12("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error_12("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error_12("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get external() {
    throw new Error_12("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set external(value) {
    throw new Error_12("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error_12("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error_12("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get compact() {
    throw new Error_12("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set compact(value) {
    throw new Error_12("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loading() {
    throw new Error_12("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loading(value) {
    throw new Error_12("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get uppercase() {
    throw new Error_12("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set uppercase(value) {
    throw new Error_12("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fullSize() {
    throw new Error_12("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fullSize(value) {
    throw new Error_12("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ripple() {
    throw new Error_12("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ripple(value) {
    throw new Error_12("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Button_default = Button;

// node_modules/@svelteuidev/core/dist/components/Button/UnstyledButton/UnstyledButton.styles.js
var UnstyledButton_styles_default = createStyles((theme4) => {
  var _a;
  return {
    root: {
      [`${theme4.dark} &`]: {
        color: (_a = theme4.colors["dark50"]) == null ? void 0 : _a.value
      },
      focusRing: "auto",
      cursor: "pointer",
      border: 0,
      padding: 0,
      appearance: "none",
      fontFamily: theme4.fonts.standard.value ?? "sans-serif",
      fontSize: theme4.fontSizes.md.value,
      backgroundColor: "transparent",
      textAlign: "left",
      color: "black",
      textDecoration: "none"
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Button/UnstyledButton/UnstyledButton.svelte
function create_default_slot3(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[12],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[12],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(12:0) <Box  bind:element  use={[forwardEvents, [useActions, use]]}  class={cx(className, classes.root, getStyles({ css: override }))}  {root}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment12(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    {
      use: [
        /*forwardEvents*/
        ctx8[8],
        [
          useActions,
          /*use*/
          ctx8[1]
        ]
      ]
    },
    {
      class: (
        /*cx*/
        ctx8[7](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[6].root,
          /*getStyles*/
          ctx8[5]({ css: (
            /*override*/
            ctx8[3]
          ) })
        )
      )
    },
    { root: (
      /*root*/
      ctx8[4]
    ) },
    /*$$restProps*/
    ctx8[9]
  ];
  function box_element_binding(value) {
    ctx8[11](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot3] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*forwardEvents, use, cx, className, classes, getStyles, override, root, $$restProps*/
      1022 ? get_spread_update(box_spread_levels, [
        dirty & /*forwardEvents, use*/
        258 && {
          use: [
            /*forwardEvents*/
            ctx9[8],
            [
              useActions,
              /*use*/
              ctx9[1]
            ]
          ]
        },
        dirty & /*cx, className, classes, getStyles, override*/
        236 && {
          class: (
            /*cx*/
            ctx9[7](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[6].root,
              /*getStyles*/
              ctx9[5]({ css: (
                /*override*/
                ctx9[3]
              ) })
            )
          )
        },
        dirty & /*root*/
        16 && { root: (
          /*root*/
          ctx9[4]
        ) },
        dirty & /*$$restProps*/
        512 && get_spread_object(
          /*$$restProps*/
          ctx9[9]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      4096) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = ["use", "element", "class", "override", "root"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("UnstyledButton", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, root = "button" } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("root" in $$new_props)
      $$invalidate(4, root = $$new_props.root);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: UnstyledButton_styles_default,
    Box: Box_default,
    createEventForwarder,
    useActions,
    get_current_component,
    use,
    element: element2,
    className,
    override,
    root,
    forwardEvents,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("root" in $$props)
      $$invalidate(4, root = $$new_props.root);
    if ("getStyles" in $$props)
      $$invalidate(5, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(6, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(7, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $:
    $$invalidate(7, { cx: cx2, classes, getStyles } = UnstyledButton_styles_default(null, { name: "UnstyledButton" }), cx2, $$invalidate(6, classes), $$invalidate(5, getStyles));
  return [
    element2,
    use,
    className,
    override,
    root,
    getStyles,
    classes,
    cx2,
    forwardEvents,
    $$restProps,
    slots,
    box_element_binding,
    $$scope
  ];
}
var UnstyledButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      root: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UnstyledButton",
      options,
      id: create_fragment12.name
    });
  }
  get use() {
    throw new Error("<UnstyledButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<UnstyledButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<UnstyledButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<UnstyledButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<UnstyledButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<UnstyledButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<UnstyledButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<UnstyledButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get root() {
    throw new Error("<UnstyledButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set root(value) {
    throw new Error("<UnstyledButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var UnstyledButton_default = UnstyledButton;

// node_modules/@svelteuidev/core/dist/components/Collapse/Collapse.svelte
var file9 = "node_modules/@svelteuidev/core/dist/components/Collapse/Collapse.svelte";
function create_if_block4(ctx8) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_13, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx9, dirty) {
    if (
      /*animateOpacity*/
      ctx9[5]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx8, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx8);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx9, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx9, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx9);
          if_block.c();
        } else {
          if_block.p(ctx9, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(22:1) {#if open}",
    ctx: ctx8
  });
  return block;
}
function create_else_block3(ctx8) {
  let div;
  let forwardEvents_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx8[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[12],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file9, 29, 3, 1018);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(forwardEvents_action = /*forwardEvents*/
        ctx8[8].call(null, div));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx8 = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx8,
            /*$$scope*/
            ctx8[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx8[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx8[12],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      add_render_callback(() => {
        if (!current)
          return;
        if (!div_transition)
          div_transition = create_bidirectional_transition(
            div,
            slide,
            /*slideTransitionOptions*/
            ctx8[7],
            true
          );
        div_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (!div_transition)
        div_transition = create_bidirectional_transition(
          div,
          slide,
          /*slideTransitionOptions*/
          ctx8[7],
          false
        );
      div_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(29:2) {:else}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_13(ctx8) {
  let div1;
  let div0;
  let forwardEvents_action;
  let div0_transition;
  let div1_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx8[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[12],
    null
  );
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div0, file9, 24, 4, 897);
      add_location(div1, file9, 23, 3, 829);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
      if (!mounted) {
        dispose = action_destroyer(forwardEvents_action = /*forwardEvents*/
        ctx8[8].call(null, div0));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx8 = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx8,
            /*$$scope*/
            ctx8[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx8[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx8[12],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      add_render_callback(() => {
        if (!current)
          return;
        if (!div0_transition)
          div0_transition = create_bidirectional_transition(
            div0,
            slide,
            /*slideTransitionOptions*/
            ctx8[7],
            true
          );
        div0_transition.run(1);
      });
      add_render_callback(() => {
        if (!current)
          return;
        if (!div1_transition)
          div1_transition = create_bidirectional_transition(div1, fade, { duration: (
            /*transitionDuration*/
            ctx8[6]
          ) }, true);
        div1_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (!div0_transition)
        div0_transition = create_bidirectional_transition(
          div0,
          slide,
          /*slideTransitionOptions*/
          ctx8[7],
          false
        );
      div0_transition.run(0);
      if (!div1_transition)
        div1_transition = create_bidirectional_transition(div1, fade, { duration: (
          /*transitionDuration*/
          ctx8[6]
        ) }, false);
      div1_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div0_transition)
        div0_transition.end();
      if (detaching && div1_transition)
        div1_transition.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(23:2) {#if animateOpacity}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot4(ctx8) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*open*/
    ctx8[4] && create_if_block4(ctx8)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (
        /*open*/
        ctx9[4]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
          if (dirty & /*open*/
          16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx9);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: "(21:0) <Box class={className} bind:element css={override} {use} {...$$restProps}>",
    ctx: ctx8
  });
  return block;
}
function create_fragment13(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { class: (
      /*className*/
      ctx8[2]
    ) },
    { css: (
      /*override*/
      ctx8[3]
    ) },
    { use: (
      /*use*/
      ctx8[1]
    ) },
    /*$$restProps*/
    ctx8[9]
  ];
  function box_element_binding(value) {
    ctx8[11](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot4] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*className, override, use, $$restProps*/
      526 ? get_spread_update(box_spread_levels, [
        dirty & /*className*/
        4 && { class: (
          /*className*/
          ctx9[2]
        ) },
        dirty & /*override*/
        8 && { css: (
          /*override*/
          ctx9[3]
        ) },
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*$$restProps*/
        512 && get_spread_object(
          /*$$restProps*/
          ctx9[9]
        )
      ]) : {};
      if (dirty & /*$$scope, transitionDuration, slideTransitionOptions, animateOpacity, open*/
      4336) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "open",
    "animateOpacity",
    "transitionDuration",
    "slideTransitionOptions"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Collapse", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, open, animateOpacity = true, transitionDuration = 200, slideTransitionOptions = { duration: transitionDuration } } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  $$self.$$.on_mount.push(function() {
    if (open === void 0 && !("open" in $$props || $$self.$$.bound[$$self.$$.props["open"]])) {
      console.warn("<Collapse> was created without expected prop 'open'");
    }
  });
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("open" in $$new_props)
      $$invalidate(4, open = $$new_props.open);
    if ("animateOpacity" in $$new_props)
      $$invalidate(5, animateOpacity = $$new_props.animateOpacity);
    if ("transitionDuration" in $$new_props)
      $$invalidate(6, transitionDuration = $$new_props.transitionDuration);
    if ("slideTransitionOptions" in $$new_props)
      $$invalidate(7, slideTransitionOptions = $$new_props.slideTransitionOptions);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    fade,
    slide,
    createEventForwarder,
    get_current_component,
    Box: Box_default,
    use,
    element: element2,
    className,
    override,
    open,
    animateOpacity,
    transitionDuration,
    slideTransitionOptions,
    forwardEvents
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("open" in $$props)
      $$invalidate(4, open = $$new_props.open);
    if ("animateOpacity" in $$props)
      $$invalidate(5, animateOpacity = $$new_props.animateOpacity);
    if ("transitionDuration" in $$props)
      $$invalidate(6, transitionDuration = $$new_props.transitionDuration);
    if ("slideTransitionOptions" in $$props)
      $$invalidate(7, slideTransitionOptions = $$new_props.slideTransitionOptions);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    use,
    className,
    override,
    open,
    animateOpacity,
    transitionDuration,
    slideTransitionOptions,
    forwardEvents,
    $$restProps,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Collapse = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      open: 4,
      animateOpacity: 5,
      transitionDuration: 6,
      slideTransitionOptions: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Collapse",
      options,
      id: create_fragment13.name
    });
  }
  get use() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animateOpacity() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animateOpacity(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionDuration() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionDuration(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slideTransitionOptions() {
    throw new Error("<Collapse>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slideTransitionOptions(value) {
    throw new Error("<Collapse>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Collapse_default = Collapse;

// node_modules/@svelteuidev/core/dist/components/Accordion/AccordionItem/AccordionItem.styles.js
var AccordionItem_styles_default = createStyles((theme4, { radius: radius2, transitionDuration, chevronPosition, chevronSize }, getRef) => {
  const radiusValue = theme4.fn.radius(radius2);
  return {
    root: {},
    active: {
      ref: getRef("active")
    },
    control: {
      ref: getRef("control"),
      width: "100%",
      display: "flex",
      alignItems: "center",
      flexDirection: chevronPosition === "right" ? "row-reverse" : "row",
      paddingRight: theme4.space.mdPX.value,
      paddingLeft: chevronPosition === "right" ? `calc(${theme4.space.mdPX.value} + 4px)` : theme4.space.xsPX.value,
      textAlign: "left",
      color: theme4.colors.black.value,
      darkMode: {
        color: theme4.fn.themeColor("dark")
      },
      "&:disabled": {
        opacity: 0.4,
        cursor: "not-allowed",
        "@media (hover: hover)": {
          "&:hover": {
            backgroundColor: "transparent"
          }
        },
        "@media (hover: none)": {
          "&:active": {
            backgroundColor: "transparent"
          }
        }
      }
    },
    chevron: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transition: `transform ${transitionDuration}ms ease`,
      marginRight: chevronPosition === "right" ? 0 : theme4.space.smPX.value,
      marginLeft: chevronPosition === "right" ? theme4.space.lgPX.value : 0,
      width: chevronSize,
      minWidth: chevronSize,
      '&[data-rotate="true"]': {
        transform: "rotate(180deg)"
      }
    },
    controlContent: {
      fontFamily: theme4.fonts.standard.value ?? "sans-serif",
      color: "inherit",
      fontWeight: 400,
      flex: 1,
      overflow: "hidden",
      textOverflow: "ellipsis",
      paddingTop: theme4.space.mdPX.value,
      paddingBottom: theme4.space.mdPX.value
    },
    panel: {
      wordBreak: "break-word",
      lineHeight: theme4.lineHeights.md.value,
      padding: theme4.space.mdPX.value,
      paddingTop: `calc(${theme4.space.xs.value} / 2)`
    },
    variants: {
      variation: {
        default: {
          color: theme4.colors.black.value,
          borderBottom: `1px solid ${theme4.fn.themeColor("gray", 3)}`,
          darkMode: {
            color: theme4.fn.themeColor("dark"),
            borderBottom: `1px solid ${theme4.fn.themeColor("dark", 4)}`
          },
          [`& .${getRef("control")}`]: {
            "@media (hover: hover)": {
              "&:hover": {
                darkMode: {
                  backgroundColor: theme4.fn.themeColor("dark", 6)
                },
                backgroundColor: theme4.fn.themeColor("gray")
              }
            },
            "@media (hover: none)": {
              "&:active": {
                darkMode: {
                  backgroundColor: theme4.fn.themeColor("dark", 6)
                },
                backgroundColor: theme4.fn.themeColor("gray")
              }
            }
          }
        },
        contained: {
          border: `1px solid ${theme4.fn.themeColor("gray", 3)}`,
          transition: "background-color 150ms ease",
          overflow: "hidden",
          [`&.${getRef("active")}`]: {
            backgroundColor: theme4.fn.themeColor("gray")
          },
          darkMode: {
            color: theme4.fn.themeColor("dark"),
            borderBottom: `1px solid ${theme4.fn.themeColor("dark", 4)}`,
            [`&.${getRef("active")}`]: {
              backgroundColor: theme4.fn.themeColor("dark", 6)
            }
          },
          "&:first-of-type": {
            borderTopRightRadius: radiusValue,
            borderTopLeftRadius: radiusValue,
            [`& > ${getRef("control")}`]: {
              borderTopRightRadius: radiusValue,
              borderTopLeftRadius: radiusValue
            }
          },
          "&:last-of-type": {
            borderBottomRightRadius: radiusValue,
            borderBottomLeftRadius: radiusValue,
            [`& > ${getRef("control")}`]: {
              borderBottomRightRadius: radiusValue,
              borderBottomLeftRadius: radiusValue
            }
          },
          "& + &": {
            borderTop: 0
          },
          [`& .${getRef("control")}`]: {
            "@media (hover: hover)": {
              "&:hover": {
                darkMode: {
                  backgroundColor: theme4.fn.themeColor("dark", 6)
                },
                backgroundColor: theme4.fn.themeColor("gray")
              }
            },
            "@media (hover: none)": {
              "&:active": {
                darkMode: {
                  backgroundColor: theme4.fn.themeColor("dark", 6)
                },
                backgroundColor: theme4.fn.themeColor("gray")
              }
            }
          }
        },
        filled: {
          borderRadius: radiusValue,
          [`&.${getRef("active")}`]: {
            backgroundColor: theme4.fn.themeColor("gray")
          },
          darkMode: {
            [`&.${getRef("active")}`]: {
              backgroundColor: theme4.fn.themeColor("dark", 6)
            }
          }
        },
        separated: {
          borderRadius: radiusValue,
          backgroundColor: theme4.fn.themeColor("gray"),
          border: `1px solid transparent`,
          transition: "background-color 150ms ease",
          "& + &": {
            marginTop: theme4.space.mdPX.value
          },
          [`&.${getRef("active")}`]: {
            backgroundColor: theme4.colors.white.value,
            borderColor: theme4.fn.themeColor("gray", 3)
          },
          darkMode: {
            [`&.${getRef("active")}`]: {
              backgroundColor: theme4.fn.themeColor("dark", 7),
              borderColor: theme4.fn.themeColor("dark", 4)
            }
          }
        }
      }
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Accordion/AccordionItem/AccordionItem.svelte
var file10 = "node_modules/@svelteuidev/core/dist/components/Accordion/AccordionItem/AccordionItem.svelte";
var get_control_slot_changes = (dirty) => ({ disabled: dirty & /*disabled*/
64 });
var get_control_slot_context = (ctx8) => ({ disabled: (
  /*disabled*/
  ctx8[6]
) });
var get_chevron_slot_changes = (dirty) => ({});
var get_chevron_slot_context = (ctx8) => ({});
function fallback_block2(ctx8) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*chevron*/
    ctx8[5] || /*$ctx*/
    ctx8[7].chevron
  );
  function switch_props(ctx9, dirty) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx8));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*chevron, $ctx*/
      160 && switch_value !== (switch_value = /*chevron*/
      ctx9[5] || /*$ctx*/
      ctx9[7].chevron)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx9, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block2.name,
    type: "fallback",
    source: "(61:24)      ",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_2(ctx8) {
  let span0;
  let span0_class_value;
  let span0_data_rotate_value;
  let t;
  let span1;
  let span1_class_value;
  let current;
  const chevron_slot_template = (
    /*#slots*/
    ctx8[15].chevron
  );
  const chevron_slot = create_slot(
    chevron_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[17],
    get_chevron_slot_context
  );
  const chevron_slot_or_fallback = chevron_slot || fallback_block2(ctx8);
  const control_slot_template = (
    /*#slots*/
    ctx8[15].control
  );
  const control_slot = create_slot(
    control_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[17],
    get_control_slot_context
  );
  const block = {
    c: function create() {
      span0 = element("span");
      if (chevron_slot_or_fallback)
        chevron_slot_or_fallback.c();
      t = space();
      span1 = element("span");
      if (control_slot)
        control_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span0 = claim_element(nodes, "SPAN", { class: true, "data-rotate": true });
      var span0_nodes = children(span0);
      if (chevron_slot_or_fallback)
        chevron_slot_or_fallback.l(span0_nodes);
      span0_nodes.forEach(detach_dev);
      t = claim_space(nodes);
      span1 = claim_element(nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      if (control_slot)
        control_slot.l(span1_nodes);
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", span0_class_value = /*classes*/
      ctx8[9].chevron);
      attr_dev(span0, "data-rotate", span0_data_rotate_value = !/*$ctx*/
      ctx8[7].disableChevronRotation && /*$ctx*/
      ctx8[7].isItemActive(
        /*value*/
        ctx8[4]
      ));
      add_location(span0, file10, 56, 2, 1631);
      attr_dev(span1, "class", span1_class_value = /*classes*/
      ctx8[9].controlContent);
      add_location(span1, file10, 64, 2, 1846);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span0, anchor);
      if (chevron_slot_or_fallback) {
        chevron_slot_or_fallback.m(span0, null);
      }
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, span1, anchor);
      if (control_slot) {
        control_slot.m(span1, null);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (chevron_slot) {
        if (chevron_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            chevron_slot,
            chevron_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[17]
            ) : get_slot_changes(
              chevron_slot_template,
              /*$$scope*/
              ctx9[17],
              dirty,
              get_chevron_slot_changes
            ),
            get_chevron_slot_context
          );
        }
      } else {
        if (chevron_slot_or_fallback && chevron_slot_or_fallback.p && (!current || dirty & /*chevron, $ctx*/
        160)) {
          chevron_slot_or_fallback.p(ctx9, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*classes*/
      512 && span0_class_value !== (span0_class_value = /*classes*/
      ctx9[9].chevron)) {
        attr_dev(span0, "class", span0_class_value);
      }
      if (!current || dirty & /*$ctx, value*/
      144 && span0_data_rotate_value !== (span0_data_rotate_value = !/*$ctx*/
      ctx9[7].disableChevronRotation && /*$ctx*/
      ctx9[7].isItemActive(
        /*value*/
        ctx9[4]
      ))) {
        attr_dev(span0, "data-rotate", span0_data_rotate_value);
      }
      if (control_slot) {
        if (control_slot.p && (!current || dirty & /*$$scope, disabled*/
        131136)) {
          update_slot_base(
            control_slot,
            control_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[17]
            ) : get_slot_changes(
              control_slot_template,
              /*$$scope*/
              ctx9[17],
              dirty,
              get_control_slot_changes
            ),
            get_control_slot_context
          );
        }
      }
      if (!current || dirty & /*classes*/
      512 && span1_class_value !== (span1_class_value = /*classes*/
      ctx9[9].controlContent)) {
        attr_dev(span1, "class", span1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chevron_slot_or_fallback, local);
      transition_in(control_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevron_slot_or_fallback, local);
      transition_out(control_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span0);
        detach_dev(t);
        detach_dev(span1);
      }
      if (chevron_slot_or_fallback)
        chevron_slot_or_fallback.d(detaching);
      if (control_slot)
        control_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(47:1) <UnstyledButton   class={classes.control}   bind:element   {disabled}   id={$ctx.getRegionId(value)}   aria-expanded={$ctx.isItemActive(value)}   aria-controls={$ctx.getControlsId(value)}   on:click={onClick}   use={[forwardEvents]}  >",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_1(ctx8) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[17],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*classes*/
      ctx8[9].panel);
      add_location(div, file10, 75, 2, 2141);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[17],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classes*/
      512 && div_class_value !== (div_class_value = /*classes*/
      ctx9[9].panel)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: '(69:1) <Collapse   role=\\"region\\"   id={$ctx.getControlsId(value)}   aria-labelledby={$ctx.getRegionId(value)}   open={$ctx.isItemActive(value)}   transitionDuration={$ctx.transitionDuration}  >',
    ctx: ctx8
  });
  return block;
}
function create_default_slot5(ctx8) {
  let unstyledbutton;
  let updating_element;
  let t;
  let collapse;
  let current;
  function unstyledbutton_element_binding(value) {
    ctx8[16](value);
  }
  let unstyledbutton_props = {
    class: (
      /*classes*/
      ctx8[9].control
    ),
    disabled: (
      /*disabled*/
      ctx8[6]
    ),
    id: (
      /*$ctx*/
      ctx8[7].getRegionId(
        /*value*/
        ctx8[4]
      )
    ),
    "aria-expanded": (
      /*$ctx*/
      ctx8[7].isItemActive(
        /*value*/
        ctx8[4]
      )
    ),
    "aria-controls": (
      /*$ctx*/
      ctx8[7].getControlsId(
        /*value*/
        ctx8[4]
      )
    ),
    use: [
      /*forwardEvents*/
      ctx8[11]
    ],
    $$slots: { default: [create_default_slot_2] },
    $$scope: { ctx: ctx8 }
  };
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    unstyledbutton_props.element = /*element*/
    ctx8[0];
  }
  unstyledbutton = new UnstyledButton_default({
    props: unstyledbutton_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(unstyledbutton, "element", unstyledbutton_element_binding));
  unstyledbutton.$on(
    "click",
    /*onClick*/
    ctx8[13]
  );
  collapse = new Collapse_default({
    props: {
      role: "region",
      id: (
        /*$ctx*/
        ctx8[7].getControlsId(
          /*value*/
          ctx8[4]
        )
      ),
      "aria-labelledby": (
        /*$ctx*/
        ctx8[7].getRegionId(
          /*value*/
          ctx8[4]
        )
      ),
      open: (
        /*$ctx*/
        ctx8[7].isItemActive(
          /*value*/
          ctx8[4]
        )
      ),
      transitionDuration: (
        /*$ctx*/
        ctx8[7].transitionDuration
      ),
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(unstyledbutton.$$.fragment);
      t = space();
      create_component(collapse.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(unstyledbutton.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(collapse.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(unstyledbutton, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(collapse, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const unstyledbutton_changes = {};
      if (dirty & /*classes*/
      512)
        unstyledbutton_changes.class = /*classes*/
        ctx9[9].control;
      if (dirty & /*disabled*/
      64)
        unstyledbutton_changes.disabled = /*disabled*/
        ctx9[6];
      if (dirty & /*$ctx, value*/
      144)
        unstyledbutton_changes.id = /*$ctx*/
        ctx9[7].getRegionId(
          /*value*/
          ctx9[4]
        );
      if (dirty & /*$ctx, value*/
      144)
        unstyledbutton_changes["aria-expanded"] = /*$ctx*/
        ctx9[7].isItemActive(
          /*value*/
          ctx9[4]
        );
      if (dirty & /*$ctx, value*/
      144)
        unstyledbutton_changes["aria-controls"] = /*$ctx*/
        ctx9[7].getControlsId(
          /*value*/
          ctx9[4]
        );
      if (dirty & /*$$scope, classes, disabled, $ctx, value, chevron*/
      131824) {
        unstyledbutton_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        unstyledbutton_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      unstyledbutton.$set(unstyledbutton_changes);
      const collapse_changes = {};
      if (dirty & /*$ctx, value*/
      144)
        collapse_changes.id = /*$ctx*/
        ctx9[7].getControlsId(
          /*value*/
          ctx9[4]
        );
      if (dirty & /*$ctx, value*/
      144)
        collapse_changes["aria-labelledby"] = /*$ctx*/
        ctx9[7].getRegionId(
          /*value*/
          ctx9[4]
        );
      if (dirty & /*$ctx, value*/
      144)
        collapse_changes.open = /*$ctx*/
        ctx9[7].isItemActive(
          /*value*/
          ctx9[4]
        );
      if (dirty & /*$ctx*/
      128)
        collapse_changes.transitionDuration = /*$ctx*/
        ctx9[7].transitionDuration;
      if (dirty & /*$$scope, classes*/
      131584) {
        collapse_changes.$$scope = { dirty, ctx: ctx9 };
      }
      collapse.$set(collapse_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(unstyledbutton.$$.fragment, local);
      transition_in(collapse.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(unstyledbutton.$$.fragment, local);
      transition_out(collapse.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_component(unstyledbutton, detaching);
      destroy_component(collapse, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: "(39:0) <Box  class={cx(className, classes.root, getStyles({ css: override, variation: $ctx.variant }), {   [classes.active]: $ctx.isItemActive(value)  })}  data-active={$ctx.isItemActive(value)}  {use}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment14(ctx8) {
  let box;
  let current;
  const box_spread_levels = [
    {
      class: (
        /*cx*/
        ctx8[10](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[9].root,
          /*getStyles*/
          ctx8[8]({
            css: (
              /*override*/
              ctx8[3]
            ),
            variation: (
              /*$ctx*/
              ctx8[7].variant
            )
          }),
          {
            [
              /*classes*/
              ctx8[9].active
            ]: (
              /*$ctx*/
              ctx8[7].isItemActive(
                /*value*/
                ctx8[4]
              )
            )
          }
        )
      )
    },
    {
      "data-active": (
        /*$ctx*/
        ctx8[7].isItemActive(
          /*value*/
          ctx8[4]
        )
      )
    },
    { use: (
      /*use*/
      ctx8[1]
    ) },
    /*$$restProps*/
    ctx8[14]
  ];
  let box_props = {
    $$slots: { default: [create_default_slot5] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  box = new Box_default({ props: box_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*cx, className, classes, getStyles, override, $ctx, value, use, $$restProps*/
      18334 ? get_spread_update(box_spread_levels, [
        dirty & /*cx, className, classes, getStyles, override, $ctx, value*/
        1948 && {
          class: (
            /*cx*/
            ctx9[10](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[9].root,
              /*getStyles*/
              ctx9[8]({
                css: (
                  /*override*/
                  ctx9[3]
                ),
                variation: (
                  /*$ctx*/
                  ctx9[7].variant
                )
              }),
              {
                [
                  /*classes*/
                  ctx9[9].active
                ]: (
                  /*$ctx*/
                  ctx9[7].isItemActive(
                    /*value*/
                    ctx9[4]
                  )
                )
              }
            )
          )
        },
        dirty & /*$ctx, value*/
        144 && {
          "data-active": (
            /*$ctx*/
            ctx9[7].isItemActive(
              /*value*/
              ctx9[4]
            )
          )
        },
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*$$restProps*/
        16384 && get_spread_object(
          /*$$restProps*/
          ctx9[14]
        )
      ]) : {};
      if (dirty & /*$$scope, $ctx, value, classes, disabled, element, chevron*/
      131825) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = ["use", "element", "class", "override", "value", "chevron", "disabled"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $ctx;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AccordionItem", slots, ["chevron", "control", "default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, value = void 0, chevron = void 0, disabled = false } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  const ctx8 = getContext(key2);
  validate_store(ctx8, "ctx");
  component_subscribe($$self, ctx8, (value2) => $$invalidate(7, $ctx = value2));
  function onClick() {
    $ctx.updateActive(value);
  }
  function unstyledbutton_element_binding(value2) {
    element2 = value2;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(14, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("value" in $$new_props)
      $$invalidate(4, value = $$new_props.value);
    if ("chevron" in $$new_props)
      $$invalidate(5, chevron = $$new_props.chevron);
    if ("disabled" in $$new_props)
      $$invalidate(6, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props)
      $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    get_current_component,
    createEventForwarder,
    Box: Box_default,
    UnstyledButton: UnstyledButton_default,
    Collapse: Collapse_default,
    key: key2,
    useStyles: AccordionItem_styles_default,
    use,
    element: element2,
    className,
    override,
    value,
    chevron,
    disabled,
    forwardEvents,
    ctx: ctx8,
    onClick,
    getStyles,
    classes,
    cx: cx2,
    $ctx
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("value" in $$props)
      $$invalidate(4, value = $$new_props.value);
    if ("chevron" in $$props)
      $$invalidate(5, chevron = $$new_props.chevron);
    if ("disabled" in $$props)
      $$invalidate(6, disabled = $$new_props.disabled);
    if ("getStyles" in $$props)
      $$invalidate(8, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(9, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(10, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$ctx*/
    128) {
      $:
        $$invalidate(
          10,
          { cx: cx2, classes, getStyles } = AccordionItem_styles_default(
            {
              radius: $ctx.radius,
              transitionDuration: $ctx.transitionDuration,
              chevronPosition: $ctx.chevronPosition,
              chevronSize: $ctx.chevronSize
            },
            { name: "AccordionItem" }
          ),
          cx2,
          ($$invalidate(9, classes), $$invalidate(7, $ctx)),
          ($$invalidate(8, getStyles), $$invalidate(7, $ctx))
        );
    }
  };
  return [
    element2,
    use,
    className,
    override,
    value,
    chevron,
    disabled,
    $ctx,
    getStyles,
    classes,
    cx2,
    forwardEvents,
    ctx8,
    onClick,
    $$restProps,
    slots,
    unstyledbutton_element_binding,
    $$scope
  ];
}
var AccordionItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      value: 4,
      chevron: 5,
      disabled: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AccordionItem",
      options,
      id: create_fragment14.name
    });
  }
  get use() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chevron() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chevron(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AccordionItem_default = AccordionItem;

// node_modules/@svelteuidev/core/dist/components/Accordion/combinator.js
Accordion_default.Item = AccordionItem_default;
var Accordion2 = Accordion_default;

// node_modules/@svelteuidev/core/dist/components/ActionIcon/ActionIcon.styles.js
var sizes2 = {
  xs: 18,
  sm: 22,
  md: 28,
  lg: 34,
  xl: 44
};
function getVariantStyles(color) {
  const { themeColor: themeColor2 } = fns;
  const variants = vFunc(color);
  return {
    ...variants,
    hover: {
      [`${dark.selector} &`]: {
        color: themeColor2(color, 2),
        "&:hover": { backgroundColor: themeColor2("dark", 8) }
      },
      border: "1px solid transparent",
      backgroundColor: "transparent",
      color: themeColor2(color, 7),
      "&:hover": { backgroundColor: themeColor2(color) }
    },
    transparent: {
      [`${dark.selector} &`]: {
        color: themeColor2(color, 8),
        "&:hover": { backgroundColor: null }
      },
      border: "1px solid transparent",
      backgroundColor: "transparent",
      color: themeColor2(color, 7),
      "&:hover": { backgroundColor: null }
    }
  };
}
var ActionIcon_styles_default = createStyles((theme4, { color, radius: radius2, size: size3 }) => {
  return {
    root: {
      focusRing: "auto",
      position: "relative",
      appearance: "none",
      WebkitAppearance: "none",
      WebkitTapHighlightColor: "transparent",
      boxSizing: "border-box",
      height: typeof size3 === "string" ? sizes2[size3] : `${size3}px`,
      minHeight: typeof size3 === "string" ? sizes2[size3] : `${size3}px`,
      width: typeof size3 === "string" ? sizes2[size3] : `${size3}px`,
      minWidth: typeof size3 === "string" ? sizes2[size3] : `${size3}px`,
      borderRadius: `$${radius2}`,
      padding: 0,
      lineHeight: 1,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      cursor: "pointer",
      textDecoration: "none",
      "&:not(:disabled):active": {
        transform: "translateY(1px)"
      },
      "&:disabled": {
        pointerEvents: "none",
        borderColor: "transparent",
        background: theme4.fn.themeColor("gray", 2),
        backgroundColor: theme4.fn.themeColor("gray", 2),
        color: theme4.fn.themeColor("gray", 5),
        cursor: "not-allowed",
        darkMode: {
          borderColor: "transparent",
          backgroundColor: theme4.fn.themeColor("dark", 4),
          color: theme4.fn.themeColor("dark", 6)
        }
      }
    },
    loading: {
      pointerEvents: "none",
      "&::before": {
        content: '""',
        position: "absolute",
        top: -1,
        left: -1,
        right: -1,
        bottom: -1,
        backgroundColor: "rgba(255, 255, 255, .5)",
        borderRadius: `$${radius2}`,
        cursor: "not-allowed"
      }
    },
    variants: {
      variation: getVariantStyles(color)
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/ActionIcon/ActionIcon.errors.js
var ActionIcon_errors_exports = {};
__export(ActionIcon_errors_exports, {
  ActionIconErrors: () => ActionIconErrors
});
var ActionIconErrors = Object.freeze([
  {
    error: true,
    message: "If using the 'href' prop, set 'root' prop to an anchor ('a') tag",
    solution: `
                If your component looks like this:

                &lt;ActionIcon href='https://example.com'&gt;
                          ^^^ - Try adding prop root='a'
                       &lt;Icon /&gt;
                &lt;/ActionIcon&gt;
                `
  }
]);

// node_modules/@svelteuidev/core/dist/components/ActionIcon/ActionIcon.svelte
var { Error: Error_13 } = globals;
function create_else_block4(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[23],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block3(ctx8);
  const block = {
    c: function create() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8388608)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[23]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[23],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(63:1) {:else}",
    ctx: ctx8
  });
  return block;
}
function create_if_block5(ctx8) {
  let loader;
  let current;
  loader = new Loader_default({
    props: {
      size: (
        /*loaderProps*/
        ctx8[6].size
      ),
      color: (
        /*loaderProps*/
        ctx8[6].color
      ),
      variant: (
        /*loaderProps*/
        ctx8[6].variant
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(loader.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(loader.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const loader_changes = {};
      if (dirty & /*loaderProps*/
      64)
        loader_changes.size = /*loaderProps*/
        ctx9[6].size;
      if (dirty & /*loaderProps*/
      64)
        loader_changes.color = /*loaderProps*/
        ctx9[6].color;
      if (dirty & /*loaderProps*/
      64)
        loader_changes.variant = /*loaderProps*/
        ctx9[6].variant;
      loader.$set(loader_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(loader, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(61:1) {#if loading}",
    ctx: ctx8
  });
  return block;
}
function fallback_block3(ctx8) {
  let t;
  const block = {
    c: function create() {
      t = text("+");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "+");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block3.name,
    type: "fallback",
    source: "(64:8) +",
    ctx: ctx8
  });
  return block;
}
function create_default_slot6(ctx8) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block5, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx9, dirty) {
    if (
      /*loading*/
      ctx9[7]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx8, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx8);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx9, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx9, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx9);
          if_block.c();
        } else {
          if_block.p(ctx9, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: "(44:0) <Box  bind:element  use={[forwardEvents, [useActions, use]]}  tabindex={0}  disabled={disabled || loading}  class={cx(   className,   classes.root,   { [classes.loading]: loading },   getStyles({ css: override, variation: variant })  )}  target={external ? '_blank' : null}  rel={external ? 'noreferrer noopener' : null}  {root}  {href}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment15(ctx8) {
  let error;
  let t;
  let box;
  let updating_element;
  let current;
  error = new Error_default({
    props: {
      observable: (
        /*observable*/
        ctx8[11]
      ),
      component: "ActionIcon",
      code: (
        /*err*/
        ctx8[12]
      )
    },
    $$inline: true
  });
  const box_spread_levels = [
    {
      use: [
        /*forwardEvents*/
        ctx8[16],
        [
          useActions,
          /*use*/
          ctx8[2]
        ]
      ]
    },
    { tabindex: 0 },
    {
      disabled: (
        /*disabled*/
        ctx8[8] || /*loading*/
        ctx8[7]
      )
    },
    {
      class: (
        /*cx*/
        ctx8[15](
          /*className*/
          ctx8[3],
          /*classes*/
          ctx8[14].root,
          {
            [
              /*classes*/
              ctx8[14].loading
            ]: (
              /*loading*/
              ctx8[7]
            )
          },
          /*getStyles*/
          ctx8[13]({
            css: (
              /*override*/
              ctx8[1]
            ),
            variation: (
              /*variant*/
              ctx8[5]
            )
          })
        )
      )
    },
    {
      target: (
        /*external*/
        ctx8[10] ? "_blank" : null
      )
    },
    {
      rel: (
        /*external*/
        ctx8[10] ? "noreferrer noopener" : null
      )
    },
    { root: (
      /*root*/
      ctx8[4]
    ) },
    { href: (
      /*href*/
      ctx8[9]
    ) },
    /*$$restProps*/
    ctx8[17]
  ];
  function box_element_binding(value) {
    ctx8[22](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot6] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(error.$$.fragment);
      t = space();
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(error.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(error, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const error_changes = {};
      if (dirty & /*observable*/
      2048)
        error_changes.observable = /*observable*/
        ctx9[11];
      if (dirty & /*err*/
      4096)
        error_changes.code = /*err*/
        ctx9[12];
      error.$set(error_changes);
      const box_changes = dirty & /*forwardEvents, use, disabled, loading, cx, className, classes, getStyles, override, variant, external, root, href, $$restProps*/
      255934 ? get_spread_update(box_spread_levels, [
        dirty & /*forwardEvents, use*/
        65540 && {
          use: [
            /*forwardEvents*/
            ctx9[16],
            [
              useActions,
              /*use*/
              ctx9[2]
            ]
          ]
        },
        box_spread_levels[1],
        dirty & /*disabled, loading*/
        384 && {
          disabled: (
            /*disabled*/
            ctx9[8] || /*loading*/
            ctx9[7]
          )
        },
        dirty & /*cx, className, classes, loading, getStyles, override, variant*/
        57514 && {
          class: (
            /*cx*/
            ctx9[15](
              /*className*/
              ctx9[3],
              /*classes*/
              ctx9[14].root,
              {
                [
                  /*classes*/
                  ctx9[14].loading
                ]: (
                  /*loading*/
                  ctx9[7]
                )
              },
              /*getStyles*/
              ctx9[13]({
                css: (
                  /*override*/
                  ctx9[1]
                ),
                variation: (
                  /*variant*/
                  ctx9[5]
                )
              })
            )
          )
        },
        dirty & /*external*/
        1024 && {
          target: (
            /*external*/
            ctx9[10] ? "_blank" : null
          )
        },
        dirty & /*external*/
        1024 && {
          rel: (
            /*external*/
            ctx9[10] ? "noreferrer noopener" : null
          )
        },
        dirty & /*root*/
        16 && { root: (
          /*root*/
          ctx9[4]
        ) },
        dirty & /*href*/
        512 && { href: (
          /*href*/
          ctx9[9]
        ) },
        dirty & /*$$restProps*/
        131072 && get_spread_object(
          /*$$restProps*/
          ctx9[17]
        )
      ]) : {};
      if (dirty & /*$$scope, loaderProps, loading*/
      8388800) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(error.$$.fragment, local);
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(error.$$.fragment, local);
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_component(error, detaching);
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "root",
    "color",
    "variant",
    "size",
    "radius",
    "loaderProps",
    "loading",
    "disabled",
    "href",
    "external"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ActionIcon", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, root = "button", color = "gray", variant: variant2 = "hover", size: size3 = "md", radius: radius2 = "sm", loaderProps = {
    size: "xs",
    color: "gray",
    variant: "circle"
  }, loading = false, disabled = false, href = "", external = false } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  let observable = false;
  let err;
  if (root !== "a" && $$props.href) {
    observable = true;
    err = ActionIconErrors[0];
  }
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(24, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(17, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(1, override = $$new_props.override);
    if ("root" in $$new_props)
      $$invalidate(4, root = $$new_props.root);
    if ("color" in $$new_props)
      $$invalidate(18, color = $$new_props.color);
    if ("variant" in $$new_props)
      $$invalidate(5, variant2 = $$new_props.variant);
    if ("size" in $$new_props)
      $$invalidate(19, size3 = $$new_props.size);
    if ("radius" in $$new_props)
      $$invalidate(20, radius2 = $$new_props.radius);
    if ("loaderProps" in $$new_props)
      $$invalidate(6, loaderProps = $$new_props.loaderProps);
    if ("loading" in $$new_props)
      $$invalidate(7, loading = $$new_props.loading);
    if ("disabled" in $$new_props)
      $$invalidate(8, disabled = $$new_props.disabled);
    if ("href" in $$new_props)
      $$invalidate(9, href = $$new_props.href);
    if ("external" in $$new_props)
      $$invalidate(10, external = $$new_props.external);
    if ("$$scope" in $$new_props)
      $$invalidate(23, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: ActionIcon_styles_default,
    ActionIconErrors,
    createEventForwarder,
    useActions,
    get_current_component,
    Box: Box_default,
    Loader: Loader_default,
    Error: Error_default,
    use,
    element: element2,
    className,
    override,
    root,
    color,
    variant: variant2,
    size: size3,
    radius: radius2,
    loaderProps,
    loading,
    disabled,
    href,
    external,
    forwardEvents,
    observable,
    err,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(24, $$props = assign(assign({}, $$props), $$new_props));
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(1, override = $$new_props.override);
    if ("root" in $$props)
      $$invalidate(4, root = $$new_props.root);
    if ("color" in $$props)
      $$invalidate(18, color = $$new_props.color);
    if ("variant" in $$props)
      $$invalidate(5, variant2 = $$new_props.variant);
    if ("size" in $$props)
      $$invalidate(19, size3 = $$new_props.size);
    if ("radius" in $$props)
      $$invalidate(20, radius2 = $$new_props.radius);
    if ("loaderProps" in $$props)
      $$invalidate(6, loaderProps = $$new_props.loaderProps);
    if ("loading" in $$props)
      $$invalidate(7, loading = $$new_props.loading);
    if ("disabled" in $$props)
      $$invalidate(8, disabled = $$new_props.disabled);
    if ("href" in $$props)
      $$invalidate(9, href = $$new_props.href);
    if ("external" in $$props)
      $$invalidate(10, external = $$new_props.external);
    if ("observable" in $$props)
      $$invalidate(11, observable = $$new_props.observable);
    if ("err" in $$props)
      $$invalidate(12, err = $$new_props.err);
    if ("getStyles" in $$props)
      $$invalidate(13, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(14, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(15, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*observable*/
    2048) {
      $:
        if (observable)
          $$invalidate(1, override = { display: "none" });
    }
    if ($$self.$$.dirty & /*color, radius, size*/
    1835008) {
      $:
        $$invalidate(15, { cx: cx2, classes, getStyles } = ActionIcon_styles_default({ color, radius: radius2, size: size3 }, { name: "ActionIcon" }), cx2, ($$invalidate(14, classes), $$invalidate(18, color), $$invalidate(20, radius2), $$invalidate(19, size3)), ($$invalidate(13, getStyles), $$invalidate(18, color), $$invalidate(20, radius2), $$invalidate(19, size3)));
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    element2,
    override,
    use,
    className,
    root,
    variant2,
    loaderProps,
    loading,
    disabled,
    href,
    external,
    observable,
    err,
    getStyles,
    classes,
    cx2,
    forwardEvents,
    $$restProps,
    color,
    size3,
    radius2,
    slots,
    box_element_binding,
    $$scope
  ];
}
var ActionIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, {
      use: 2,
      element: 0,
      class: 3,
      override: 1,
      root: 4,
      color: 18,
      variant: 5,
      size: 19,
      radius: 20,
      loaderProps: 6,
      loading: 7,
      disabled: 8,
      href: 9,
      external: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ActionIcon",
      options,
      id: create_fragment15.name
    });
  }
  get use() {
    throw new Error_13("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error_13("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error_13("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error_13("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error_13("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error_13("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error_13("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error_13("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get root() {
    throw new Error_13("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set root(value) {
    throw new Error_13("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error_13("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error_13("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error_13("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error_13("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error_13("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error_13("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error_13("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error_13("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loaderProps() {
    throw new Error_13("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loaderProps(value) {
    throw new Error_13("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loading() {
    throw new Error_13("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loading(value) {
    throw new Error_13("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error_13("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error_13("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error_13("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error_13("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get external() {
    throw new Error_13("<ActionIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set external(value) {
    throw new Error_13("<ActionIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ActionIcon_default = ActionIcon;

// node_modules/@svelteuidev/core/dist/components/ActionIcon/CloseButton/CloseIcon.svelte
var file11 = "node_modules/@svelteuidev/core/dist/components/ActionIcon/CloseButton/CloseIcon.svelte";
function create_fragment16(ctx8) {
  let svg;
  let path;
  let svg_levels = [
    { width: (
      /*width*/
      ctx8[0]
    ) },
    { height: (
      /*height*/
      ctx8[1]
    ) },
    { viewBox: "0 0 15 15" },
    { fill: "none" },
    { xmlns: "http://www.w3.org/2000/svg" },
    /*$$restProps*/
    ctx8[2]
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign(svg_data, svg_levels[i2]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        fill: true,
        xmlns: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", {
        d: true,
        fill: true,
        "fill-rule": true,
        "clip-rule": true
      });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z");
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "clip-rule", "evenodd");
      add_location(path, file11, 12, 1, 181);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file11, 4, 0, 66);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx9, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        dirty & /*width*/
        1 && { width: (
          /*width*/
          ctx9[0]
        ) },
        dirty & /*height*/
        2 && { height: (
          /*height*/
          ctx9[1]
        ) },
        { viewBox: "0 0 15 15" },
        { fill: "none" },
        { xmlns: "http://www.w3.org/2000/svg" },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx9[2]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  const omit_props_names = ["width", "height"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CloseIcon", slots, []);
  let { width = 16 } = $$props;
  let { height = 16 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("width" in $$new_props)
      $$invalidate(0, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(1, height = $$new_props.height);
  };
  $$self.$capture_state = () => ({ width, height });
  $$self.$inject_state = ($$new_props) => {
    if ("width" in $$props)
      $$invalidate(0, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(1, height = $$new_props.height);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [width, height, $$restProps];
}
var CloseIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, { width: 0, height: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CloseIcon",
      options,
      id: create_fragment16.name
    });
  }
  get width() {
    throw new Error("<CloseIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<CloseIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<CloseIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<CloseIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CloseIcon_default = CloseIcon;

// node_modules/@svelteuidev/core/dist/components/ActionIcon/CloseButton/CloseButton.svelte
function create_default_slot7(ctx8) {
  let closeicon;
  let current;
  closeicon = new CloseIcon_default({
    props: {
      width: (
        /*iconSizes*/
        ctx8[16][
          /*iconSize*/
          ctx8[4]
        ]
      ),
      height: (
        /*iconSizes*/
        ctx8[16][
          /*iconSize*/
          ctx8[4]
        ]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(closeicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(closeicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(closeicon, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const closeicon_changes = {};
      if (dirty & /*iconSize*/
      16)
        closeicon_changes.width = /*iconSizes*/
        ctx9[16][
          /*iconSize*/
          ctx9[4]
        ];
      if (dirty & /*iconSize*/
      16)
        closeicon_changes.height = /*iconSizes*/
        ctx9[16][
          /*iconSize*/
          ctx9[4]
        ];
      closeicon.$set(closeicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(closeicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(closeicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(closeicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot7.name,
    type: "slot",
    source: "(34:0) <ActionIcon  bind:element  class={className}  use={[forwardEvents, [useActions, use]]}  {override}  {root}  {color}  {variant}  {size}  {radius}  {loaderProps}  {loading}  {disabled}  {href}  {external}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment17(ctx8) {
  let actionicon;
  let updating_element;
  let current;
  const actionicon_spread_levels = [
    { class: (
      /*className*/
      ctx8[2]
    ) },
    {
      use: [
        /*forwardEvents*/
        ctx8[15],
        [
          useActions,
          /*use*/
          ctx8[1]
        ]
      ]
    },
    { override: (
      /*override*/
      ctx8[3]
    ) },
    { root: (
      /*root*/
      ctx8[5]
    ) },
    { color: (
      /*color*/
      ctx8[6]
    ) },
    { variant: (
      /*variant*/
      ctx8[7]
    ) },
    { size: (
      /*size*/
      ctx8[8]
    ) },
    { radius: (
      /*radius*/
      ctx8[9]
    ) },
    { loaderProps: (
      /*loaderProps*/
      ctx8[10]
    ) },
    { loading: (
      /*loading*/
      ctx8[11]
    ) },
    { disabled: (
      /*disabled*/
      ctx8[12]
    ) },
    { href: (
      /*href*/
      ctx8[13]
    ) },
    { external: (
      /*external*/
      ctx8[14]
    ) },
    /*$$restProps*/
    ctx8[17]
  ];
  function actionicon_element_binding(value) {
    ctx8[18](value);
  }
  let actionicon_props = {
    $$slots: { default: [create_default_slot7] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < actionicon_spread_levels.length; i2 += 1) {
    actionicon_props = assign(actionicon_props, actionicon_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    actionicon_props.element = /*element*/
    ctx8[0];
  }
  actionicon = new ActionIcon_default({ props: actionicon_props, $$inline: true });
  binding_callbacks.push(() => bind(actionicon, "element", actionicon_element_binding));
  const block = {
    c: function create() {
      create_component(actionicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(actionicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(actionicon, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const actionicon_changes = dirty & /*className, forwardEvents, use, override, root, color, variant, size, radius, loaderProps, loading, disabled, href, external, $$restProps*/
      196590 ? get_spread_update(actionicon_spread_levels, [
        dirty & /*className*/
        4 && { class: (
          /*className*/
          ctx9[2]
        ) },
        dirty & /*forwardEvents, use*/
        32770 && {
          use: [
            /*forwardEvents*/
            ctx9[15],
            [
              useActions,
              /*use*/
              ctx9[1]
            ]
          ]
        },
        dirty & /*override*/
        8 && { override: (
          /*override*/
          ctx9[3]
        ) },
        dirty & /*root*/
        32 && { root: (
          /*root*/
          ctx9[5]
        ) },
        dirty & /*color*/
        64 && { color: (
          /*color*/
          ctx9[6]
        ) },
        dirty & /*variant*/
        128 && { variant: (
          /*variant*/
          ctx9[7]
        ) },
        dirty & /*size*/
        256 && { size: (
          /*size*/
          ctx9[8]
        ) },
        dirty & /*radius*/
        512 && { radius: (
          /*radius*/
          ctx9[9]
        ) },
        dirty & /*loaderProps*/
        1024 && { loaderProps: (
          /*loaderProps*/
          ctx9[10]
        ) },
        dirty & /*loading*/
        2048 && { loading: (
          /*loading*/
          ctx9[11]
        ) },
        dirty & /*disabled*/
        4096 && { disabled: (
          /*disabled*/
          ctx9[12]
        ) },
        dirty & /*href*/
        8192 && { href: (
          /*href*/
          ctx9[13]
        ) },
        dirty & /*external*/
        16384 && { external: (
          /*external*/
          ctx9[14]
        ) },
        dirty & /*$$restProps*/
        131072 && get_spread_object(
          /*$$restProps*/
          ctx9[17]
        )
      ]) : {};
      if (dirty & /*$$scope, iconSize*/
      524304) {
        actionicon_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        actionicon_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      actionicon.$set(actionicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(actionicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(actionicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(actionicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "iconSize",
    "root",
    "color",
    "variant",
    "size",
    "radius",
    "loaderProps",
    "loading",
    "disabled",
    "href",
    "external"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CloseButton", slots, []);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, iconSize = "md", root = "button", color = "gray", variant: variant2 = "hover", size: size3 = "md", radius: radius2 = "sm", loaderProps = {
    size: "xs",
    color: "gray",
    variant: "circle"
  }, loading = false, disabled = false, href = "", external = false } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  const iconSizes3 = { xs: 12, sm: 14, md: 16, lg: 20, xl: 24 };
  function actionicon_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(17, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("iconSize" in $$new_props)
      $$invalidate(4, iconSize = $$new_props.iconSize);
    if ("root" in $$new_props)
      $$invalidate(5, root = $$new_props.root);
    if ("color" in $$new_props)
      $$invalidate(6, color = $$new_props.color);
    if ("variant" in $$new_props)
      $$invalidate(7, variant2 = $$new_props.variant);
    if ("size" in $$new_props)
      $$invalidate(8, size3 = $$new_props.size);
    if ("radius" in $$new_props)
      $$invalidate(9, radius2 = $$new_props.radius);
    if ("loaderProps" in $$new_props)
      $$invalidate(10, loaderProps = $$new_props.loaderProps);
    if ("loading" in $$new_props)
      $$invalidate(11, loading = $$new_props.loading);
    if ("disabled" in $$new_props)
      $$invalidate(12, disabled = $$new_props.disabled);
    if ("href" in $$new_props)
      $$invalidate(13, href = $$new_props.href);
    if ("external" in $$new_props)
      $$invalidate(14, external = $$new_props.external);
  };
  $$self.$capture_state = () => ({
    ActionIcon: ActionIcon_default,
    CloseIcon: CloseIcon_default,
    createEventForwarder,
    useActions,
    get_current_component,
    use,
    element: element2,
    className,
    override,
    iconSize,
    root,
    color,
    variant: variant2,
    size: size3,
    radius: radius2,
    loaderProps,
    loading,
    disabled,
    href,
    external,
    forwardEvents,
    iconSizes: iconSizes3
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("iconSize" in $$props)
      $$invalidate(4, iconSize = $$new_props.iconSize);
    if ("root" in $$props)
      $$invalidate(5, root = $$new_props.root);
    if ("color" in $$props)
      $$invalidate(6, color = $$new_props.color);
    if ("variant" in $$props)
      $$invalidate(7, variant2 = $$new_props.variant);
    if ("size" in $$props)
      $$invalidate(8, size3 = $$new_props.size);
    if ("radius" in $$props)
      $$invalidate(9, radius2 = $$new_props.radius);
    if ("loaderProps" in $$props)
      $$invalidate(10, loaderProps = $$new_props.loaderProps);
    if ("loading" in $$props)
      $$invalidate(11, loading = $$new_props.loading);
    if ("disabled" in $$props)
      $$invalidate(12, disabled = $$new_props.disabled);
    if ("href" in $$props)
      $$invalidate(13, href = $$new_props.href);
    if ("external" in $$props)
      $$invalidate(14, external = $$new_props.external);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    use,
    className,
    override,
    iconSize,
    root,
    color,
    variant2,
    size3,
    radius2,
    loaderProps,
    loading,
    disabled,
    href,
    external,
    forwardEvents,
    iconSizes3,
    $$restProps,
    actionicon_element_binding
  ];
}
var CloseButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      iconSize: 4,
      root: 5,
      color: 6,
      variant: 7,
      size: 8,
      radius: 9,
      loaderProps: 10,
      loading: 11,
      disabled: 12,
      href: 13,
      external: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CloseButton",
      options,
      id: create_fragment17.name
    });
  }
  get use() {
    throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconSize() {
    throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconSize(value) {
    throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get root() {
    throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set root(value) {
    throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loaderProps() {
    throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loaderProps(value) {
    throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loading() {
    throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loading(value) {
    throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get external() {
    throw new Error("<CloseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set external(value) {
    throw new Error("<CloseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CloseButton_default = CloseButton;

// node_modules/@svelteuidev/composables/dist/actions/use-click-outside/use-click-outside.js
function clickoutside(node, params) {
  const { enabled: initialEnabled, callback } = params;
  const handleOutsideClick = ({ target }) => {
    if (!node.contains(target))
      callback(node);
  };
  function update({ enabled }) {
    if (enabled) {
      window.addEventListener("click", handleOutsideClick);
    } else {
      window.removeEventListener("click", handleOutsideClick);
    }
  }
  update({ enabled: initialEnabled });
  return {
    update,
    destroy() {
      window.removeEventListener("click", handleOutsideClick);
    }
  };
}

// node_modules/@svelteuidev/composables/dist/actions/use-focus-trap/tabbable.js
var TABBABLE_NODES = /input|select|textarea|button|object/;
var FOCUS_SELECTOR = "a, input, select, textarea, button, object, [tabindex]";
function hidden(element2) {
  if (false) {
    return false;
  }
  return element2.style.display === "none";
}
function visible(element2) {
  const isHidden = element2.getAttribute("aria-hidden") || element2.getAttribute("hidden") || element2.getAttribute("type") === "hidden";
  if (isHidden) {
    return false;
  }
  let parentElement = element2;
  while (parentElement) {
    if (parentElement === document.body || parentElement.nodeType === 11) {
      break;
    }
    if (hidden(parentElement)) {
      return false;
    }
    parentElement = parentElement.parentNode;
  }
  return true;
}
function getElementTabIndex(element2) {
  const tabIndex = element2.getAttribute("tabindex");
  return tabIndex ? parseInt(tabIndex, 10) : null;
}
function focusable(element2) {
  const nodeName = element2.nodeName.toLowerCase();
  const isTabIndexNotNull = getElementTabIndex(element2) !== null;
  const res = (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    TABBABLE_NODES.test(nodeName) && !element2.disabled || (element2 instanceof HTMLAnchorElement ? element2.href || isTabIndexNotNull : isTabIndexNotNull)
  );
  return res && visible(element2);
}
function tabbable(element2) {
  const tabIndex = getElementTabIndex(element2);
  const isTabIndexNull = tabIndex === null;
  return (isTabIndexNull || tabIndex >= 0) && focusable(element2);
}
function findTabbableDescendants(element2) {
  return Array.from(element2.querySelectorAll(FOCUS_SELECTOR)).filter(tabbable);
}

// node_modules/@svelteuidev/composables/dist/actions/use-focus-trap/scope-tab.js
function scopeTab(node, event) {
  const tabbable2 = findTabbableDescendants(node);
  if (!tabbable2.length) {
    event.preventDefault();
    return;
  }
  const finalTabbable = tabbable2[event.shiftKey ? 0 : tabbable2.length - 1];
  const root = node.getRootNode();
  const leavingFinalTabbable = finalTabbable === root.activeElement || node === root.activeElement;
  if (!leavingFinalTabbable) {
    return;
  }
  event.preventDefault();
  const target = tabbable2[event.shiftKey ? tabbable2.length - 1 : 0];
  if (target) {
    target.focus();
  }
}

// node_modules/@svelteuidev/composables/dist/actions/use-focus-trap/create-aria-hider.js
function createAriaHider(containerNode) {
  const hiddenDomNodes = [];
  gatherOutsideDomNodes(containerNode);
  hiddenDomNodes.map(({ node }) => {
    node.setAttribute("aria-hidden", "true");
  });
  function gatherOutsideDomNodes(currentElement) {
    if (!currentElement) {
      return void 0;
    }
    if (currentElement !== document.querySelector("body")) {
      const parentElement = currentElement.parentElement;
      const siblingElements = [...Array.from(parentElement.children)];
      siblingElements.forEach((node) => {
        const ariaHidden = node.getAttribute("aria-hidden");
        if (node !== currentElement && node.nodeName !== "SCRIPT" && (ariaHidden === null || ariaHidden === "false")) {
          hiddenDomNodes.push({ node, ariaHidden });
        }
      });
      gatherOutsideDomNodes(parentElement);
    }
  }
  return () => {
    hiddenDomNodes.forEach((item) => {
      if (!item) {
        return;
      }
      if (item.ariaHidden === null) {
        item.node.removeAttribute("aria-hidden");
      } else {
        item.node.setAttribute("aria-hidden", item.ariaHidden);
      }
    });
  };
}

// node_modules/@svelteuidev/composables/dist/actions/use-focus-trap/use-focus-trap.js
function focustrap(node, active = true) {
  let restoreAria = null;
  const handleKeyDown = (event) => {
    if (!active) {
      return;
    }
    if (event.key === "Tab" && node) {
      scopeTab(node, event);
    }
  };
  document.addEventListener("keydown", handleKeyDown);
  activate();
  function activate() {
    if (!active) {
      if (restoreAria) {
        restoreAria();
      }
      return;
    }
    restoreAria = createAriaHider(node);
    const processNode = () => {
      let focusElement = node.querySelector("[autofocus]");
      if (!focusElement) {
        const children2 = Array.from(node.querySelectorAll(FOCUS_SELECTOR));
        focusElement = children2.find(tabbable) || children2.find(focusable) || null;
        if (!focusElement && focusable(node))
          focusElement = node;
      }
      if (focusElement) {
        focusElement.focus({ preventScroll: true });
      } else if (true) {
        console.warn("[@svelteuidev/composables/use-focus-trap] Failed to find focusable element within provided node", node);
      }
    };
    setTimeout(() => {
      if (node.getRootNode()) {
        processNode();
      } else if (true) {
        console.warn("[@svelteuidev/composables/use-focus-trap] node is not part of the dom", node);
      }
    });
  }
  return {
    update(newActive) {
      active = newActive;
      activate();
    },
    destroy() {
      document.removeEventListener("keydown", handleKeyDown);
      if (restoreAria) {
        restoreAria();
      }
    }
  };
}

// node_modules/@svelteuidev/composables/dist/actions/use-io/use-io.js
var createEvent = (name, detail) => new CustomEvent(name, { detail });
var defaultOptions = {
  root: null,
  rootMargin: "0px",
  threshold: 0,
  unobserveOnEnter: false
};
function io(node, options = {}) {
  const { root, rootMargin, threshold, unobserveOnEnter } = { ...defaultOptions, ...options };
  let prevPosition = {
    x: void 0,
    y: void 0
  };
  const scrollDirection = {
    vertical: void 0,
    horizontal: void 0
  };
  if (typeof IntersectionObserver !== "undefined" && node) {
    const observer = new IntersectionObserver((entries, _observer) => {
      entries.forEach((singleEntry) => {
        if (prevPosition.y > singleEntry.boundingClientRect.y) {
          scrollDirection.vertical = "up";
        } else {
          scrollDirection.vertical = "down";
        }
        if (prevPosition.x > singleEntry.boundingClientRect.x) {
          scrollDirection.horizontal = "left";
        } else {
          scrollDirection.horizontal = "right";
        }
        prevPosition = {
          y: singleEntry.boundingClientRect.y,
          x: singleEntry.boundingClientRect.x
        };
        const detail = {
          inView: singleEntry.isIntersecting,
          entry: singleEntry,
          scrollDirection,
          node,
          observer: _observer
        };
        node.dispatchEvent(createEvent("change", detail));
        if (singleEntry.isIntersecting) {
          node.dispatchEvent(createEvent("enter", detail));
          unobserveOnEnter && _observer.unobserve(node);
        } else {
          node.dispatchEvent(createEvent("leave", detail));
        }
      });
    }, {
      root,
      rootMargin,
      threshold
    });
    setTimeout(() => {
      node.dispatchEvent(createEvent("init", { observer, node }));
    }, 0);
    observer.observe(node);
    return {
      destroy: () => {
        observer.unobserve(node);
      }
    };
  }
}

// node_modules/@svelteuidev/composables/dist/actions/use-io/use-io.config.js
var use_io_config_exports = {};

// node_modules/@svelteuidev/composables/dist/actions/use-lock-scroll/utils/create-style-tag.js
function createStyleTag() {
  const tag = document.createElement("style");
  tag.type = "text/css";
  tag.setAttribute("svelteui-scroll-lock", "");
  return tag;
}

// node_modules/@svelteuidev/composables/dist/actions/use-lock-scroll/utils/get-scroll-width.js
function getScrollWidth() {
  if (typeof window === "undefined" || typeof document === "undefined")
    return 0;
  const paddingRight = parseInt(window.getComputedStyle(document.body).paddingRight, 10);
  const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
  return paddingRight + scrollbarWidth;
}

// node_modules/@svelteuidev/composables/dist/actions/use-lock-scroll/utils/get-lock-styles.js
var getLockStyles = ({ disableBodyPadding }) => {
  const scrollWidth = disableBodyPadding ? null : getScrollWidth();
  const styles = `body {
        --removed-scroll-width: ${scrollWidth}px;
        touch-action: none;
        overflow: hidden !important;
        position: relative !important;
        ${scrollWidth ? "padding-right: var(--removed-scroll-width) !important;" : ""}
        `;
  return styles;
};

// node_modules/@svelteuidev/composables/dist/actions/use-lock-scroll/utils/inject-style-tag.js
function injectStyles(tag, css2) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css2;
  } else {
    tag.appendChild(document.createTextNode(css2));
  }
}

// node_modules/@svelteuidev/composables/dist/actions/use-lock-scroll/utils/insert-style-tag.js
function insertStyleTag(tag) {
  const head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}

// node_modules/@svelteuidev/composables/dist/shared/actions/utils/environment.js
var isBrowser3 = () => typeof window !== "undefined";
var ENVIRONMENT2 = {
  browser: isBrowser3(),
  server: !isBrowser3()
};
var defaultWindow = ENVIRONMENT2.browser ? window : void 0;

// node_modules/@svelteuidev/composables/dist/actions/use-lock-scroll/use-lock-scroll.js
function lockscroll(node, lock, options = { disableBodyPadding: false }) {
  const { browser: browser4 } = ENVIRONMENT2;
  let window2;
  if (browser4) {
    window2 = defaultWindow;
  }
  let scrollLocked = lock ?? false;
  const { disableBodyPadding } = options;
  let stylesheet;
  const lockScroll = () => {
    const styles = getLockStyles({ disableBodyPadding });
    const sheet = createStyleTag();
    injectStyles(sheet, styles);
    insertStyleTag(sheet);
    stylesheet = sheet;
  };
  const unlockScroll = () => {
    var _a;
    if (!stylesheet)
      return;
    (_a = stylesheet == null ? void 0 : stylesheet.parentNode) == null ? void 0 : _a.removeChild(stylesheet);
    stylesheet = null;
  };
  if (scrollLocked) {
    lockScroll();
  } else {
    unlockScroll();
  }
  if (lock !== void 0) {
    scrollLocked = lock;
  }
  if (lock === void 0 && typeof window2 !== "undefined") {
    window2.document.body.style.overflow === "hidden" && (scrollLocked = lock);
  }
  return {
    update: (locked) => {
      if (locked) {
        lockScroll();
      } else {
        window2.document.body.style.overflow === "visible" && (scrollLocked = lock);
        unlockScroll();
      }
    },
    destroy: () => {
      unlockScroll();
      return;
    }
  };
}

// node_modules/@svelteuidev/composables/dist/shared/utilities/utils/_configurable.js
var isBrowser4 = () => typeof window !== "undefined";
var browser2 = isBrowser4();
var defaultDocument = browser2 ? window.document : void 0;
var defaultNavigator = browser2 ? window.navigator : void 0;
var defaultLocation = browser2 ? window.location : void 0;

// node_modules/@svelteuidev/composables/dist/actions/use-portal/use-portal.js
function portal(node, target = "body") {
  let targetNode;
  async function update(newTarget) {
    target = newTarget;
    if (typeof target === "string") {
      targetNode = document.querySelector(target);
      if (targetNode === null) {
        await tick();
        targetNode = document.querySelector(target);
      }
      if (targetNode === null) {
        throw new Error(`No element found matching css selector: "${target}"`);
      }
    } else if (target instanceof HTMLElement) {
      targetNode = target;
    } else {
      throw new TypeError(`Unknown portal target type: ${target === null ? "null" : typeof target}. Allowed types: string (CSS selector) or HTMLElement.`);
    }
    targetNode.appendChild(node);
    node.hidden = false;
  }
  function destroy() {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    }
  }
  update(target);
  return {
    update,
    destroy
  };
}

// node_modules/@svelteuidev/composables/dist/utilities/use-focus-return/use-focus-return.js
function useFocusReturn() {
  let lastActiveElement;
  const returnFocus = () => {
    if (lastActiveElement && "focus" in lastActiveElement && typeof lastActiveElement.focus === "function") {
      lastActiveElement.focus({ preventScroll: true });
    }
  };
  return {
    handleFocusReturn(opened, shouldReturnFocus = true) {
      if (opened) {
        lastActiveElement = document.activeElement;
      } else if (shouldReturnFocus) {
        returnFocus();
      }
    },
    returnFocus
  };
}

// node_modules/@svelteuidev/composables/dist/utilities/use-hash/use-hash.js
function useHash(prefix = "svelteui", persist = false) {
  if (persist && browser2) {
    let hash = `${prefix}-${Math.random().toString(36).substring(2, 10)}`;
    if (localStorage[`${prefix}-hash`] !== void 0) {
      hash = localStorage.getItem(`${prefix}-hash`);
    } else {
      localStorage.setItem(`${prefix}-hash`, hash);
    }
    return hash;
  }
  return `${prefix}-${Math.random().toString(36).substring(2, 10)}`;
}

// node_modules/@svelteuidev/composables/dist/utilities/use-id/use-id.js
var IDX = 256;
var HEX = [];
while (IDX--)
  HEX[IDX] = (IDX + 256).toString(16).substring(1);

// node_modules/@svelteuidev/composables/dist/utilities/use-raf-fn/use-raf-fn.js
var isBrowser5 = () => typeof window !== "undefined";
var browser3 = isBrowser5();

// node_modules/@svelteuidev/core/dist/components/Portal/Portal.svelte
var file12 = "node_modules/@svelteuidev/core/dist/components/Portal/Portal.svelte";
function create_fragment18(ctx8) {
  let div;
  let useActions_action;
  let forwardEvents_action;
  let portal_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx8[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[7],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "class",
        /*className*/
        ctx8[2]
      );
      div.hidden = true;
      set_style(
        div,
        "position",
        /*position*/
        ctx8[4]
      );
      set_style(
        div,
        "zIndex",
        /*zIndex*/
        ctx8[5]
      );
      add_location(div, file12, 9, 0, 479);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx8[9](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div,
            /*use*/
            ctx8[1]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx8[6].call(null, div)),
          action_destroyer(portal_action = portal.call(
            null,
            div,
            /*target*/
            ctx8[3]
          ))
        ];
        mounted = true;
      }
    },
    p: function update(ctx9, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*className*/
      4) {
        attr_dev(
          div,
          "class",
          /*className*/
          ctx9[2]
        );
      }
      if (!current || dirty & /*position*/
      16) {
        set_style(
          div,
          "position",
          /*position*/
          ctx9[4]
        );
      }
      if (!current || dirty & /*zIndex*/
      32) {
        set_style(
          div,
          "zIndex",
          /*zIndex*/
          ctx9[5]
        );
      }
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      2)
        useActions_action.update.call(
          null,
          /*use*/
          ctx9[1]
        );
      if (portal_action && is_function(portal_action.update) && dirty & /*target*/
      8)
        portal_action.update.call(
          null,
          /*target*/
          ctx9[3]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx8[9](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Portal", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", target = "body", position = "relative", zIndex = 1 } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  const writable_props = ["use", "element", "class", "target", "position", "zIndex"];
  Object.keys($$props).forEach((key3) => {
    if (!~writable_props.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<Portal> was created with unknown prop '${key3}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("use" in $$props2)
      $$invalidate(1, use = $$props2.use);
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("class" in $$props2)
      $$invalidate(2, className = $$props2.class);
    if ("target" in $$props2)
      $$invalidate(3, target = $$props2.target);
    if ("position" in $$props2)
      $$invalidate(4, position = $$props2.position);
    if ("zIndex" in $$props2)
      $$invalidate(5, zIndex = $$props2.zIndex);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventForwarder,
    useActions,
    get_current_component,
    portal,
    use,
    element: element2,
    className,
    target,
    position,
    zIndex,
    forwardEvents
  });
  $$self.$inject_state = ($$props2) => {
    if ("use" in $$props2)
      $$invalidate(1, use = $$props2.use);
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("className" in $$props2)
      $$invalidate(2, className = $$props2.className);
    if ("target" in $$props2)
      $$invalidate(3, target = $$props2.target);
    if ("position" in $$props2)
      $$invalidate(4, position = $$props2.position);
    if ("zIndex" in $$props2)
      $$invalidate(5, zIndex = $$props2.zIndex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    use,
    className,
    target,
    position,
    zIndex,
    forwardEvents,
    $$scope,
    slots,
    div_binding
  ];
}
var Portal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      target: 3,
      position: 4,
      zIndex: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Portal",
      options,
      id: create_fragment18.name
    });
  }
  get use() {
    throw new Error("<Portal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Portal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Portal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Portal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Portal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Portal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<Portal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<Portal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Portal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Portal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Portal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Portal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Portal_default = Portal;

// node_modules/@svelteuidev/core/dist/components/Portal/OptionalPortal.svelte
function create_else_block5(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[7],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[7],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block5.name,
    type: "else",
    source: "(10:0) {:else}",
    ctx: ctx8
  });
  return block;
}
function create_if_block6(ctx8) {
  let portal2;
  let updating_element;
  let current;
  function portal_element_binding(value) {
    ctx8[6](value);
  }
  let portal_props = {
    class: (
      /*className*/
      ctx8[3]
    ),
    use: (
      /*use*/
      ctx8[2]
    ),
    target: (
      /*target*/
      ctx8[4]
    ),
    $$slots: { default: [create_default_slot8] },
    $$scope: { ctx: ctx8 }
  };
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    portal_props.element = /*element*/
    ctx8[0];
  }
  portal2 = new Portal_default({ props: portal_props, $$inline: true });
  binding_callbacks.push(() => bind(portal2, "element", portal_element_binding));
  const block = {
    c: function create() {
      create_component(portal2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(portal2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(portal2, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const portal_changes = {};
      if (dirty & /*className*/
      8)
        portal_changes.class = /*className*/
        ctx9[3];
      if (dirty & /*use*/
      4)
        portal_changes.use = /*use*/
        ctx9[2];
      if (dirty & /*target*/
      16)
        portal_changes.target = /*target*/
        ctx9[4];
      if (dirty & /*$$scope*/
      128) {
        portal_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        portal_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      portal2.$set(portal_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(portal2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(portal2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(portal2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(6:0) {#if withinPortal}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot8(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[7],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[7],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot8.name,
    type: "slot",
    source: "(7:1) <Portal bind:element class={className} {use} {target}>",
    ctx: ctx8
  });
  return block;
}
function create_fragment19(ctx8) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block6, create_else_block5];
  const if_blocks = [];
  function select_block_type(ctx9, dirty) {
    if (
      /*withinPortal*/
      ctx9[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx8, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx8);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx9, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx9, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx9);
          if_block.c();
        } else {
          if_block.p(ctx9, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("OptionalPortal", slots, ["default"]);
  let { withinPortal = true, use = [], element: element2 = void 0, class: className = "", target = "body" } = $$props;
  const writable_props = ["withinPortal", "use", "element", "class", "target"];
  Object.keys($$props).forEach((key3) => {
    if (!~writable_props.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<OptionalPortal> was created with unknown prop '${key3}'`);
  });
  function portal_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$props2) => {
    if ("withinPortal" in $$props2)
      $$invalidate(1, withinPortal = $$props2.withinPortal);
    if ("use" in $$props2)
      $$invalidate(2, use = $$props2.use);
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("class" in $$props2)
      $$invalidate(3, className = $$props2.class);
    if ("target" in $$props2)
      $$invalidate(4, target = $$props2.target);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    Portal: Portal_default,
    withinPortal,
    use,
    element: element2,
    className,
    target
  });
  $$self.$inject_state = ($$props2) => {
    if ("withinPortal" in $$props2)
      $$invalidate(1, withinPortal = $$props2.withinPortal);
    if ("use" in $$props2)
      $$invalidate(2, use = $$props2.use);
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("className" in $$props2)
      $$invalidate(3, className = $$props2.className);
    if ("target" in $$props2)
      $$invalidate(4, target = $$props2.target);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    withinPortal,
    use,
    className,
    target,
    slots,
    portal_element_binding,
    $$scope
  ];
}
var OptionalPortal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, {
      withinPortal: 1,
      use: 2,
      element: 0,
      class: 3,
      target: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "OptionalPortal",
      options,
      id: create_fragment19.name
    });
  }
  get withinPortal() {
    throw new Error("<OptionalPortal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withinPortal(value) {
    throw new Error("<OptionalPortal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get use() {
    throw new Error("<OptionalPortal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<OptionalPortal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<OptionalPortal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<OptionalPortal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<OptionalPortal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<OptionalPortal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<OptionalPortal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<OptionalPortal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var OptionalPortal_default = OptionalPortal;

// node_modules/@svelteuidev/core/dist/components/Affix/Affix.svelte
function create_default_slot_12(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[10],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[10],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: "(8:1) <Box   bind:element   class={className}   css={{ position: 'fixed', ...position, ...override }}   {use}   {...$$restProps}  >",
    ctx: ctx8
  });
  return block;
}
function create_default_slot9(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { class: (
      /*className*/
      ctx8[2]
    ) },
    {
      css: {
        position: "fixed",
        .../*position*/
        ctx8[5],
        .../*override*/
        ctx8[3]
      }
    },
    { use: (
      /*use*/
      ctx8[1]
    ) },
    /*$$restProps*/
    ctx8[7]
  ];
  function box_element_binding(value) {
    ctx8[9](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot_12] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const box_changes = dirty & /*className, position, override, use, $$restProps*/
      174 ? get_spread_update(box_spread_levels, [
        dirty & /*className*/
        4 && { class: (
          /*className*/
          ctx9[2]
        ) },
        dirty & /*position, override*/
        40 && {
          css: {
            position: "fixed",
            .../*position*/
            ctx9[5],
            .../*override*/
            ctx9[3]
          }
        },
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*$$restProps*/
        128 && get_spread_object(
          /*$$restProps*/
          ctx9[7]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      1024) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot9.name,
    type: "slot",
    source: "(7:0) <Portal {zIndex} {target}>",
    ctx: ctx8
  });
  return block;
}
function create_fragment20(ctx8) {
  let portal2;
  let current;
  portal2 = new Portal_default({
    props: {
      zIndex: (
        /*zIndex*/
        ctx8[6]
      ),
      target: (
        /*target*/
        ctx8[4]
      ),
      $$slots: { default: [create_default_slot9] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(portal2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(portal2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(portal2, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const portal_changes = {};
      if (dirty & /*zIndex*/
      64)
        portal_changes.zIndex = /*zIndex*/
        ctx9[6];
      if (dirty & /*target*/
      16)
        portal_changes.target = /*target*/
        ctx9[4];
      if (dirty & /*$$scope, className, position, override, use, $$restProps, element*/
      1199) {
        portal_changes.$$scope = { dirty, ctx: ctx9 };
      }
      portal2.$set(portal_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(portal2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(portal2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(portal2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "element", "class", "override", "target", "position", "zIndex"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Affix", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, target = "body", position = { bottom: 0, right: 0 }, zIndex = 200 } = $$props;
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("target" in $$new_props)
      $$invalidate(4, target = $$new_props.target);
    if ("position" in $$new_props)
      $$invalidate(5, position = $$new_props.position);
    if ("zIndex" in $$new_props)
      $$invalidate(6, zIndex = $$new_props.zIndex);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Box: Box_default,
    Portal: Portal_default,
    use,
    element: element2,
    className,
    override,
    target,
    position,
    zIndex
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("target" in $$props)
      $$invalidate(4, target = $$new_props.target);
    if ("position" in $$props)
      $$invalidate(5, position = $$new_props.position);
    if ("zIndex" in $$props)
      $$invalidate(6, zIndex = $$new_props.zIndex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    use,
    className,
    override,
    target,
    position,
    zIndex,
    $$restProps,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Affix = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      target: 4,
      position: 5,
      zIndex: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Affix",
      options,
      id: create_fragment20.name
    });
  }
  get use() {
    throw new Error("<Affix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Affix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Affix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Affix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Affix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Affix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Affix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Affix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<Affix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<Affix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Affix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Affix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Affix>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Affix>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Affix_default = Affix;

// node_modules/@svelteuidev/core/dist/components/Alert/Alert.styles.js
var Alert_styles_default = createStyles((theme4, { color, radius: radius2, variant: variant2 }, getRef) => {
  return {
    root: {
      fontFamily: theme4.fonts.standard.value ?? "sans-serif",
      position: "relative",
      overflow: "hidden",
      padding: `${theme4.space.sm.value}px ${theme4.space.md.value}px`,
      borderRadius: theme4.fn.radius(radius2),
      border: "1px solid transparent",
      "&.light": {
        darkMode: {
          backgroundColor: theme4.fn.variant({ variant: "light", color }).background[0],
          color: theme4.fn.variant({ variant: "light", color }).color[0]
        },
        backgroundColor: theme4.fn.variant({ variant: "light", color }).background[1],
        color: theme4.fn.variant({ variant: "light", color }).color[1]
      },
      "&.filled": {
        darkMode: {
          backgroundColor: theme4.fn.variant({ variant: "filled", color }).background[0]
        },
        backgroundColor: theme4.fn.variant({ variant: "filled", color }).background[1],
        color: theme4.colors.white.value,
        [`& .${getRef("closeButton")}`]: {
          color: theme4.colors.white.value
        }
      },
      "&.outline": {
        darkMode: {
          color: theme4.fn.variant({ variant: "outline", color }).color[0],
          borderColor: theme4.fn.variant({ variant: "outline", color }).border[0]
        },
        color: theme4.fn.variant({ variant: "outline", color }).color[1],
        borderColor: theme4.fn.variant({ variant: "outline", color }).border[1]
      }
    },
    wrapper: {
      display: "flex"
    },
    content: {
      flex: 1
    },
    title: {
      boxSizing: "border-box",
      margin: 0,
      marginBottom: 7,
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      lineHeight: theme4.lineHeights.sm.value,
      fontSize: theme4.fontSizes.sm.value,
      fontWeight: "$bold"
    },
    label: {
      display: "block",
      overflow: "hidden",
      textOverflow: "ellipsis"
    },
    icon: {
      lineHeight: 1,
      width: 20,
      height: 20,
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-start",
      marginRight: theme4.space.mdPX.value,
      marginTop: 1
    },
    message: {
      darkMode: {
        color: variant2 === "filled" ? theme4.colors.white.value : variant2 === "light" ? theme4.colors.white.value : theme4.fn.themeColor("dark", 0)
      },
      lineHeight: theme4.lineHeights.sm.value,
      textOverflow: "ellipsis",
      overflow: "hidden",
      fontSize: theme4.fontSizes.sm.value,
      color: variant2 === "filled" ? theme4.colors.white.value : theme4.colors.black.value
    },
    closeButton: {
      ref: getRef("closeButton"),
      marginTop: 2
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/IconRenderer/IconRenderer.styles.js
var IconRenderer_styles_default = createStyles((theme4, { iconSize }) => {
  return {
    root: {
      focusRing: "auto",
      position: "relative",
      appearance: "none",
      WebkitAppearance: "none",
      WebkitTapHighlightColor: "transparent",
      boxSizing: "border-box",
      height: `${theme4.fn.size({ size: iconSize, sizes: theme4.space })}px`,
      minHeight: `${theme4.fn.size({ size: iconSize, sizes: theme4.space })}px`,
      width: `${theme4.fn.size({ size: iconSize, sizes: theme4.space })}px`,
      minWidth: `${theme4.fn.size({ size: iconSize, sizes: theme4.space })}px`,
      padding: 0,
      lineHeight: 1,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      cursor: "pointer",
      textDecoration: "none"
    },
    icon: {
      height: `${theme4.fn.size({ size: iconSize, sizes: theme4.space })}px`,
      minHeight: `${theme4.fn.size({ size: iconSize, sizes: theme4.space })}px`,
      position: "static",
      margin: 0,
      ml: 0,
      mr: 0,
      mt: 0,
      mb: 0
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/IconRenderer/IconRenderer.svelte
var file13 = "node_modules/@svelteuidev/core/dist/components/IconRenderer/IconRenderer.svelte";
function create_if_block_14(ctx8) {
  let if_block_anchor;
  let if_block = (
    /*icon*/
    (ctx8[2] instanceof HTMLElement || /*icon*/
    ctx8[2] instanceof SVGElement) && create_if_block_22(ctx8)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (
        /*icon*/
        ctx9[2] instanceof HTMLElement || /*icon*/
        ctx9[2] instanceof SVGElement
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
        } else {
          if_block = create_if_block_22(ctx9);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(17:24) ",
    ctx: ctx8
  });
  return block;
}
function create_if_block7(ctx8) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    {
      class: (
        /*cx*/
        ctx8[6](
          /*className*/
          ctx8[0],
          /*classes*/
          ctx8[4].root,
          /*getStyles*/
          ctx8[5]({ css: (
            /*override*/
            ctx8[1]
          ) })
        )
      )
    },
    /*iconProps*/
    ctx8[3]
  ];
  var switch_value = (
    /*icon*/
    ctx8[2]
  );
  function switch_props(ctx9, dirty) {
    let switch_instance_props = {};
    for (let i2 = 0; i2 < switch_instance_spread_levels.length; i2 += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i2]);
    }
    if (dirty !== void 0 && dirty & /*cx, className, classes, getStyles, override, iconProps*/
    123) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
        dirty & /*cx, className, classes, getStyles, override*/
        115 && {
          class: (
            /*cx*/
            ctx9[6](
              /*className*/
              ctx9[0],
              /*classes*/
              ctx9[4].root,
              /*getStyles*/
              ctx9[5]({ css: (
                /*override*/
                ctx9[1]
              ) })
            )
          )
        },
        dirty & /*iconProps*/
        8 && get_spread_object(
          /*iconProps*/
          ctx9[3]
        )
      ]));
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx8));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*icon*/
      4 && switch_value !== (switch_value = /*icon*/
      ctx9[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx9, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*cx, className, classes, getStyles, override, iconProps*/
        123 ? get_spread_update(switch_instance_spread_levels, [
          dirty & /*cx, className, classes, getStyles, override*/
          115 && {
            class: (
              /*cx*/
              ctx9[6](
                /*className*/
                ctx9[0],
                /*classes*/
                ctx9[4].root,
                /*getStyles*/
                ctx9[5]({ css: (
                  /*override*/
                  ctx9[1]
                ) })
              )
            )
          },
          dirty & /*iconProps*/
          8 && get_spread_object(
            /*iconProps*/
            ctx9[3]
          )
        ]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(11:0) {#if typeof icon === 'function'}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_22(ctx8) {
  let span;
  let html_tag;
  let raw_value = (
    /*icon*/
    ctx8[2].outerHTML + ""
  );
  let span_class_value;
  const block = {
    c: function create() {
      span = element("span");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      html_tag = claim_html_tag(span_nodes, false);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(span, "class", span_class_value = /*cx*/
      ctx8[6](
        /*className*/
        ctx8[0],
        /*classes*/
        ctx8[4].root,
        /*getStyles*/
        ctx8[5]({ css: (
          /*override*/
          ctx8[1]
        ) })
      ));
      add_location(span, file13, 18, 2, 796);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      html_tag.m(raw_value, span);
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*icon*/
      4 && raw_value !== (raw_value = /*icon*/
      ctx9[2].outerHTML + ""))
        html_tag.p(raw_value);
      if (dirty & /*cx, className, classes, getStyles, override*/
      115 && span_class_value !== (span_class_value = /*cx*/
      ctx9[6](
        /*className*/
        ctx9[0],
        /*classes*/
        ctx9[4].root,
        /*getStyles*/
        ctx9[5]({ css: (
          /*override*/
          ctx9[1]
        ) })
      ))) {
        attr_dev(span, "class", span_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(18:1) {#if icon instanceof HTMLElement || icon instanceof SVGElement}",
    ctx: ctx8
  });
  return block;
}
function create_fragment21(ctx8) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block7, create_if_block_14];
  const if_blocks = [];
  function select_block_type(ctx9, dirty) {
    if (typeof /*icon*/
    ctx9[2] === "function")
      return 0;
    if (!/*requiresShim*/
    ctx9[7])
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx8, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx8);
  }
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx9, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx9, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx9);
            if_block.c();
          } else {
            if_block.p(ctx9, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  let cx2;
  let getStyles;
  let classes;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("IconRenderer", slots, []);
  let { className = "", override = {}, icon = void 0, iconSize = 16, iconProps = {} } = $$props;
  const requiresShim = typeof HTMLElement === "undefined" && typeof SVGElement === "undefined";
  const writable_props = ["className", "override", "icon", "iconSize", "iconProps"];
  Object.keys($$props).forEach((key3) => {
    if (!~writable_props.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<IconRenderer> was created with unknown prop '${key3}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("className" in $$props2)
      $$invalidate(0, className = $$props2.className);
    if ("override" in $$props2)
      $$invalidate(1, override = $$props2.override);
    if ("icon" in $$props2)
      $$invalidate(2, icon = $$props2.icon);
    if ("iconSize" in $$props2)
      $$invalidate(8, iconSize = $$props2.iconSize);
    if ("iconProps" in $$props2)
      $$invalidate(3, iconProps = $$props2.iconProps);
  };
  $$self.$capture_state = () => ({
    useStyles: IconRenderer_styles_default,
    className,
    override,
    icon,
    iconSize,
    iconProps,
    requiresShim,
    classes,
    getStyles,
    cx: cx2
  });
  $$self.$inject_state = ($$props2) => {
    if ("className" in $$props2)
      $$invalidate(0, className = $$props2.className);
    if ("override" in $$props2)
      $$invalidate(1, override = $$props2.override);
    if ("icon" in $$props2)
      $$invalidate(2, icon = $$props2.icon);
    if ("iconSize" in $$props2)
      $$invalidate(8, iconSize = $$props2.iconSize);
    if ("iconProps" in $$props2)
      $$invalidate(3, iconProps = $$props2.iconProps);
    if ("classes" in $$props2)
      $$invalidate(4, classes = $$props2.classes);
    if ("getStyles" in $$props2)
      $$invalidate(5, getStyles = $$props2.getStyles);
    if ("cx" in $$props2)
      $$invalidate(6, cx2 = $$props2.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*iconSize*/
    256) {
      $:
        $$invalidate(6, { cx: cx2, getStyles, classes } = IconRenderer_styles_default({ iconSize }, { name: "IconRenderer" }), cx2, ($$invalidate(5, getStyles), $$invalidate(8, iconSize)), ($$invalidate(4, classes), $$invalidate(8, iconSize)));
    }
    if ($$self.$$.dirty & /*icon, classes*/
    20) {
      $:
        if (!requiresShim && (icon instanceof HTMLElement || icon instanceof SVGElement)) {
          icon.classList.add(...classes.icon.split(" "));
        }
    }
  };
  return [
    className,
    override,
    icon,
    iconProps,
    classes,
    getStyles,
    cx2,
    requiresShim,
    iconSize
  ];
}
var IconRenderer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, {
      className: 0,
      override: 1,
      icon: 2,
      iconSize: 8,
      iconProps: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "IconRenderer",
      options,
      id: create_fragment21.name
    });
  }
  get className() {
    throw new Error("<IconRenderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set className(value) {
    throw new Error("<IconRenderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<IconRenderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<IconRenderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<IconRenderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<IconRenderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconSize() {
    throw new Error("<IconRenderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconSize(value) {
    throw new Error("<IconRenderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconProps() {
    throw new Error("<IconRenderer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconProps(value) {
    throw new Error("<IconRenderer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var IconRenderer_default = IconRenderer;

// node_modules/@svelteuidev/core/dist/components/Alert/Alert.svelte
var file14 = "node_modules/@svelteuidev/core/dist/components/Alert/Alert.svelte";
var get_icon_slot_changes = (dirty) => ({});
var get_icon_slot_context = (ctx8) => ({});
function create_if_block_23(ctx8) {
  let iconrenderer;
  let current;
  iconrenderer = new IconRenderer_default({
    props: {
      icon: (
        /*icon*/
        ctx8[5]
      ),
      className: (
        /*classes*/
        ctx8[10].icon
      ),
      iconSize: (
        /*iconSize*/
        ctx8[6]
      ),
      iconProps: (
        /*iconProps*/
        ctx8[7]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(iconrenderer.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconrenderer.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconrenderer, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const iconrenderer_changes = {};
      if (dirty & /*icon*/
      32)
        iconrenderer_changes.icon = /*icon*/
        ctx9[5];
      if (dirty & /*classes*/
      1024)
        iconrenderer_changes.className = /*classes*/
        ctx9[10].icon;
      if (dirty & /*iconSize*/
      64)
        iconrenderer_changes.iconSize = /*iconSize*/
        ctx9[6];
      if (dirty & /*iconProps*/
      128)
        iconrenderer_changes.iconProps = /*iconProps*/
        ctx9[7];
      iconrenderer.$set(iconrenderer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconrenderer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconrenderer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconrenderer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_23.name,
    type: "if",
    source: "(18:3) {#if icon}",
    ctx: ctx8
  });
  return block;
}
function fallback_block4(ctx8) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*icon*/
    ctx8[5] && create_if_block_23(ctx8)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (
        /*icon*/
        ctx9[5]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
          if (dirty & /*icon*/
          32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_23(ctx9);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block4.name,
    type: "fallback",
    source: "(17:20)     ",
    ctx: ctx8
  });
  return block;
}
function create_if_block8(ctx8) {
  let div;
  let span;
  let t0;
  let span_class_value;
  let t1;
  let div_class_value;
  let current;
  let if_block = (
    /*withCloseButton*/
    ctx8[8] && create_if_block_15(ctx8)
  );
  const block = {
    c: function create() {
      div = element("div");
      span = element("span");
      t0 = text(
        /*title*/
        ctx8[3]
      );
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      span = claim_element(div_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(
        span_nodes,
        /*title*/
        ctx8[3]
      );
      span_nodes.forEach(detach_dev);
      t1 = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*classes*/
      ctx8[10].label);
      add_location(span, file14, 25, 5, 1051);
      attr_dev(div, "class", div_class_value = /*classes*/
      ctx8[10].title);
      add_location(div, file14, 24, 4, 1018);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, span);
      append_hydration_dev(span, t0);
      append_hydration_dev(div, t1);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (!current || dirty & /*title*/
      8)
        set_data_dev(
          t0,
          /*title*/
          ctx9[3]
        );
      if (!current || dirty & /*classes*/
      1024 && span_class_value !== (span_class_value = /*classes*/
      ctx9[10].label)) {
        attr_dev(span, "class", span_class_value);
      }
      if (
        /*withCloseButton*/
        ctx9[8]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
          if (dirty & /*withCloseButton*/
          256) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_15(ctx9);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*classes*/
      1024 && div_class_value !== (div_class_value = /*classes*/
      ctx9[10].title)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(24:3) {#if title}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_15(ctx8) {
  let closebutton;
  let current;
  closebutton = new CloseButton_default({
    props: {
      class: (
        /*classes*/
        ctx8[10].closeButton
      ),
      "aria-label": (
        /*closeButtonLabel*/
        ctx8[9]
      ),
      variant: "transparent",
      size: (
        /*iconSize*/
        ctx8[6]
      ),
      iconSize: (
        /*iconSize*/
        ctx8[6]
      )
    },
    $$inline: true
  });
  closebutton.$on(
    "click",
    /*onClose*/
    ctx8[12]
  );
  const block = {
    c: function create() {
      create_component(closebutton.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(closebutton.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(closebutton, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const closebutton_changes = {};
      if (dirty & /*classes*/
      1024)
        closebutton_changes.class = /*classes*/
        ctx9[10].closeButton;
      if (dirty & /*closeButtonLabel*/
      512)
        closebutton_changes["aria-label"] = /*closeButtonLabel*/
        ctx9[9];
      if (dirty & /*iconSize*/
      64)
        closebutton_changes.size = /*iconSize*/
        ctx9[6];
      if (dirty & /*iconSize*/
      64)
        closebutton_changes.iconSize = /*iconSize*/
        ctx9[6];
      closebutton.$set(closebutton_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(closebutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(closebutton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(closebutton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(29:5) {#if withCloseButton}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot10(ctx8) {
  let div2;
  let t0;
  let div1;
  let t1;
  let div0;
  let div0_class_value;
  let div1_class_value;
  let div2_class_value;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx8[17].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[19],
    get_icon_slot_context
  );
  const icon_slot_or_fallback = icon_slot || fallback_block4(ctx8);
  let if_block = (
    /*title*/
    ctx8[3] && create_if_block8(ctx8)
  );
  const default_slot_template = (
    /*#slots*/
    ctx8[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[19],
    null
  );
  const block = {
    c: function create() {
      div2 = element("div");
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.c();
      t0 = space();
      div1 = element("div");
      if (if_block)
        if_block.c();
      t1 = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.l(div2_nodes);
      t0 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block)
        if_block.l(div1_nodes);
      t1 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = /*classes*/
      ctx8[10].message);
      add_location(div0, file14, 40, 3, 1364);
      attr_dev(div1, "class", div1_class_value = /*classes*/
      ctx8[10].content);
      add_location(div1, file14, 22, 2, 969);
      attr_dev(div2, "class", div2_class_value = /*classes*/
      ctx8[10].wrapper);
      add_location(div2, file14, 15, 1, 806);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(div2, null);
      }
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, div1);
      if (if_block)
        if_block.m(div1, null);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[19]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx9[19],
              dirty,
              get_icon_slot_changes
            ),
            get_icon_slot_context
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty & /*icon, classes, iconSize, iconProps*/
        1248)) {
          icon_slot_or_fallback.p(ctx9, !current ? -1 : dirty);
        }
      }
      if (
        /*title*/
        ctx9[3]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
          if (dirty & /*title*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block8(ctx9);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[19],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classes*/
      1024 && div0_class_value !== (div0_class_value = /*classes*/
      ctx9[10].message)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty & /*classes*/
      1024 && div1_class_value !== (div1_class_value = /*classes*/
      ctx9[10].content)) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*classes*/
      1024 && div2_class_value !== (div2_class_value = /*classes*/
      ctx9[10].wrapper)) {
        attr_dev(div2, "class", div2_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot_or_fallback, local);
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot_or_fallback, local);
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.d(detaching);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot10.name,
    type: "slot",
    source: '(15:0) <Box {use} bind:element role=\\"alert\\" class={cx(className, variant, classes.root)} {...$$restProps}>',
    ctx: ctx8
  });
  return block;
}
function create_fragment22(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { use: (
      /*use*/
      ctx8[1]
    ) },
    { role: "alert" },
    {
      class: (
        /*cx*/
        ctx8[11](
          /*className*/
          ctx8[2],
          /*variant*/
          ctx8[4],
          /*classes*/
          ctx8[10].root
        )
      )
    },
    /*$$restProps*/
    ctx8[13]
  ];
  function box_element_binding(value) {
    ctx8[18](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot10] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*use, cx, className, variant, classes, $$restProps*/
      11286 ? get_spread_update(box_spread_levels, [
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        box_spread_levels[1],
        dirty & /*cx, className, variant, classes*/
        3092 && {
          class: (
            /*cx*/
            ctx9[11](
              /*className*/
              ctx9[2],
              /*variant*/
              ctx9[4],
              /*classes*/
              ctx9[10].root
            )
          )
        },
        dirty & /*$$restProps*/
        8192 && get_spread_object(
          /*$$restProps*/
          ctx9[13]
        )
      ]) : {};
      if (dirty & /*$$scope, classes, closeButtonLabel, iconSize, withCloseButton, title, icon, iconProps*/
      526312) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "title",
    "color",
    "radius",
    "variant",
    "icon",
    "iconSize",
    "iconProps",
    "withCloseButton",
    "closeButtonLabel"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Alert", slots, ["icon", "default"]);
  let { use = [], element: element2 = void 0, class: className = "blue", override = {}, title = void 0, color = "red", radius: radius2 = "sm", variant: variant2 = "light", icon = void 0, iconSize = 16, iconProps = {}, withCloseButton = false, closeButtonLabel = void 0 } = $$props;
  const dispatch = createEventDispatcher();
  function onClose() {
    dispatch("close");
  }
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(14, override = $$new_props.override);
    if ("title" in $$new_props)
      $$invalidate(3, title = $$new_props.title);
    if ("color" in $$new_props)
      $$invalidate(15, color = $$new_props.color);
    if ("radius" in $$new_props)
      $$invalidate(16, radius2 = $$new_props.radius);
    if ("variant" in $$new_props)
      $$invalidate(4, variant2 = $$new_props.variant);
    if ("icon" in $$new_props)
      $$invalidate(5, icon = $$new_props.icon);
    if ("iconSize" in $$new_props)
      $$invalidate(6, iconSize = $$new_props.iconSize);
    if ("iconProps" in $$new_props)
      $$invalidate(7, iconProps = $$new_props.iconProps);
    if ("withCloseButton" in $$new_props)
      $$invalidate(8, withCloseButton = $$new_props.withCloseButton);
    if ("closeButtonLabel" in $$new_props)
      $$invalidate(9, closeButtonLabel = $$new_props.closeButtonLabel);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    useStyles: Alert_styles_default,
    Box: Box_default,
    IconRenderer: IconRenderer_default,
    CloseButton: CloseButton_default,
    use,
    element: element2,
    className,
    override,
    title,
    color,
    radius: radius2,
    variant: variant2,
    icon,
    iconSize,
    iconProps,
    withCloseButton,
    closeButtonLabel,
    dispatch,
    onClose,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(14, override = $$new_props.override);
    if ("title" in $$props)
      $$invalidate(3, title = $$new_props.title);
    if ("color" in $$props)
      $$invalidate(15, color = $$new_props.color);
    if ("radius" in $$props)
      $$invalidate(16, radius2 = $$new_props.radius);
    if ("variant" in $$props)
      $$invalidate(4, variant2 = $$new_props.variant);
    if ("icon" in $$props)
      $$invalidate(5, icon = $$new_props.icon);
    if ("iconSize" in $$props)
      $$invalidate(6, iconSize = $$new_props.iconSize);
    if ("iconProps" in $$props)
      $$invalidate(7, iconProps = $$new_props.iconProps);
    if ("withCloseButton" in $$props)
      $$invalidate(8, withCloseButton = $$new_props.withCloseButton);
    if ("closeButtonLabel" in $$props)
      $$invalidate(9, closeButtonLabel = $$new_props.closeButtonLabel);
    if ("classes" in $$props)
      $$invalidate(10, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(11, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*color, radius, variant, override*/
    114704) {
      $:
        $$invalidate(11, { cx: cx2, classes } = Alert_styles_default({ color, radius: radius2, variant: variant2 }, { name: "Alert", override }), cx2, ($$invalidate(10, classes), $$invalidate(15, color), $$invalidate(16, radius2), $$invalidate(4, variant2), $$invalidate(14, override)));
    }
  };
  return [
    element2,
    use,
    className,
    title,
    variant2,
    icon,
    iconSize,
    iconProps,
    withCloseButton,
    closeButtonLabel,
    classes,
    cx2,
    onClose,
    $$restProps,
    override,
    color,
    radius2,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Alert = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 14,
      title: 3,
      color: 15,
      radius: 16,
      variant: 4,
      icon: 5,
      iconSize: 6,
      iconProps: 7,
      withCloseButton: 8,
      closeButtonLabel: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Alert",
      options,
      id: create_fragment22.name
    });
  }
  get use() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconSize() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconSize(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconProps() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconProps(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withCloseButton() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withCloseButton(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeButtonLabel() {
    throw new Error("<Alert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeButtonLabel(value) {
    throw new Error("<Alert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Alert_default = Alert;

// node_modules/@svelteuidev/core/dist/components/Anchor/Anchor.styles.js
var Anchor_styles_default = createStyles(() => {
  return {
    root: {
      backgroundColor: "transparent",
      cursor: "pointer",
      padding: 0,
      border: 0
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Text/Text.styles.js
function getTextColor(theme4, color, variant2, gradient, dark2 = false) {
  if (color === "dimmed")
    return dark2 ? theme4.fn.themeColor("dark", 2) : theme4.fn.themeColor("gray", 6);
  if (variant2 === "gradient" || gradient)
    return theme4.fn.themeColor(color, 6);
  if (variant2 === "link")
    return dark2 ? theme4.fn.themeColor("blue", 4) : theme4.fn.themeColor("blue", 7);
  if (variant2 === "text")
    return dark2 ? theme4.fn.themeColor(color, 5) : theme4.fn.themeColor(color, 7);
}
var Text_styles_default = createStyles((theme4, { align, color, inherit, inline, lineClamp, size: size3, tracking, transform: transform2, underline, weight, gradient, variant: variant2 }) => {
  var _a;
  return {
    root: {
      focusRing: "auto",
      [`${theme4.dark} &`]: {
        color: color === "dark" ? "$dark50" : getTextColor(theme4, color, variant2, gradient, true)
      },
      fontFamily: inherit ? "inherit" : "$standard",
      fontSize: inherit ? "inherit" : typeof size3 === "string" ? `$${size3}` : `${size3}px`,
      fontWeight: inherit ? "inherit" : `$${weight}`,
      letterSpacing: (_a = theme4.letterSpacings[tracking]) == null ? void 0 : _a.value,
      lineHeight: inherit ? "inherit" : inline ? 1 : typeof size3 === "string" ? `$${size3}` : `${size3}px`,
      textTransform: transform2,
      textDecoration: underline ? "underline" : "none",
      textAlign: align,
      cursor: variant2 === "link" ? "pointer" : "inherit",
      color: color === "green" ? "Black" : getTextColor(theme4, color, variant2, gradient),
      backgroundImage: variant2 === "gradient" ? `linear-gradient(${gradient == null ? void 0 : gradient.deg}deg, $${gradient == null ? void 0 : gradient.from}600 0%, $${gradient == null ? void 0 : gradient.to}600 100%)` : null,
      WebkitBackgroundClip: variant2 === "gradient" ? "text" : null,
      WebkitTextFillColor: variant2 === "gradient" ? "transparent" : null,
      ...lineClamp !== void 0 ? {
        overflow: "hidden",
        textOverflow: "ellipsis",
        display: "-webkit-box",
        WebkitLineClamp: lineClamp,
        WebkitBoxOrient: "vertical"
      } : {},
      "&:hover": variant2 === "link" && underline === true ? {
        textDecoration: "underline"
      } : void 0
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Text/Text.errors.js
var Text_errors_exports = {};
__export(Text_errors_exports, {
  TextErrors: () => TextErrors
});
var TextErrors = Object.freeze([
  {
    error: true,
    message: "If using the 'gradient' prop, set 'variant' prop to 'gradient' to apply the gradient",
    solution: `
                If your component looks like this:

                &lt;Text gradient={{from: 'blue', to: 'red', deg: 45}}&gt;Text string &lt;/Text&gt;
                                                                    ^^^ - Try adding prop variant='gradient'
                `
  },
  {
    error: true,
    message: "If using the 'link' variant, an href needs to be set and the root must be an anchor",
    solution: `
                If your component looks like this:

                &lt;Text variant='link'&gt;Text string &lt;/Text&gt;
                                    ^^^ - Try adding props href && root={'a'}'
                `
  }
]);

// node_modules/@svelteuidev/core/dist/components/Text/Text.svelte
var { Error: Error_14 } = globals;
function create_default_slot11(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[25].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[27],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[27]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[27],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot11.name,
    type: "slot",
    source: "(55:0) <Box  {root}  bind:element  use={[forwardEvents, [useActions, use]]}  class={cx(className, classes.root, getStyles({ css: override }))}  href={href ?? undefined}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment23(ctx8) {
  let error;
  let t;
  let box;
  let updating_element;
  let current;
  error = new Error_default({
    props: {
      observable: (
        /*observable*/
        ctx8[6]
      ),
      component: "Text",
      code: (
        /*err*/
        ctx8[7]
      )
    },
    $$inline: true
  });
  const box_spread_levels = [
    { root: (
      /*root*/
      ctx8[4]
    ) },
    {
      use: [
        /*forwardEvents*/
        ctx8[11],
        [
          useActions,
          /*use*/
          ctx8[1]
        ]
      ]
    },
    {
      class: (
        /*cx*/
        ctx8[10](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[9].root,
          /*getStyles*/
          ctx8[8]({ css: (
            /*override*/
            ctx8[3]
          ) })
        )
      )
    },
    { href: (
      /*href*/
      ctx8[5] ?? void 0
    ) },
    /*$$restProps*/
    ctx8[12]
  ];
  function box_element_binding(value) {
    ctx8[26](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot11] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(error.$$.fragment);
      t = space();
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(error.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(error, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const error_changes = {};
      if (dirty & /*observable*/
      64)
        error_changes.observable = /*observable*/
        ctx9[6];
      if (dirty & /*err*/
      128)
        error_changes.code = /*err*/
        ctx9[7];
      error.$set(error_changes);
      const box_changes = dirty & /*root, forwardEvents, use, cx, className, classes, getStyles, override, href, undefined, $$restProps*/
      7998 ? get_spread_update(box_spread_levels, [
        dirty & /*root*/
        16 && { root: (
          /*root*/
          ctx9[4]
        ) },
        dirty & /*forwardEvents, use*/
        2050 && {
          use: [
            /*forwardEvents*/
            ctx9[11],
            [
              useActions,
              /*use*/
              ctx9[1]
            ]
          ]
        },
        dirty & /*cx, className, classes, getStyles, override*/
        1804 && {
          class: (
            /*cx*/
            ctx9[10](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[9].root,
              /*getStyles*/
              ctx9[8]({ css: (
                /*override*/
                ctx9[3]
              ) })
            )
          )
        },
        dirty & /*href, undefined*/
        32 && { href: (
          /*href*/
          ctx9[5] ?? void 0
        ) },
        dirty & /*$$restProps*/
        4096 && get_spread_object(
          /*$$restProps*/
          ctx9[12]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      134217728) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(error.$$.fragment, local);
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(error.$$.fragment, local);
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_component(error, detaching);
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "align",
    "color",
    "root",
    "transform",
    "variant",
    "size",
    "weight",
    "gradient",
    "inline",
    "lineClamp",
    "underline",
    "inherit",
    "href",
    "tracking"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Text", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, align = "left", color = "dark", root = void 0, transform: transform2 = "none", variant: variant2 = "text", size: size3 = "md", weight = "normal", gradient = { from: "indigo", to: "cyan", deg: 45 }, inline = true, lineClamp = void 0, underline = false, inherit = false, href = "", tracking = "normal" } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  let observable = false;
  let err;
  if (gradient.from === "indigo" && gradient.to === "cyan0" && gradient.deg === 45 && variant2 !== "gradient") {
    observable = true;
    err = TextErrors[0];
  }
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("align" in $$new_props)
      $$invalidate(13, align = $$new_props.align);
    if ("color" in $$new_props)
      $$invalidate(14, color = $$new_props.color);
    if ("root" in $$new_props)
      $$invalidate(4, root = $$new_props.root);
    if ("transform" in $$new_props)
      $$invalidate(15, transform2 = $$new_props.transform);
    if ("variant" in $$new_props)
      $$invalidate(16, variant2 = $$new_props.variant);
    if ("size" in $$new_props)
      $$invalidate(17, size3 = $$new_props.size);
    if ("weight" in $$new_props)
      $$invalidate(18, weight = $$new_props.weight);
    if ("gradient" in $$new_props)
      $$invalidate(19, gradient = $$new_props.gradient);
    if ("inline" in $$new_props)
      $$invalidate(20, inline = $$new_props.inline);
    if ("lineClamp" in $$new_props)
      $$invalidate(21, lineClamp = $$new_props.lineClamp);
    if ("underline" in $$new_props)
      $$invalidate(22, underline = $$new_props.underline);
    if ("inherit" in $$new_props)
      $$invalidate(23, inherit = $$new_props.inherit);
    if ("href" in $$new_props)
      $$invalidate(5, href = $$new_props.href);
    if ("tracking" in $$new_props)
      $$invalidate(24, tracking = $$new_props.tracking);
    if ("$$scope" in $$new_props)
      $$invalidate(27, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    get_current_component,
    createEventForwarder,
    useActions,
    Error: Error_default,
    Box: Box_default,
    useStyles: Text_styles_default,
    TextErrors,
    use,
    element: element2,
    className,
    override,
    align,
    color,
    root,
    transform: transform2,
    variant: variant2,
    size: size3,
    weight,
    gradient,
    inline,
    lineClamp,
    underline,
    inherit,
    href,
    tracking,
    forwardEvents,
    observable,
    err,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("align" in $$props)
      $$invalidate(13, align = $$new_props.align);
    if ("color" in $$props)
      $$invalidate(14, color = $$new_props.color);
    if ("root" in $$props)
      $$invalidate(4, root = $$new_props.root);
    if ("transform" in $$props)
      $$invalidate(15, transform2 = $$new_props.transform);
    if ("variant" in $$props)
      $$invalidate(16, variant2 = $$new_props.variant);
    if ("size" in $$props)
      $$invalidate(17, size3 = $$new_props.size);
    if ("weight" in $$props)
      $$invalidate(18, weight = $$new_props.weight);
    if ("gradient" in $$props)
      $$invalidate(19, gradient = $$new_props.gradient);
    if ("inline" in $$props)
      $$invalidate(20, inline = $$new_props.inline);
    if ("lineClamp" in $$props)
      $$invalidate(21, lineClamp = $$new_props.lineClamp);
    if ("underline" in $$props)
      $$invalidate(22, underline = $$new_props.underline);
    if ("inherit" in $$props)
      $$invalidate(23, inherit = $$new_props.inherit);
    if ("href" in $$props)
      $$invalidate(5, href = $$new_props.href);
    if ("tracking" in $$props)
      $$invalidate(24, tracking = $$new_props.tracking);
    if ("observable" in $$props)
      $$invalidate(6, observable = $$new_props.observable);
    if ("err" in $$props)
      $$invalidate(7, err = $$new_props.err);
    if ("getStyles" in $$props)
      $$invalidate(8, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(9, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(10, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*lineClamp, underline, inline, inherit, gradient, variant, align, color, transform, size, weight, tracking*/
    33546240) {
      $:
        $$invalidate(
          10,
          { cx: cx2, classes, getStyles } = Text_styles_default(
            {
              lineClamp,
              underline,
              inline,
              inherit,
              gradient,
              variant: variant2,
              align,
              color,
              transform: transform2,
              size: size3,
              weight,
              tracking
            },
            { name: "Text" }
          ),
          cx2,
          ($$invalidate(9, classes), $$invalidate(21, lineClamp), $$invalidate(22, underline), $$invalidate(20, inline), $$invalidate(23, inherit), $$invalidate(19, gradient), $$invalidate(16, variant2), $$invalidate(13, align), $$invalidate(14, color), $$invalidate(15, transform2), $$invalidate(17, size3), $$invalidate(18, weight), $$invalidate(24, tracking)),
          ($$invalidate(8, getStyles), $$invalidate(21, lineClamp), $$invalidate(22, underline), $$invalidate(20, inline), $$invalidate(23, inherit), $$invalidate(19, gradient), $$invalidate(16, variant2), $$invalidate(13, align), $$invalidate(14, color), $$invalidate(15, transform2), $$invalidate(17, size3), $$invalidate(18, weight), $$invalidate(24, tracking))
        );
    }
  };
  return [
    element2,
    use,
    className,
    override,
    root,
    href,
    observable,
    err,
    getStyles,
    classes,
    cx2,
    forwardEvents,
    $$restProps,
    align,
    color,
    transform2,
    variant2,
    size3,
    weight,
    gradient,
    inline,
    lineClamp,
    underline,
    inherit,
    tracking,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Text = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      align: 13,
      color: 14,
      root: 4,
      transform: 15,
      variant: 16,
      size: 17,
      weight: 18,
      gradient: 19,
      inline: 20,
      lineClamp: 21,
      underline: 22,
      inherit: 23,
      href: 5,
      tracking: 24
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Text",
      options,
      id: create_fragment23.name
    });
  }
  get use() {
    throw new Error_14("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error_14("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error_14("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error_14("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error_14("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error_14("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error_14("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error_14("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error_14("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error_14("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error_14("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error_14("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get root() {
    throw new Error_14("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set root(value) {
    throw new Error_14("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transform() {
    throw new Error_14("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transform(value) {
    throw new Error_14("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error_14("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error_14("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error_14("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error_14("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get weight() {
    throw new Error_14("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set weight(value) {
    throw new Error_14("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gradient() {
    throw new Error_14("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gradient(value) {
    throw new Error_14("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error_14("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error_14("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineClamp() {
    throw new Error_14("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineClamp(value) {
    throw new Error_14("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get underline() {
    throw new Error_14("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set underline(value) {
    throw new Error_14("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inherit() {
    throw new Error_14("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inherit(value) {
    throw new Error_14("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error_14("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error_14("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tracking() {
    throw new Error_14("<Text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tracking(value) {
    throw new Error_14("<Text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Text_default = Text;

// node_modules/@svelteuidev/core/dist/components/Anchor/Anchor.svelte
function fallback_block5(ctx8) {
  let t;
  const block = {
    c: function create() {
      t = text("Enter some anchor text");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Enter some anchor text");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block5.name,
    type: "fallback",
    source: "(44:7) Enter some anchor text",
    ctx: ctx8
  });
  return block;
}
function create_default_slot12(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[23],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block5(ctx8);
  const block = {
    c: function create() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8388608)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[23],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[23]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[23],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot12.name,
    type: "slot",
    source: `(23:0) <Text  bind:element  class={cx(className, classes.root, getStyles({ css: override }))}  variant=\\"link\\"  {use}  {root}  {align}  {color}  {transform}  {weight}  {gradient}  {inline}  {lineClamp}  {underline}  {inherit}  {href}  {tracking}  target={external ? '_blank' : null}  rel={external ? 'noreferrer noopener' : null}  {...$$restProps} >`,
    ctx: ctx8
  });
  return block;
}
function create_fragment24(ctx8) {
  let text_1;
  let updating_element;
  let current;
  const text_1_spread_levels = [
    {
      class: (
        /*cx*/
        ctx8[19](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[18].root,
          /*getStyles*/
          ctx8[17]({ css: (
            /*override*/
            ctx8[3]
          ) })
        )
      )
    },
    { variant: "link" },
    { use: (
      /*use*/
      ctx8[1]
    ) },
    { root: (
      /*root*/
      ctx8[4]
    ) },
    { align: (
      /*align*/
      ctx8[5]
    ) },
    { color: (
      /*color*/
      ctx8[6]
    ) },
    { transform: (
      /*transform*/
      ctx8[7]
    ) },
    { weight: (
      /*weight*/
      ctx8[8]
    ) },
    { gradient: (
      /*gradient*/
      ctx8[9]
    ) },
    { inline: (
      /*inline*/
      ctx8[10]
    ) },
    { lineClamp: (
      /*lineClamp*/
      ctx8[11]
    ) },
    { underline: (
      /*underline*/
      ctx8[12]
    ) },
    { inherit: (
      /*inherit*/
      ctx8[13]
    ) },
    { href: (
      /*href*/
      ctx8[14]
    ) },
    { tracking: (
      /*tracking*/
      ctx8[15]
    ) },
    {
      target: (
        /*external*/
        ctx8[16] ? "_blank" : null
      )
    },
    {
      rel: (
        /*external*/
        ctx8[16] ? "noreferrer noopener" : null
      )
    },
    /*$$restProps*/
    ctx8[20]
  ];
  function text_1_element_binding(value) {
    ctx8[22](value);
  }
  let text_1_props = {
    $$slots: { default: [create_default_slot12] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < text_1_spread_levels.length; i2 += 1) {
    text_1_props = assign(text_1_props, text_1_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    text_1_props.element = /*element*/
    ctx8[0];
  }
  text_1 = new Text_default({ props: text_1_props, $$inline: true });
  binding_callbacks.push(() => bind(text_1, "element", text_1_element_binding));
  const block = {
    c: function create() {
      create_component(text_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(text_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(text_1, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const text_1_changes = dirty & /*cx, className, classes, getStyles, override, use, root, align, color, transform, weight, gradient, inline, lineClamp, underline, inherit, href, tracking, external, $$restProps*/
      2097150 ? get_spread_update(text_1_spread_levels, [
        dirty & /*cx, className, classes, getStyles, override*/
        917516 && {
          class: (
            /*cx*/
            ctx9[19](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[18].root,
              /*getStyles*/
              ctx9[17]({ css: (
                /*override*/
                ctx9[3]
              ) })
            )
          )
        },
        text_1_spread_levels[1],
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*root*/
        16 && { root: (
          /*root*/
          ctx9[4]
        ) },
        dirty & /*align*/
        32 && { align: (
          /*align*/
          ctx9[5]
        ) },
        dirty & /*color*/
        64 && { color: (
          /*color*/
          ctx9[6]
        ) },
        dirty & /*transform*/
        128 && { transform: (
          /*transform*/
          ctx9[7]
        ) },
        dirty & /*weight*/
        256 && { weight: (
          /*weight*/
          ctx9[8]
        ) },
        dirty & /*gradient*/
        512 && { gradient: (
          /*gradient*/
          ctx9[9]
        ) },
        dirty & /*inline*/
        1024 && { inline: (
          /*inline*/
          ctx9[10]
        ) },
        dirty & /*lineClamp*/
        2048 && { lineClamp: (
          /*lineClamp*/
          ctx9[11]
        ) },
        dirty & /*underline*/
        4096 && { underline: (
          /*underline*/
          ctx9[12]
        ) },
        dirty & /*inherit*/
        8192 && { inherit: (
          /*inherit*/
          ctx9[13]
        ) },
        dirty & /*href*/
        16384 && { href: (
          /*href*/
          ctx9[14]
        ) },
        dirty & /*tracking*/
        32768 && { tracking: (
          /*tracking*/
          ctx9[15]
        ) },
        dirty & /*external*/
        65536 && {
          target: (
            /*external*/
            ctx9[16] ? "_blank" : null
          )
        },
        dirty & /*external*/
        65536 && {
          rel: (
            /*external*/
            ctx9[16] ? "noreferrer noopener" : null
          )
        },
        dirty & /*$$restProps*/
        1048576 && get_spread_object(
          /*$$restProps*/
          ctx9[20]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      8388608) {
        text_1_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        text_1_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      text_1.$set(text_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(text_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance24($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "root",
    "align",
    "color",
    "transform",
    "weight",
    "gradient",
    "inline",
    "lineClamp",
    "underline",
    "inherit",
    "href",
    "tracking",
    "external"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Anchor", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, root = "a", align = "left", color = "blue", transform: transform2 = "none", weight = "normal", gradient = { from: "indigo", to: "cyan", deg: 45 }, inline = true, lineClamp = void 0, underline = true, inherit = false, href = "", tracking = "normal", external = false } = $$props;
  function text_1_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(20, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("root" in $$new_props)
      $$invalidate(4, root = $$new_props.root);
    if ("align" in $$new_props)
      $$invalidate(5, align = $$new_props.align);
    if ("color" in $$new_props)
      $$invalidate(6, color = $$new_props.color);
    if ("transform" in $$new_props)
      $$invalidate(7, transform2 = $$new_props.transform);
    if ("weight" in $$new_props)
      $$invalidate(8, weight = $$new_props.weight);
    if ("gradient" in $$new_props)
      $$invalidate(9, gradient = $$new_props.gradient);
    if ("inline" in $$new_props)
      $$invalidate(10, inline = $$new_props.inline);
    if ("lineClamp" in $$new_props)
      $$invalidate(11, lineClamp = $$new_props.lineClamp);
    if ("underline" in $$new_props)
      $$invalidate(12, underline = $$new_props.underline);
    if ("inherit" in $$new_props)
      $$invalidate(13, inherit = $$new_props.inherit);
    if ("href" in $$new_props)
      $$invalidate(14, href = $$new_props.href);
    if ("tracking" in $$new_props)
      $$invalidate(15, tracking = $$new_props.tracking);
    if ("external" in $$new_props)
      $$invalidate(16, external = $$new_props.external);
    if ("$$scope" in $$new_props)
      $$invalidate(23, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: Anchor_styles_default,
    Text: Text_default,
    use,
    element: element2,
    className,
    override,
    root,
    align,
    color,
    transform: transform2,
    weight,
    gradient,
    inline,
    lineClamp,
    underline,
    inherit,
    href,
    tracking,
    external,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("root" in $$props)
      $$invalidate(4, root = $$new_props.root);
    if ("align" in $$props)
      $$invalidate(5, align = $$new_props.align);
    if ("color" in $$props)
      $$invalidate(6, color = $$new_props.color);
    if ("transform" in $$props)
      $$invalidate(7, transform2 = $$new_props.transform);
    if ("weight" in $$props)
      $$invalidate(8, weight = $$new_props.weight);
    if ("gradient" in $$props)
      $$invalidate(9, gradient = $$new_props.gradient);
    if ("inline" in $$props)
      $$invalidate(10, inline = $$new_props.inline);
    if ("lineClamp" in $$props)
      $$invalidate(11, lineClamp = $$new_props.lineClamp);
    if ("underline" in $$props)
      $$invalidate(12, underline = $$new_props.underline);
    if ("inherit" in $$props)
      $$invalidate(13, inherit = $$new_props.inherit);
    if ("href" in $$props)
      $$invalidate(14, href = $$new_props.href);
    if ("tracking" in $$props)
      $$invalidate(15, tracking = $$new_props.tracking);
    if ("external" in $$props)
      $$invalidate(16, external = $$new_props.external);
    if ("getStyles" in $$props)
      $$invalidate(17, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(18, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(19, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $:
    $$invalidate(19, { cx: cx2, classes, getStyles } = Anchor_styles_default(null, { name: "Anchor" }), cx2, $$invalidate(18, classes), $$invalidate(17, getStyles));
  return [
    element2,
    use,
    className,
    override,
    root,
    align,
    color,
    transform2,
    weight,
    gradient,
    inline,
    lineClamp,
    underline,
    inherit,
    href,
    tracking,
    external,
    getStyles,
    classes,
    cx2,
    $$restProps,
    slots,
    text_1_element_binding,
    $$scope
  ];
}
var Anchor = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment24, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      root: 4,
      align: 5,
      color: 6,
      transform: 7,
      weight: 8,
      gradient: 9,
      inline: 10,
      lineClamp: 11,
      underline: 12,
      inherit: 13,
      href: 14,
      tracking: 15,
      external: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Anchor",
      options,
      id: create_fragment24.name
    });
  }
  get use() {
    throw new Error("<Anchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Anchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Anchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Anchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Anchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Anchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Anchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Anchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get root() {
    throw new Error("<Anchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set root(value) {
    throw new Error("<Anchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<Anchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<Anchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Anchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Anchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transform() {
    throw new Error("<Anchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transform(value) {
    throw new Error("<Anchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get weight() {
    throw new Error("<Anchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set weight(value) {
    throw new Error("<Anchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gradient() {
    throw new Error("<Anchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gradient(value) {
    throw new Error("<Anchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error("<Anchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<Anchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineClamp() {
    throw new Error("<Anchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineClamp(value) {
    throw new Error("<Anchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get underline() {
    throw new Error("<Anchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set underline(value) {
    throw new Error("<Anchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inherit() {
    throw new Error("<Anchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inherit(value) {
    throw new Error("<Anchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Anchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Anchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tracking() {
    throw new Error("<Anchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tracking(value) {
    throw new Error("<Anchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get external() {
    throw new Error("<Anchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set external(value) {
    throw new Error("<Anchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Anchor_default = Anchor;

// node_modules/@svelteuidev/core/dist/components/AppShell/HorizontalSection/Section/Section.svelte
function create_default_slot13(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[8],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[8],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot13.name,
    type: "slot",
    source: "(5:0) <Box  bind:element  class={className}  css={{ flex: grow ? 1 : 0, boxSizing: 'border-box', ...override }}  {use}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment25(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { class: (
      /*className*/
      ctx8[2]
    ) },
    {
      css: {
        flex: (
          /*grow*/
          ctx8[4] ? 1 : 0
        ),
        boxSizing: "border-box",
        .../*override*/
        ctx8[3]
      }
    },
    { use: (
      /*use*/
      ctx8[1]
    ) },
    /*$$restProps*/
    ctx8[5]
  ];
  function box_element_binding(value) {
    ctx8[7](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot13] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*className, grow, override, use, $$restProps*/
      62 ? get_spread_update(box_spread_levels, [
        dirty & /*className*/
        4 && { class: (
          /*className*/
          ctx9[2]
        ) },
        dirty & /*grow, override*/
        24 && {
          css: {
            flex: (
              /*grow*/
              ctx9[4] ? 1 : 0
            ),
            boxSizing: "border-box",
            .../*override*/
            ctx9[3]
          }
        },
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*$$restProps*/
        32 && get_spread_object(
          /*$$restProps*/
          ctx9[5]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      256) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance25($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "element", "className", "override", "grow"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Section", slots, ["default"]);
  let { use = [], element: element2 = void 0, className = "", override = {}, grow = false } = $$props;
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$new_props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("grow" in $$new_props)
      $$invalidate(4, grow = $$new_props.grow);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Box: Box_default,
    use,
    element: element2,
    className,
    override,
    grow
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("grow" in $$props)
      $$invalidate(4, grow = $$new_props.grow);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    use,
    className,
    override,
    grow,
    $$restProps,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Section = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance25, create_fragment25, safe_not_equal, {
      use: 1,
      element: 0,
      className: 2,
      override: 3,
      grow: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Section",
      options,
      id: create_fragment25.name
    });
  }
  get use() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get className() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set className(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get grow() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set grow(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Section_default = Section;

// node_modules/@svelteuidev/core/dist/components/AppShell/HorizontalSection/get-sorted-breakpoints/get-sorted-breakpoints.js
var theme2 = {
  spacing: {
    xs: 10,
    sm: 12,
    md: 16,
    lg: 20,
    xl: 24
  },
  breakpoints: {
    xs: 576,
    sm: 768,
    md: 992,
    lg: 1200,
    xl: 1400
  }
};
function getSortedBreakpoints(breakpoints, theme4) {
  if (!breakpoints) {
    return [];
  }
  const values = Object.keys(breakpoints).filter((breakpoint) => breakpoint !== "base").map((breakpoint) => [
    fns.size({ size: breakpoint, sizes: theme4.breakpoints }),
    breakpoints[breakpoint]
  ]);
  values.sort((a, b) => a[0] - b[0]);
  return values;
}

// node_modules/@svelteuidev/core/dist/components/AppShell/HorizontalSection/HorizontalSection.styles.js
var HorizontalSection_styles_default = createStyles((theme4, { height, width, fixed, position, hiddenBreakpoint, zIndex, section, hidden: hidden2 }) => {
  const breakpoints = typeof width === "object" && width !== null ? getSortedBreakpoints(width, theme2).reduce((acc, [breakpoint, breakpointSize]) => {
    acc[`@media (min-width: ${breakpoint + 1}px)`] = {
      width: breakpointSize,
      minWidth: breakpointSize
    };
    return acc;
  }, {}) : null;
  return {
    root: {
      darkMode: {
        backgroundColor: theme4.fn.themeColor("dark", 7),
        [section === "navbar" ? "borderRight" : "borderLeft"]: `1px solid ${theme4.fn.themeColor("dark", 5)}`
      },
      fontFamily: theme4.fonts.standard.value ?? "sans-serif",
      ...position,
      top: (position == null ? void 0 : position.top) || "var(--svelteui-header-height)",
      zIndex,
      height: height || "calc(100vh - var(--svelteui-header-height, 0px) - var(--svelteui-footer-height, 0px))",
      width: (width == null ? void 0 : width.base) || "100%",
      position: fixed ? "fixed" : "static",
      boxSizing: "border-box",
      display: "flex",
      flexDirection: "column",
      backgroundColor: "white",
      [section === "navbar" ? "borderRight" : "borderLeft"]: `1px solid ${theme4.fn.themeColor("gray", 2)}`,
      ...breakpoints,
      [`@media (max-width: ${theme4.fn.size({
        size: hiddenBreakpoint,
        sizes: theme2.breakpoints
      })}px)`]: hidden2 ? {
        display: "none"
      } : {}
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/AppShell/HorizontalSection/HorizontalSection.svelte
function create_default_slot14(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[18],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[18],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot14.name,
    type: "slot",
    source: "(35:0) <Box  {use}  bind:element  root={section === 'navbar' ? 'nav' : 'aside'}  class={cx(className, classes.root, getStyles({ css: override }))}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment26(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { use: (
      /*use*/
      ctx8[1]
    ) },
    {
      root: (
        /*section*/
        ctx8[4] === "navbar" ? "nav" : "aside"
      )
    },
    {
      class: (
        /*cx*/
        ctx8[7](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[6].root,
          /*getStyles*/
          ctx8[5]({ css: (
            /*override*/
            ctx8[3]
          ) })
        )
      )
    },
    /*$$restProps*/
    ctx8[8]
  ];
  function box_element_binding(value) {
    ctx8[17](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot14] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*use, section, cx, className, classes, getStyles, override, $$restProps*/
      510 ? get_spread_update(box_spread_levels, [
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*section*/
        16 && {
          root: (
            /*section*/
            ctx9[4] === "navbar" ? "nav" : "aside"
          )
        },
        dirty & /*cx, className, classes, getStyles, override*/
        236 && {
          class: (
            /*cx*/
            ctx9[7](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[6].root,
              /*getStyles*/
              ctx9[5]({ css: (
                /*override*/
                ctx9[3]
              ) })
            )
          )
        },
        dirty & /*$$restProps*/
        256 && get_spread_object(
          /*$$restProps*/
          ctx9[8]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      262144) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "width",
    "height",
    "fixed",
    "position",
    "hiddenBreakpoint",
    "hidden",
    "zIndex",
    "section"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HorizontalSection", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, width = void 0, height = void 0, fixed = false, position = {}, hiddenBreakpoint = "md", hidden: hidden2 = false, zIndex = 100, section } = $$props;
  const breakpoints = getSortedBreakpoints(width, theme2).reduce(
    (acc, [breakpoint, breakpointSize]) => {
      acc[`@media (min-width: ${breakpoint + 1}px)`] = {
        [`--svelteui-${section}-width`]: `${breakpointSize}px`
      };
      return acc;
    },
    {}
  );
  const injectRoot = globalCss({
    ":root": {
      [`--svelteui-${section}-width`]: (width == null ? void 0 : width.base) ? `${width.base}px` : "0px",
      ...breakpoints
    }
  });
  injectRoot();
  $$self.$$.on_mount.push(function() {
    if (section === void 0 && !("section" in $$props || $$self.$$.bound[$$self.$$.props["section"]])) {
      console.warn("<HorizontalSection> was created without expected prop 'section'");
    }
  });
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("width" in $$new_props)
      $$invalidate(9, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(10, height = $$new_props.height);
    if ("fixed" in $$new_props)
      $$invalidate(11, fixed = $$new_props.fixed);
    if ("position" in $$new_props)
      $$invalidate(12, position = $$new_props.position);
    if ("hiddenBreakpoint" in $$new_props)
      $$invalidate(13, hiddenBreakpoint = $$new_props.hiddenBreakpoint);
    if ("hidden" in $$new_props)
      $$invalidate(14, hidden2 = $$new_props.hidden);
    if ("zIndex" in $$new_props)
      $$invalidate(15, zIndex = $$new_props.zIndex);
    if ("section" in $$new_props)
      $$invalidate(4, section = $$new_props.section);
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: HorizontalSection_styles_default,
    Box: Box_default,
    globalCss,
    getSortedBreakpoints,
    appShellTheme: theme2,
    use,
    element: element2,
    className,
    override,
    width,
    height,
    fixed,
    position,
    hiddenBreakpoint,
    hidden: hidden2,
    zIndex,
    section,
    breakpoints,
    injectRoot,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("width" in $$props)
      $$invalidate(9, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(10, height = $$new_props.height);
    if ("fixed" in $$props)
      $$invalidate(11, fixed = $$new_props.fixed);
    if ("position" in $$props)
      $$invalidate(12, position = $$new_props.position);
    if ("hiddenBreakpoint" in $$props)
      $$invalidate(13, hiddenBreakpoint = $$new_props.hiddenBreakpoint);
    if ("hidden" in $$props)
      $$invalidate(14, hidden2 = $$new_props.hidden);
    if ("zIndex" in $$props)
      $$invalidate(15, zIndex = $$new_props.zIndex);
    if ("section" in $$props)
      $$invalidate(4, section = $$new_props.section);
    if ("getStyles" in $$props)
      $$invalidate(5, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(6, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(7, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*fixed, height, hiddenBreakpoint, position, width, zIndex, section, hidden*/
    65040) {
      $:
        $$invalidate(
          7,
          { cx: cx2, classes, getStyles } = HorizontalSection_styles_default(
            {
              fixed,
              height,
              hiddenBreakpoint,
              position,
              width,
              zIndex,
              section,
              hidden: hidden2
            },
            { name: "HorizontalSection" }
          ),
          cx2,
          ($$invalidate(6, classes), $$invalidate(11, fixed), $$invalidate(10, height), $$invalidate(13, hiddenBreakpoint), $$invalidate(12, position), $$invalidate(9, width), $$invalidate(15, zIndex), $$invalidate(4, section), $$invalidate(14, hidden2)),
          ($$invalidate(5, getStyles), $$invalidate(11, fixed), $$invalidate(10, height), $$invalidate(13, hiddenBreakpoint), $$invalidate(12, position), $$invalidate(9, width), $$invalidate(15, zIndex), $$invalidate(4, section), $$invalidate(14, hidden2))
        );
    }
  };
  return [
    element2,
    use,
    className,
    override,
    section,
    getStyles,
    classes,
    cx2,
    $$restProps,
    width,
    height,
    fixed,
    position,
    hiddenBreakpoint,
    hidden2,
    zIndex,
    slots,
    box_element_binding,
    $$scope
  ];
}
var HorizontalSection = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      width: 9,
      height: 10,
      fixed: 11,
      position: 12,
      hiddenBreakpoint: 13,
      hidden: 14,
      zIndex: 15,
      section: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HorizontalSection",
      options,
      id: create_fragment26.name
    });
  }
  get use() {
    throw new Error("<HorizontalSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<HorizontalSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<HorizontalSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<HorizontalSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<HorizontalSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<HorizontalSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<HorizontalSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<HorizontalSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<HorizontalSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<HorizontalSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<HorizontalSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<HorizontalSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fixed() {
    throw new Error("<HorizontalSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fixed(value) {
    throw new Error("<HorizontalSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<HorizontalSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<HorizontalSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hiddenBreakpoint() {
    throw new Error("<HorizontalSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hiddenBreakpoint(value) {
    throw new Error("<HorizontalSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hidden() {
    throw new Error("<HorizontalSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hidden(value) {
    throw new Error("<HorizontalSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<HorizontalSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<HorizontalSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get section() {
    throw new Error("<HorizontalSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set section(value) {
    throw new Error("<HorizontalSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HorizontalSection_default = HorizontalSection;

// node_modules/@svelteuidev/core/dist/components/AppShell/Navbar/Navbar.svelte
function create_default_slot15(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[14],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[14],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot15.name,
    type: "slot",
    source: '(6:0) <HorizontalSection  section=\\"navbar\\"  bind:element  class={className}  {use}  {override}  {width}  {height}  {fixed}  {position}  {hiddenBreakpoint}  {hidden}  {zIndex}  {...$$restProps} >',
    ctx: ctx8
  });
  return block;
}
function create_fragment27(ctx8) {
  let horizontalsection;
  let updating_element;
  let current;
  const horizontalsection_spread_levels = [
    { section: "navbar" },
    { class: (
      /*className*/
      ctx8[2]
    ) },
    { use: (
      /*use*/
      ctx8[1]
    ) },
    { override: (
      /*override*/
      ctx8[3]
    ) },
    { width: (
      /*width*/
      ctx8[4]
    ) },
    { height: (
      /*height*/
      ctx8[5]
    ) },
    { fixed: (
      /*fixed*/
      ctx8[6]
    ) },
    { position: (
      /*position*/
      ctx8[7]
    ) },
    {
      hiddenBreakpoint: (
        /*hiddenBreakpoint*/
        ctx8[8]
      )
    },
    { hidden: (
      /*hidden*/
      ctx8[9]
    ) },
    { zIndex: (
      /*zIndex*/
      ctx8[10]
    ) },
    /*$$restProps*/
    ctx8[11]
  ];
  function horizontalsection_element_binding(value) {
    ctx8[13](value);
  }
  let horizontalsection_props = {
    $$slots: { default: [create_default_slot15] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < horizontalsection_spread_levels.length; i2 += 1) {
    horizontalsection_props = assign(horizontalsection_props, horizontalsection_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    horizontalsection_props.element = /*element*/
    ctx8[0];
  }
  horizontalsection = new HorizontalSection_default({
    props: horizontalsection_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(horizontalsection, "element", horizontalsection_element_binding));
  const block = {
    c: function create() {
      create_component(horizontalsection.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(horizontalsection.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(horizontalsection, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const horizontalsection_changes = dirty & /*className, use, override, width, height, fixed, position, hiddenBreakpoint, hidden, zIndex, $$restProps*/
      4094 ? get_spread_update(horizontalsection_spread_levels, [
        horizontalsection_spread_levels[0],
        dirty & /*className*/
        4 && { class: (
          /*className*/
          ctx9[2]
        ) },
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*override*/
        8 && { override: (
          /*override*/
          ctx9[3]
        ) },
        dirty & /*width*/
        16 && { width: (
          /*width*/
          ctx9[4]
        ) },
        dirty & /*height*/
        32 && { height: (
          /*height*/
          ctx9[5]
        ) },
        dirty & /*fixed*/
        64 && { fixed: (
          /*fixed*/
          ctx9[6]
        ) },
        dirty & /*position*/
        128 && { position: (
          /*position*/
          ctx9[7]
        ) },
        dirty & /*hiddenBreakpoint*/
        256 && {
          hiddenBreakpoint: (
            /*hiddenBreakpoint*/
            ctx9[8]
          )
        },
        dirty & /*hidden*/
        512 && { hidden: (
          /*hidden*/
          ctx9[9]
        ) },
        dirty & /*zIndex*/
        1024 && { zIndex: (
          /*zIndex*/
          ctx9[10]
        ) },
        dirty & /*$$restProps*/
        2048 && get_spread_object(
          /*$$restProps*/
          ctx9[11]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      16384) {
        horizontalsection_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        horizontalsection_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      horizontalsection.$set(horizontalsection_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(horizontalsection.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(horizontalsection.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(horizontalsection, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance27($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "width",
    "height",
    "fixed",
    "position",
    "hiddenBreakpoint",
    "hidden",
    "zIndex"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Navbar", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, width = void 0, height = void 0, fixed = true, position = { top: 0, left: 0 }, hiddenBreakpoint = "md", hidden: hidden2 = false, zIndex = 100 } = $$props;
  function horizontalsection_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("width" in $$new_props)
      $$invalidate(4, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(5, height = $$new_props.height);
    if ("fixed" in $$new_props)
      $$invalidate(6, fixed = $$new_props.fixed);
    if ("position" in $$new_props)
      $$invalidate(7, position = $$new_props.position);
    if ("hiddenBreakpoint" in $$new_props)
      $$invalidate(8, hiddenBreakpoint = $$new_props.hiddenBreakpoint);
    if ("hidden" in $$new_props)
      $$invalidate(9, hidden2 = $$new_props.hidden);
    if ("zIndex" in $$new_props)
      $$invalidate(10, zIndex = $$new_props.zIndex);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    HorizontalSection: HorizontalSection_default,
    use,
    element: element2,
    className,
    override,
    width,
    height,
    fixed,
    position,
    hiddenBreakpoint,
    hidden: hidden2,
    zIndex
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("width" in $$props)
      $$invalidate(4, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(5, height = $$new_props.height);
    if ("fixed" in $$props)
      $$invalidate(6, fixed = $$new_props.fixed);
    if ("position" in $$props)
      $$invalidate(7, position = $$new_props.position);
    if ("hiddenBreakpoint" in $$props)
      $$invalidate(8, hiddenBreakpoint = $$new_props.hiddenBreakpoint);
    if ("hidden" in $$props)
      $$invalidate(9, hidden2 = $$new_props.hidden);
    if ("zIndex" in $$props)
      $$invalidate(10, zIndex = $$new_props.zIndex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    use,
    className,
    override,
    width,
    height,
    fixed,
    position,
    hiddenBreakpoint,
    hidden2,
    zIndex,
    $$restProps,
    slots,
    horizontalsection_element_binding,
    $$scope
  ];
}
var Navbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment27, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      width: 4,
      height: 5,
      fixed: 6,
      position: 7,
      hiddenBreakpoint: 8,
      hidden: 9,
      zIndex: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Navbar",
      options,
      id: create_fragment27.name
    });
  }
  get use() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fixed() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fixed(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hiddenBreakpoint() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hiddenBreakpoint(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hidden() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hidden(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Navbar_default = Navbar;

// node_modules/@svelteuidev/core/dist/components/AppShell/VerticalSection/VerticalSection.styles.js
var VerticalSection_styles_default = createStyles((theme4, { height, borderPosition, fixed, position, zIndex }) => {
  return {
    root: {
      [`${theme4.dark} &`]: {
        backgroundColor: theme4.fn.themeColor("dark", 7),
        borderBottom: borderPosition === "bottom" ? `1px solid ${theme4.fn.themeColor("dark", 5)}` : void 0,
        borderTop: borderPosition === "top" ? `1px solid ${theme4.fn.themeColor("dark", 5)}` : void 0
      },
      ...position,
      zIndex,
      height,
      fontFamily: theme4.fonts.standard.value ?? "sans-serif",
      maxHeight: height,
      position: fixed ? "fixed" : "static",
      boxSizing: "border-box",
      backgroundColor: "white",
      borderBottom: borderPosition === "bottom" ? `1px solid ${theme4.fn.themeColor("gray", 2)}` : void 0,
      borderTop: borderPosition === "top" ? `1px solid ${theme4.fn.themeColor("gray", 2)}` : void 0
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/AppShell/VerticalSection/VerticalSection.svelte
function create_default_slot16(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[15],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[15],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot16.name,
    type: "slot",
    source: "(21:0) <Box  {use}  bind:element  root={section === 'header' ? 'nav' : 'footer'}  class={cx(className, classes.root, getStyles({ css: override }))}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment28(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { use: (
      /*use*/
      ctx8[1]
    ) },
    {
      root: (
        /*section*/
        ctx8[4] === "header" ? "nav" : "footer"
      )
    },
    {
      class: (
        /*cx*/
        ctx8[7](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[6].root,
          /*getStyles*/
          ctx8[5]({ css: (
            /*override*/
            ctx8[3]
          ) })
        )
      )
    },
    /*$$restProps*/
    ctx8[8]
  ];
  function box_element_binding(value) {
    ctx8[14](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot16] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*use, section, cx, className, classes, getStyles, override, $$restProps*/
      510 ? get_spread_update(box_spread_levels, [
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*section*/
        16 && {
          root: (
            /*section*/
            ctx9[4] === "header" ? "nav" : "footer"
          )
        },
        dirty & /*cx, className, classes, getStyles, override*/
        236 && {
          class: (
            /*cx*/
            ctx9[7](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[6].root,
              /*getStyles*/
              ctx9[5]({ css: (
                /*override*/
                ctx9[3]
              ) })
            )
          )
        },
        dirty & /*$$restProps*/
        256 && get_spread_object(
          /*$$restProps*/
          ctx9[8]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      32768) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance28($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "height",
    "fixed",
    "position",
    "zIndex",
    "section"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("VerticalSection", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, height = void 0, fixed = false, position = {}, zIndex = 100, section } = $$props;
  const injectStyles2 = globalCss({
    ":root": {
      [`--svelteui-${section}-height`]: `${height}px`
    }
  });
  injectStyles2();
  $$self.$$.on_mount.push(function() {
    if (section === void 0 && !("section" in $$props || $$self.$$.bound[$$self.$$.props["section"]])) {
      console.warn("<VerticalSection> was created without expected prop 'section'");
    }
  });
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("height" in $$new_props)
      $$invalidate(9, height = $$new_props.height);
    if ("fixed" in $$new_props)
      $$invalidate(10, fixed = $$new_props.fixed);
    if ("position" in $$new_props)
      $$invalidate(11, position = $$new_props.position);
    if ("zIndex" in $$new_props)
      $$invalidate(12, zIndex = $$new_props.zIndex);
    if ("section" in $$new_props)
      $$invalidate(4, section = $$new_props.section);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: VerticalSection_styles_default,
    Box: Box_default,
    globalCss,
    use,
    element: element2,
    className,
    override,
    height,
    fixed,
    position,
    zIndex,
    section,
    injectStyles: injectStyles2,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("height" in $$props)
      $$invalidate(9, height = $$new_props.height);
    if ("fixed" in $$props)
      $$invalidate(10, fixed = $$new_props.fixed);
    if ("position" in $$props)
      $$invalidate(11, position = $$new_props.position);
    if ("zIndex" in $$props)
      $$invalidate(12, zIndex = $$new_props.zIndex);
    if ("section" in $$props)
      $$invalidate(4, section = $$new_props.section);
    if ("getStyles" in $$props)
      $$invalidate(5, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(6, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(7, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*section, fixed, height, position, zIndex*/
    7696) {
      $:
        $$invalidate(
          7,
          { cx: cx2, classes, getStyles } = VerticalSection_styles_default(
            {
              borderPosition: section === "header" ? "bottom" : "top",
              fixed,
              height,
              position,
              zIndex
            },
            { name: "VerticalSection" }
          ),
          cx2,
          ($$invalidate(6, classes), $$invalidate(4, section), $$invalidate(10, fixed), $$invalidate(9, height), $$invalidate(11, position), $$invalidate(12, zIndex)),
          ($$invalidate(5, getStyles), $$invalidate(4, section), $$invalidate(10, fixed), $$invalidate(9, height), $$invalidate(11, position), $$invalidate(12, zIndex))
        );
    }
  };
  return [
    element2,
    use,
    className,
    override,
    section,
    getStyles,
    classes,
    cx2,
    $$restProps,
    height,
    fixed,
    position,
    zIndex,
    slots,
    box_element_binding,
    $$scope
  ];
}
var VerticalSection = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance28, create_fragment28, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      height: 9,
      fixed: 10,
      position: 11,
      zIndex: 12,
      section: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "VerticalSection",
      options,
      id: create_fragment28.name
    });
  }
  get use() {
    throw new Error("<VerticalSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<VerticalSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<VerticalSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<VerticalSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<VerticalSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<VerticalSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<VerticalSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<VerticalSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<VerticalSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<VerticalSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fixed() {
    throw new Error("<VerticalSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fixed(value) {
    throw new Error("<VerticalSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<VerticalSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<VerticalSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<VerticalSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<VerticalSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get section() {
    throw new Error("<VerticalSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set section(value) {
    throw new Error("<VerticalSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var VerticalSection_default = VerticalSection;

// node_modules/@svelteuidev/core/dist/components/AppShell/Header/Header.svelte
function create_default_slot17(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[11],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[11],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot17.name,
    type: "slot",
    source: '(6:0) <VerticalSection  bind:element  section=\\"header\\"  class={className}  {use}  {override}  {height}  {fixed}  {position}  {zIndex}  {...$$restProps} >',
    ctx: ctx8
  });
  return block;
}
function create_fragment29(ctx8) {
  let verticalsection;
  let updating_element;
  let current;
  const verticalsection_spread_levels = [
    { section: "header" },
    { class: (
      /*className*/
      ctx8[2]
    ) },
    { use: (
      /*use*/
      ctx8[1]
    ) },
    { override: (
      /*override*/
      ctx8[3]
    ) },
    { height: (
      /*height*/
      ctx8[4]
    ) },
    { fixed: (
      /*fixed*/
      ctx8[5]
    ) },
    { position: (
      /*position*/
      ctx8[6]
    ) },
    { zIndex: (
      /*zIndex*/
      ctx8[7]
    ) },
    /*$$restProps*/
    ctx8[8]
  ];
  function verticalsection_element_binding(value) {
    ctx8[10](value);
  }
  let verticalsection_props = {
    $$slots: { default: [create_default_slot17] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < verticalsection_spread_levels.length; i2 += 1) {
    verticalsection_props = assign(verticalsection_props, verticalsection_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    verticalsection_props.element = /*element*/
    ctx8[0];
  }
  verticalsection = new VerticalSection_default({
    props: verticalsection_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(verticalsection, "element", verticalsection_element_binding));
  const block = {
    c: function create() {
      create_component(verticalsection.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(verticalsection.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(verticalsection, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const verticalsection_changes = dirty & /*className, use, override, height, fixed, position, zIndex, $$restProps*/
      510 ? get_spread_update(verticalsection_spread_levels, [
        verticalsection_spread_levels[0],
        dirty & /*className*/
        4 && { class: (
          /*className*/
          ctx9[2]
        ) },
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*override*/
        8 && { override: (
          /*override*/
          ctx9[3]
        ) },
        dirty & /*height*/
        16 && { height: (
          /*height*/
          ctx9[4]
        ) },
        dirty & /*fixed*/
        32 && { fixed: (
          /*fixed*/
          ctx9[5]
        ) },
        dirty & /*position*/
        64 && { position: (
          /*position*/
          ctx9[6]
        ) },
        dirty & /*zIndex*/
        128 && { zIndex: (
          /*zIndex*/
          ctx9[7]
        ) },
        dirty & /*$$restProps*/
        256 && get_spread_object(
          /*$$restProps*/
          ctx9[8]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      2048) {
        verticalsection_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        verticalsection_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      verticalsection.$set(verticalsection_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(verticalsection.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(verticalsection.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(verticalsection, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance29($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "element", "class", "override", "height", "fixed", "position", "zIndex"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Header", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, height = void 0, fixed = false, position = { top: 0, left: 0, right: 0 }, zIndex = 100 } = $$props;
  function verticalsection_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("height" in $$new_props)
      $$invalidate(4, height = $$new_props.height);
    if ("fixed" in $$new_props)
      $$invalidate(5, fixed = $$new_props.fixed);
    if ("position" in $$new_props)
      $$invalidate(6, position = $$new_props.position);
    if ("zIndex" in $$new_props)
      $$invalidate(7, zIndex = $$new_props.zIndex);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    VerticalSection: VerticalSection_default,
    use,
    element: element2,
    className,
    override,
    height,
    fixed,
    position,
    zIndex
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("height" in $$props)
      $$invalidate(4, height = $$new_props.height);
    if ("fixed" in $$props)
      $$invalidate(5, fixed = $$new_props.fixed);
    if ("position" in $$props)
      $$invalidate(6, position = $$new_props.position);
    if ("zIndex" in $$props)
      $$invalidate(7, zIndex = $$new_props.zIndex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    use,
    className,
    override,
    height,
    fixed,
    position,
    zIndex,
    $$restProps,
    slots,
    verticalsection_element_binding,
    $$scope
  ];
}
var Header = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance29, create_fragment29, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      height: 4,
      fixed: 5,
      position: 6,
      zIndex: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Header",
      options,
      id: create_fragment29.name
    });
  }
  get use() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fixed() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fixed(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Header_default = Header;

// node_modules/@svelteuidev/core/dist/components/AppShell/Aside/Aside.svelte
function create_default_slot18(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[14],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[14],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot18.name,
    type: "slot",
    source: '(6:0) <HorizontalSection  section=\\"aside\\"  bind:element  class={className}  {use}  {override}  {width}  {height}  {fixed}  {position}  {hiddenBreakpoint}  {hidden}  {zIndex}  {...$$restProps} >',
    ctx: ctx8
  });
  return block;
}
function create_fragment30(ctx8) {
  let horizontalsection;
  let updating_element;
  let current;
  const horizontalsection_spread_levels = [
    { section: "aside" },
    { class: (
      /*className*/
      ctx8[2]
    ) },
    { use: (
      /*use*/
      ctx8[1]
    ) },
    { override: (
      /*override*/
      ctx8[3]
    ) },
    { width: (
      /*width*/
      ctx8[4]
    ) },
    { height: (
      /*height*/
      ctx8[5]
    ) },
    { fixed: (
      /*fixed*/
      ctx8[6]
    ) },
    { position: (
      /*position*/
      ctx8[7]
    ) },
    {
      hiddenBreakpoint: (
        /*hiddenBreakpoint*/
        ctx8[8]
      )
    },
    { hidden: (
      /*hidden*/
      ctx8[9]
    ) },
    { zIndex: (
      /*zIndex*/
      ctx8[10]
    ) },
    /*$$restProps*/
    ctx8[11]
  ];
  function horizontalsection_element_binding(value) {
    ctx8[13](value);
  }
  let horizontalsection_props = {
    $$slots: { default: [create_default_slot18] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < horizontalsection_spread_levels.length; i2 += 1) {
    horizontalsection_props = assign(horizontalsection_props, horizontalsection_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    horizontalsection_props.element = /*element*/
    ctx8[0];
  }
  horizontalsection = new HorizontalSection_default({
    props: horizontalsection_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(horizontalsection, "element", horizontalsection_element_binding));
  const block = {
    c: function create() {
      create_component(horizontalsection.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(horizontalsection.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(horizontalsection, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const horizontalsection_changes = dirty & /*className, use, override, width, height, fixed, position, hiddenBreakpoint, hidden, zIndex, $$restProps*/
      4094 ? get_spread_update(horizontalsection_spread_levels, [
        horizontalsection_spread_levels[0],
        dirty & /*className*/
        4 && { class: (
          /*className*/
          ctx9[2]
        ) },
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*override*/
        8 && { override: (
          /*override*/
          ctx9[3]
        ) },
        dirty & /*width*/
        16 && { width: (
          /*width*/
          ctx9[4]
        ) },
        dirty & /*height*/
        32 && { height: (
          /*height*/
          ctx9[5]
        ) },
        dirty & /*fixed*/
        64 && { fixed: (
          /*fixed*/
          ctx9[6]
        ) },
        dirty & /*position*/
        128 && { position: (
          /*position*/
          ctx9[7]
        ) },
        dirty & /*hiddenBreakpoint*/
        256 && {
          hiddenBreakpoint: (
            /*hiddenBreakpoint*/
            ctx9[8]
          )
        },
        dirty & /*hidden*/
        512 && { hidden: (
          /*hidden*/
          ctx9[9]
        ) },
        dirty & /*zIndex*/
        1024 && { zIndex: (
          /*zIndex*/
          ctx9[10]
        ) },
        dirty & /*$$restProps*/
        2048 && get_spread_object(
          /*$$restProps*/
          ctx9[11]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      16384) {
        horizontalsection_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        horizontalsection_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      horizontalsection.$set(horizontalsection_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(horizontalsection.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(horizontalsection.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(horizontalsection, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance30($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "width",
    "height",
    "fixed",
    "position",
    "hiddenBreakpoint",
    "hidden",
    "zIndex"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Aside", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, width = void 0, height = void 0, fixed = false, position = { top: 0, right: 0 }, hiddenBreakpoint = "md", hidden: hidden2 = false, zIndex = 100 } = $$props;
  function horizontalsection_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("width" in $$new_props)
      $$invalidate(4, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(5, height = $$new_props.height);
    if ("fixed" in $$new_props)
      $$invalidate(6, fixed = $$new_props.fixed);
    if ("position" in $$new_props)
      $$invalidate(7, position = $$new_props.position);
    if ("hiddenBreakpoint" in $$new_props)
      $$invalidate(8, hiddenBreakpoint = $$new_props.hiddenBreakpoint);
    if ("hidden" in $$new_props)
      $$invalidate(9, hidden2 = $$new_props.hidden);
    if ("zIndex" in $$new_props)
      $$invalidate(10, zIndex = $$new_props.zIndex);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    HorizontalSection: HorizontalSection_default,
    use,
    element: element2,
    className,
    override,
    width,
    height,
    fixed,
    position,
    hiddenBreakpoint,
    hidden: hidden2,
    zIndex
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("width" in $$props)
      $$invalidate(4, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(5, height = $$new_props.height);
    if ("fixed" in $$props)
      $$invalidate(6, fixed = $$new_props.fixed);
    if ("position" in $$props)
      $$invalidate(7, position = $$new_props.position);
    if ("hiddenBreakpoint" in $$props)
      $$invalidate(8, hiddenBreakpoint = $$new_props.hiddenBreakpoint);
    if ("hidden" in $$props)
      $$invalidate(9, hidden2 = $$new_props.hidden);
    if ("zIndex" in $$props)
      $$invalidate(10, zIndex = $$new_props.zIndex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    use,
    className,
    override,
    width,
    height,
    fixed,
    position,
    hiddenBreakpoint,
    hidden2,
    zIndex,
    $$restProps,
    slots,
    horizontalsection_element_binding,
    $$scope
  ];
}
var Aside = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      width: 4,
      height: 5,
      fixed: 6,
      position: 7,
      hiddenBreakpoint: 8,
      hidden: 9,
      zIndex: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Aside",
      options,
      id: create_fragment30.name
    });
  }
  get use() {
    throw new Error("<Aside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Aside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Aside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Aside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Aside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Aside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Aside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Aside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Aside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Aside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Aside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Aside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fixed() {
    throw new Error("<Aside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fixed(value) {
    throw new Error("<Aside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Aside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Aside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hiddenBreakpoint() {
    throw new Error("<Aside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hiddenBreakpoint(value) {
    throw new Error("<Aside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hidden() {
    throw new Error("<Aside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hidden(value) {
    throw new Error("<Aside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Aside>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Aside>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Aside_default = Aside;

// node_modules/@svelteuidev/core/dist/components/AppShell/Footer/Footer.svelte
function create_default_slot19(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[11],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[11],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot19.name,
    type: "slot",
    source: '(6:0) <VerticalSection  bind:element  section=\\"footer\\"  class={className}  {use}  {override}  {height}  {fixed}  {position}  {zIndex}  {...$$restProps} >',
    ctx: ctx8
  });
  return block;
}
function create_fragment31(ctx8) {
  let verticalsection;
  let updating_element;
  let current;
  const verticalsection_spread_levels = [
    { section: "footer" },
    { class: (
      /*className*/
      ctx8[2]
    ) },
    { use: (
      /*use*/
      ctx8[1]
    ) },
    { override: (
      /*override*/
      ctx8[3]
    ) },
    { height: (
      /*height*/
      ctx8[4]
    ) },
    { fixed: (
      /*fixed*/
      ctx8[5]
    ) },
    { position: (
      /*position*/
      ctx8[6]
    ) },
    { zIndex: (
      /*zIndex*/
      ctx8[7]
    ) },
    /*$$restProps*/
    ctx8[8]
  ];
  function verticalsection_element_binding(value) {
    ctx8[10](value);
  }
  let verticalsection_props = {
    $$slots: { default: [create_default_slot19] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < verticalsection_spread_levels.length; i2 += 1) {
    verticalsection_props = assign(verticalsection_props, verticalsection_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    verticalsection_props.element = /*element*/
    ctx8[0];
  }
  verticalsection = new VerticalSection_default({
    props: verticalsection_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(verticalsection, "element", verticalsection_element_binding));
  const block = {
    c: function create() {
      create_component(verticalsection.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(verticalsection.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(verticalsection, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const verticalsection_changes = dirty & /*className, use, override, height, fixed, position, zIndex, $$restProps*/
      510 ? get_spread_update(verticalsection_spread_levels, [
        verticalsection_spread_levels[0],
        dirty & /*className*/
        4 && { class: (
          /*className*/
          ctx9[2]
        ) },
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*override*/
        8 && { override: (
          /*override*/
          ctx9[3]
        ) },
        dirty & /*height*/
        16 && { height: (
          /*height*/
          ctx9[4]
        ) },
        dirty & /*fixed*/
        32 && { fixed: (
          /*fixed*/
          ctx9[5]
        ) },
        dirty & /*position*/
        64 && { position: (
          /*position*/
          ctx9[6]
        ) },
        dirty & /*zIndex*/
        128 && { zIndex: (
          /*zIndex*/
          ctx9[7]
        ) },
        dirty & /*$$restProps*/
        256 && get_spread_object(
          /*$$restProps*/
          ctx9[8]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      2048) {
        verticalsection_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        verticalsection_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      verticalsection.$set(verticalsection_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(verticalsection.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(verticalsection.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(verticalsection, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance31($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "element", "class", "override", "height", "fixed", "position", "zIndex"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Footer", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, height = void 0, fixed = false, position = { bottom: 0, left: 0, right: 0 }, zIndex = 100 } = $$props;
  function verticalsection_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("height" in $$new_props)
      $$invalidate(4, height = $$new_props.height);
    if ("fixed" in $$new_props)
      $$invalidate(5, fixed = $$new_props.fixed);
    if ("position" in $$new_props)
      $$invalidate(6, position = $$new_props.position);
    if ("zIndex" in $$new_props)
      $$invalidate(7, zIndex = $$new_props.zIndex);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    VerticalSection: VerticalSection_default,
    use,
    element: element2,
    className,
    override,
    height,
    fixed,
    position,
    zIndex
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("height" in $$props)
      $$invalidate(4, height = $$new_props.height);
    if ("fixed" in $$props)
      $$invalidate(5, fixed = $$new_props.fixed);
    if ("position" in $$props)
      $$invalidate(6, position = $$new_props.position);
    if ("zIndex" in $$props)
      $$invalidate(7, zIndex = $$new_props.zIndex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    use,
    className,
    override,
    height,
    fixed,
    position,
    zIndex,
    $$restProps,
    slots,
    verticalsection_element_binding,
    $$scope
  ];
}
var Footer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance31, create_fragment31, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      height: 4,
      fixed: 5,
      position: 6,
      zIndex: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Footer",
      options,
      id: create_fragment31.name
    });
  }
  get use() {
    throw new Error("<Footer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Footer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Footer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Footer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Footer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Footer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Footer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Footer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Footer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Footer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fixed() {
    throw new Error("<Footer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fixed(value) {
    throw new Error("<Footer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Footer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Footer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Footer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Footer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Footer_default = Footer;

// node_modules/@svelteuidev/core/dist/components/AppShell/AppShell.styles.js
function getPositionStyles(props, theme4) {
  const padding3 = fns.size({ size: props.padding, sizes: theme4.spacing });
  const navbarOffset = props.navbarOffsetBreakpoint ? fns.size({ size: props.navbarOffsetBreakpoint, sizes: theme4.breakpoints }) : null;
  const asideOffset = props.asideOffsetBreakpoint ? fns.size({ size: props.asideOffsetBreakpoint, sizes: theme4.breakpoints }) : null;
  if (!props.fixed) {
    return { padding: padding3 };
  }
  return {
    minHeight: "100vh",
    paddingTop: `calc(var(--svelteui-header-height, 0px) + ${padding3}px)`,
    paddingBottom: `calc(var(--svelteui-footer-height, 0px) + ${padding3}px)`,
    paddingLeft: `calc(var(--svelteui-navbar-width, 0px) + ${padding3}px)`,
    paddingRight: `calc(var(--svelteui-aside-width, 0px) + ${padding3}px)`,
    [`@media (max-width: ${navbarOffset}px)`]: {
      paddingLeft: padding3
    },
    [`@media (max-width: ${asideOffset}px)`]: {
      paddingRight: padding3
    }
  };
}
var AppShell_styles_default = createStyles((_, props) => {
  return {
    root: {
      boxSizing: "border-box"
    },
    body: {
      display: "flex",
      boxSizing: "border-box"
    },
    main: {
      flex: 1,
      width: "100vw",
      boxSizing: "border-box",
      ...getPositionStyles(props, theme2)
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/AppShell/AppShellProvider.svelte
function create_default_slot20(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[8],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[8],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot20.name,
    type: "slot",
    source: "(8:0) <Box bind:element class={className} css={{ ...override }} {use} {...$$restProps}>",
    ctx: ctx8
  });
  return block;
}
function create_fragment32(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { class: (
      /*className*/
      ctx8[2]
    ) },
    { css: { .../*override*/
    ctx8[3] } },
    { use: (
      /*use*/
      ctx8[1]
    ) },
    /*$$restProps*/
    ctx8[4]
  ];
  function box_element_binding(value) {
    ctx8[7](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot20] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*className, override, use, $$restProps*/
      30 ? get_spread_update(box_spread_levels, [
        dirty & /*className*/
        4 && { class: (
          /*className*/
          ctx9[2]
        ) },
        dirty & /*override*/
        8 && { css: { .../*override*/
        ctx9[3] } },
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx9[4]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      256) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance32($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "element", "class", "override", "value"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AppShellProvider", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, value } = $$props;
  const noop2 = () => value;
  noop2();
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<AppShellProvider> was created without expected prop 'value'");
    }
  });
  function box_element_binding(value2) {
    element2 = value2;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("value" in $$new_props)
      $$invalidate(5, value = $$new_props.value);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Box: Box_default,
    use,
    element: element2,
    className,
    override,
    value,
    noop: noop2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("value" in $$props)
      $$invalidate(5, value = $$new_props.value);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    use,
    className,
    override,
    $$restProps,
    value,
    slots,
    box_element_binding,
    $$scope
  ];
}
var AppShellProvider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment32, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      value: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AppShellProvider",
      options,
      id: create_fragment32.name
    });
  }
  get use() {
    throw new Error("<AppShellProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<AppShellProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<AppShellProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<AppShellProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<AppShellProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<AppShellProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<AppShellProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<AppShellProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<AppShellProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<AppShellProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AppShellProvider_default = AppShellProvider;

// node_modules/@svelteuidev/core/dist/components/AppShell/AppShell.svelte
var file15 = "node_modules/@svelteuidev/core/dist/components/AppShell/AppShell.svelte";
var get_footer_slot_changes = (dirty) => ({});
var get_footer_slot_context = (ctx8) => ({});
var get_aside_slot_changes = (dirty) => ({});
var get_aside_slot_context = (ctx8) => ({});
var get_navbar_slot_changes = (dirty) => ({});
var get_navbar_slot_context = (ctx8) => ({});
var get_header_slot_changes = (dirty) => ({});
var get_header_slot_context = (ctx8) => ({});
function create_if_block_32(ctx8) {
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx8[12].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[14],
    get_header_slot_context
  );
  const block = {
    c: function create() {
      if (header_slot)
        header_slot.c();
    },
    l: function claim(nodes) {
      if (header_slot)
        header_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (header_slot) {
        header_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[14]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx9[14],
              dirty,
              get_header_slot_changes
            ),
            get_header_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(20:2) {#if $$slots.header}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_24(ctx8) {
  let current;
  const navbar_slot_template = (
    /*#slots*/
    ctx8[12].navbar
  );
  const navbar_slot = create_slot(
    navbar_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[14],
    get_navbar_slot_context
  );
  const block = {
    c: function create() {
      if (navbar_slot)
        navbar_slot.c();
    },
    l: function claim(nodes) {
      if (navbar_slot)
        navbar_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (navbar_slot) {
        navbar_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (navbar_slot) {
        if (navbar_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            navbar_slot,
            navbar_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[14]
            ) : get_slot_changes(
              navbar_slot_template,
              /*$$scope*/
              ctx9[14],
              dirty,
              get_navbar_slot_changes
            ),
            get_navbar_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(navbar_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(navbar_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (navbar_slot)
        navbar_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_24.name,
    type: "if",
    source: "(24:3) {#if $$slots.navbar}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_16(ctx8) {
  let current;
  const aside_slot_template = (
    /*#slots*/
    ctx8[12].aside
  );
  const aside_slot = create_slot(
    aside_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[14],
    get_aside_slot_context
  );
  const block = {
    c: function create() {
      if (aside_slot)
        aside_slot.c();
    },
    l: function claim(nodes) {
      if (aside_slot)
        aside_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (aside_slot) {
        aside_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (aside_slot) {
        if (aside_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            aside_slot,
            aside_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[14]
            ) : get_slot_changes(
              aside_slot_template,
              /*$$scope*/
              ctx9[14],
              dirty,
              get_aside_slot_changes
            ),
            get_aside_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(aside_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(aside_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (aside_slot)
        aside_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_16.name,
    type: "if",
    source: "(30:3) {#if $$slots.aside}",
    ctx: ctx8
  });
  return block;
}
function create_if_block9(ctx8) {
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx8[12].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[14],
    get_footer_slot_context
  );
  const block = {
    c: function create() {
      if (footer_slot)
        footer_slot.c();
    },
    l: function claim(nodes) {
      if (footer_slot)
        footer_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (footer_slot) {
        footer_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[14]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx9[14],
              dirty,
              get_footer_slot_changes
            ),
            get_footer_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(34:2) {#if $$slots.footer}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_13(ctx8) {
  let t0;
  let div;
  let t1;
  let main;
  let main_class_value;
  let t2;
  let div_class_value;
  let t3;
  let if_block3_anchor;
  let current;
  let if_block0 = (
    /*$$slots*/
    ctx8[7].header && create_if_block_32(ctx8)
  );
  let if_block1 = (
    /*$$slots*/
    ctx8[7].navbar && create_if_block_24(ctx8)
  );
  const default_slot_template = (
    /*#slots*/
    ctx8[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[14],
    null
  );
  let if_block2 = (
    /*$$slots*/
    ctx8[7].aside && create_if_block_16(ctx8)
  );
  let if_block3 = (
    /*$$slots*/
    ctx8[7].footer && create_if_block9(ctx8)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      div = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      main = element("main");
      if (default_slot)
        default_slot.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      if_block3_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block1)
        if_block1.l(div_nodes);
      t1 = claim_space(div_nodes);
      main = claim_element(div_nodes, "MAIN", { class: true });
      var main_nodes = children(main);
      if (default_slot)
        default_slot.l(main_nodes);
      main_nodes.forEach(detach_dev);
      t2 = claim_space(div_nodes);
      if (if_block2)
        if_block2.l(div_nodes);
      div_nodes.forEach(detach_dev);
      t3 = claim_space(nodes);
      if (if_block3)
        if_block3.l(nodes);
      if_block3_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(main, "class", main_class_value = /*classes*/
      ctx8[5].main);
      add_location(main, file15, 26, 3, 921);
      attr_dev(div, "class", div_class_value = /*classes*/
      ctx8[5].body);
      add_location(div, file15, 22, 2, 831);
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div, anchor);
      if (if_block1)
        if_block1.m(div, null);
      append_hydration_dev(div, t1);
      append_hydration_dev(div, main);
      if (default_slot) {
        default_slot.m(main, null);
      }
      append_hydration_dev(div, t2);
      if (if_block2)
        if_block2.m(div, null);
      insert_hydration_dev(target, t3, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert_hydration_dev(target, if_block3_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (
        /*$$slots*/
        ctx9[7].header
      ) {
        if (if_block0) {
          if_block0.p(ctx9, dirty);
          if (dirty & /*$$slots*/
          128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_32(ctx9);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx9[7].navbar
      ) {
        if (if_block1) {
          if_block1.p(ctx9, dirty);
          if (dirty & /*$$slots*/
          128) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_24(ctx9);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classes*/
      32 && main_class_value !== (main_class_value = /*classes*/
      ctx9[5].main)) {
        attr_dev(main, "class", main_class_value);
      }
      if (
        /*$$slots*/
        ctx9[7].aside
      ) {
        if (if_block2) {
          if_block2.p(ctx9, dirty);
          if (dirty & /*$$slots*/
          128) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_16(ctx9);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*classes*/
      32 && div_class_value !== (div_class_value = /*classes*/
      ctx9[5].body)) {
        attr_dev(div, "class", div_class_value);
      }
      if (
        /*$$slots*/
        ctx9[7].footer
      ) {
        if (if_block3) {
          if_block3.p(ctx9, dirty);
          if (dirty & /*$$slots*/
          128) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block9(ctx9);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(default_slot, local);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(default_slot, local);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(div);
        detach_dev(t3);
        detach_dev(if_block3_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d();
      if (default_slot)
        default_slot.d(detaching);
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_13.name,
    type: "slot",
    source: "(19:1) <Box>",
    ctx: ctx8
  });
  return block;
}
function create_default_slot21(ctx8) {
  let box;
  let current;
  box = new Box_default({
    props: {
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const box_changes = {};
      if (dirty & /*$$scope, $$slots, classes*/
      16544) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot21.name,
    type: "slot",
    source: "(18:0) <AppShellProvider {use} bind:element value={{ fixed, zIndex }} class={cx(className, classes.root)}>",
    ctx: ctx8
  });
  return block;
}
function create_fragment33(ctx8) {
  let appshellprovider;
  let updating_element;
  let current;
  function appshellprovider_element_binding(value) {
    ctx8[13](value);
  }
  let appshellprovider_props = {
    use: (
      /*use*/
      ctx8[1]
    ),
    value: {
      fixed: (
        /*fixed*/
        ctx8[4]
      ),
      zIndex: (
        /*zIndex*/
        ctx8[3]
      )
    },
    class: (
      /*cx*/
      ctx8[6](
        /*className*/
        ctx8[2],
        /*classes*/
        ctx8[5].root
      )
    ),
    $$slots: { default: [create_default_slot21] },
    $$scope: { ctx: ctx8 }
  };
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    appshellprovider_props.element = /*element*/
    ctx8[0];
  }
  appshellprovider = new AppShellProvider_default({
    props: appshellprovider_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(appshellprovider, "element", appshellprovider_element_binding));
  const block = {
    c: function create() {
      create_component(appshellprovider.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(appshellprovider.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(appshellprovider, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const appshellprovider_changes = {};
      if (dirty & /*use*/
      2)
        appshellprovider_changes.use = /*use*/
        ctx9[1];
      if (dirty & /*fixed, zIndex*/
      24)
        appshellprovider_changes.value = {
          fixed: (
            /*fixed*/
            ctx9[4]
          ),
          zIndex: (
            /*zIndex*/
            ctx9[3]
          )
        };
      if (dirty & /*cx, className, classes*/
      100)
        appshellprovider_changes.class = /*cx*/
        ctx9[6](
          /*className*/
          ctx9[2],
          /*classes*/
          ctx9[5].root
        );
      if (dirty & /*$$scope, $$slots, classes*/
      16544) {
        appshellprovider_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        appshellprovider_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      appshellprovider.$set(appshellprovider_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(appshellprovider.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(appshellprovider.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(appshellprovider, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance33($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AppShell", slots, ["header", "navbar", "default", "aside", "footer"]);
  const $$slots = compute_slots(slots);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, zIndex = 100, fixed = true, padding: padding3 = "md", navbarOffsetBreakpoint = void 0, asideOffsetBreakpoint = void 0 } = $$props;
  const writable_props = [
    "use",
    "element",
    "class",
    "override",
    "zIndex",
    "fixed",
    "padding",
    "navbarOffsetBreakpoint",
    "asideOffsetBreakpoint"
  ];
  Object.keys($$props).forEach((key3) => {
    if (!~writable_props.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<AppShell> was created with unknown prop '${key3}'`);
  });
  function appshellprovider_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$props2) => {
    if ("use" in $$props2)
      $$invalidate(1, use = $$props2.use);
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("class" in $$props2)
      $$invalidate(2, className = $$props2.class);
    if ("override" in $$props2)
      $$invalidate(8, override = $$props2.override);
    if ("zIndex" in $$props2)
      $$invalidate(3, zIndex = $$props2.zIndex);
    if ("fixed" in $$props2)
      $$invalidate(4, fixed = $$props2.fixed);
    if ("padding" in $$props2)
      $$invalidate(9, padding3 = $$props2.padding);
    if ("navbarOffsetBreakpoint" in $$props2)
      $$invalidate(10, navbarOffsetBreakpoint = $$props2.navbarOffsetBreakpoint);
    if ("asideOffsetBreakpoint" in $$props2)
      $$invalidate(11, asideOffsetBreakpoint = $$props2.asideOffsetBreakpoint);
    if ("$$scope" in $$props2)
      $$invalidate(14, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    Box: Box_default,
    useStyles: AppShell_styles_default,
    AppShellProvider: AppShellProvider_default,
    use,
    element: element2,
    className,
    override,
    zIndex,
    fixed,
    padding: padding3,
    navbarOffsetBreakpoint,
    asideOffsetBreakpoint,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$props2) => {
    if ("use" in $$props2)
      $$invalidate(1, use = $$props2.use);
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("className" in $$props2)
      $$invalidate(2, className = $$props2.className);
    if ("override" in $$props2)
      $$invalidate(8, override = $$props2.override);
    if ("zIndex" in $$props2)
      $$invalidate(3, zIndex = $$props2.zIndex);
    if ("fixed" in $$props2)
      $$invalidate(4, fixed = $$props2.fixed);
    if ("padding" in $$props2)
      $$invalidate(9, padding3 = $$props2.padding);
    if ("navbarOffsetBreakpoint" in $$props2)
      $$invalidate(10, navbarOffsetBreakpoint = $$props2.navbarOffsetBreakpoint);
    if ("asideOffsetBreakpoint" in $$props2)
      $$invalidate(11, asideOffsetBreakpoint = $$props2.asideOffsetBreakpoint);
    if ("classes" in $$props2)
      $$invalidate(5, classes = $$props2.classes);
    if ("cx" in $$props2)
      $$invalidate(6, cx2 = $$props2.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*padding, fixed, navbarOffsetBreakpoint, asideOffsetBreakpoint, override*/
    3856) {
      $:
        $$invalidate(
          6,
          { cx: cx2, classes } = AppShell_styles_default(
            {
              padding: padding3,
              fixed,
              navbarOffsetBreakpoint,
              asideOffsetBreakpoint
            },
            { override, name: "AppShell" }
          ),
          cx2,
          ($$invalidate(5, classes), $$invalidate(9, padding3), $$invalidate(4, fixed), $$invalidate(10, navbarOffsetBreakpoint), $$invalidate(11, asideOffsetBreakpoint), $$invalidate(8, override))
        );
    }
  };
  return [
    element2,
    use,
    className,
    zIndex,
    fixed,
    classes,
    cx2,
    $$slots,
    override,
    padding3,
    navbarOffsetBreakpoint,
    asideOffsetBreakpoint,
    slots,
    appshellprovider_element_binding,
    $$scope
  ];
}
var AppShell = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance33, create_fragment33, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 8,
      zIndex: 3,
      fixed: 4,
      padding: 9,
      navbarOffsetBreakpoint: 10,
      asideOffsetBreakpoint: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AppShell",
      options,
      id: create_fragment33.name
    });
  }
  get use() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fixed() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fixed(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get navbarOffsetBreakpoint() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set navbarOffsetBreakpoint(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get asideOffsetBreakpoint() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set asideOffsetBreakpoint(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AppShell_default = AppShell;

// node_modules/@svelteuidev/core/dist/components/AspectRatio/AspectRatio.styles.js
var AspectRatio_styles_default = createStyles((theme4, { ratio }) => {
  return {
    root: {
      position: "relative",
      maxWidth: "100%",
      "&::before": {
        content: '""',
        height: 0,
        display: "block",
        paddingBottom: `${1 / ratio * 100}%`
      },
      "&::after": {
        content: '""',
        display: "table",
        clear: "both"
      },
      "& > *:not(style)": {
        ...theme4.fn.cover(),
        overflow: "hidden",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        width: "100%",
        height: "100%"
      },
      "& img, & video": {
        objectFit: "cover"
      },
      "& figure": {
        width: "100%"
      }
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/AspectRatio/AspectRatio.svelte
function create_default_slot22(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[11],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[11],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot22.name,
    type: "slot",
    source: "(27:0) <Box  bind:element  {use}  class={cx(className, classes.root, getStyles({ css: override }))}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment34(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { use: (
      /*use*/
      ctx8[1]
    ) },
    {
      class: (
        /*cx*/
        ctx8[6](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[5].root,
          /*getStyles*/
          ctx8[4]({ css: (
            /*override*/
            ctx8[3]
          ) })
        )
      )
    },
    /*$$restProps*/
    ctx8[7]
  ];
  function box_element_binding(value) {
    ctx8[10](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot22] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*use, cx, className, classes, getStyles, override, $$restProps*/
      254 ? get_spread_update(box_spread_levels, [
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*cx, className, classes, getStyles, override*/
        124 && {
          class: (
            /*cx*/
            ctx9[6](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[5].root,
              /*getStyles*/
              ctx9[4]({ css: (
                /*override*/
                ctx9[3]
              ) })
            )
          )
        },
        dirty & /*$$restProps*/
        128 && get_spread_object(
          /*$$restProps*/
          ctx9[7]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      2048) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance34($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = ["use", "element", "class", "override", "ratio"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AspectRatio", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, ratio = 1 } = $$props;
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("ratio" in $$new_props)
      $$invalidate(8, ratio = $$new_props.ratio);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: AspectRatio_styles_default,
    Box: Box_default,
    use,
    element: element2,
    className,
    override,
    ratio,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("ratio" in $$props)
      $$invalidate(8, ratio = $$new_props.ratio);
    if ("getStyles" in $$props)
      $$invalidate(4, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(5, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(6, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*ratio*/
    256) {
      $:
        $$invalidate(6, { cx: cx2, classes, getStyles } = AspectRatio_styles_default({ ratio }, { name: "AspectRatio" }), cx2, ($$invalidate(5, classes), $$invalidate(8, ratio)), ($$invalidate(4, getStyles), $$invalidate(8, ratio)));
    }
  };
  return [
    element2,
    use,
    className,
    override,
    getStyles,
    classes,
    cx2,
    $$restProps,
    ratio,
    slots,
    box_element_binding,
    $$scope
  ];
}
var AspectRatio = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance34, create_fragment34, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      ratio: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AspectRatio",
      options,
      id: create_fragment34.name
    });
  }
  get use() {
    throw new Error("<AspectRatio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<AspectRatio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<AspectRatio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<AspectRatio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<AspectRatio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<AspectRatio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<AspectRatio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<AspectRatio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ratio() {
    throw new Error("<AspectRatio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ratio(value) {
    throw new Error("<AspectRatio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AspectRatio_default = AspectRatio;

// node_modules/@svelteuidev/core/dist/components/Badge/Badge.styles.js
var sizes3 = {
  xs: {
    fontSize: 9,
    height: 16
  },
  sm: {
    fontSize: 10,
    height: 18
  },
  md: {
    fontSize: 11,
    height: 20
  },
  lg: {
    fontSize: 13,
    height: 26
  },
  xl: {
    fontSize: 16,
    height: 32
  }
};
var dotSizes = {
  xs: 4,
  sm: 4,
  md: 6,
  lg: 8,
  xl: 10
};
var Badge_styles_default = createStyles((theme4, { fullWidth, radius: radius2, size: size3, color, gradientDeg, gradientFrom, gradientTo }) => {
  const dotSize = theme4.fn.size({ size: size3, sizes: dotSizes });
  const lightColors = theme4.fn.variant({ color, variant: "light" });
  const filledColors = theme4.fn.variant({ color, variant: "filled" });
  const outlineColors = theme4.fn.variant({ color, variant: "outline" });
  const gradientColors = theme4.fn.variant({
    variant: "gradient",
    gradient: { from: gradientFrom, to: gradientTo, deg: gradientDeg }
  });
  const { fontSize, height } = size3 in sizes3 ? sizes3[size3] : sizes3.md;
  return {
    root: {
      focusRing: "auto",
      fontSize,
      height,
      WebkitTapHighlightColor: "transparent",
      lineHeight: `${height - 2}px`,
      textDecoration: "none",
      padding: `0 ${theme4.fn.size({ size: size3, sizes: theme4.space }) / 1.5}px`,
      boxSizing: "border-box",
      display: fullWidth ? "flex" : "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      width: fullWidth ? "100%" : "auto",
      textTransform: "uppercase",
      borderRadius: theme4.fn.radius(radius2),
      fontFamily: theme4.fonts.standard.value ?? "sans-serif",
      fontWeight: 700,
      letterSpacing: 0.25,
      cursor: "default",
      textOverflow: "ellipsis",
      overflow: "hidden",
      // As of now the createStyles function has a limitation that doesn't allow you to have multiple properties per component.
      // For an example, I can not make a `root` key, and then a `wrapper` key, and expect it to work. So for now they will be done manually.
      "&.light": {
        [`${theme4.dark} &`]: {
          backgroundColor: lightColors.background[0],
          color: lightColors.color[0]
        },
        backgroundColor: lightColors.background[1],
        color: lightColors.color[1],
        border: "1px solid transparent"
      },
      "&.filled": {
        [`${theme4.dark} &`]: {
          backgroundColor: filledColors.background[0]
        },
        backgroundColor: filledColors.background[1],
        color: filledColors.color,
        border: "1px solid transparent"
      },
      "&.outline": {
        [`${theme4.dark} &`]: {
          color: outlineColors.color[0],
          border: `1px solid ${outlineColors.border[0]}`
        },
        backgroundColor: outlineColors.background,
        color: outlineColors.color[1],
        border: `1px solid ${outlineColors.border[1]}`
      },
      "&.gradient": {
        backgroundImage: gradientColors.background,
        color: gradientColors.color,
        border: 0
      },
      "&.dot": {
        darkMode: {
          color: theme4.fn.themeColor("dark", 0),
          border: `1px solid ${theme4.fn.themeColor("dark", 3)}`,
          "&::before": {
            backgroundColor: theme4.fn.themeColor(color, 4)
          }
        },
        backgroundColor: "transparent",
        color: theme4.fn.themeColor("gray", 7),
        border: `1px solid ${theme4.fn.themeColor("gray", 3)}`,
        paddingLeft: theme4.fn.size({ size: size3, sizes: theme4.space }) / 1.5 - dotSize / 2,
        "&::before": {
          content: '""',
          display: "block",
          width: dotSize,
          height: dotSize,
          borderRadius: dotSize,
          backgroundColor: theme4.fn.themeColor(color, 6),
          marginRight: dotSize
        }
      }
    },
    leftSection: {
      marginRight: parseInt(theme4.space.xs.value) / 2
    },
    rightSection: {
      marginLeft: parseInt(theme4.space.xs.value) / 2
    },
    inner: {
      whiteSpace: "nowrap",
      overflow: "hidden",
      textOverflow: "ellipsis"
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Badge/Badge.svelte
var file16 = "node_modules/@svelteuidev/core/dist/components/Badge/Badge.svelte";
var get_rightSection_slot_changes = (dirty) => ({});
var get_rightSection_slot_context = (ctx8) => ({});
var get_leftSection_slot_changes = (dirty) => ({});
var get_leftSection_slot_context = (ctx8) => ({});
function create_if_block_17(ctx8) {
  let span;
  let span_class_value;
  let current;
  const leftSection_slot_template = (
    /*#slots*/
    ctx8[15].leftSection
  );
  const leftSection_slot = create_slot(
    leftSection_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[17],
    get_leftSection_slot_context
  );
  const block = {
    c: function create() {
      span = element("span");
      if (leftSection_slot)
        leftSection_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (leftSection_slot)
        leftSection_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*classes*/
      ctx8[4].leftSection);
      add_location(span, file16, 42, 2, 1336);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (leftSection_slot) {
        leftSection_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (leftSection_slot) {
        if (leftSection_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            leftSection_slot,
            leftSection_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[17]
            ) : get_slot_changes(
              leftSection_slot_template,
              /*$$scope*/
              ctx9[17],
              dirty,
              get_leftSection_slot_changes
            ),
            get_leftSection_slot_context
          );
        }
      }
      if (!current || dirty & /*classes*/
      16 && span_class_value !== (span_class_value = /*classes*/
      ctx9[4].leftSection)) {
        attr_dev(span, "class", span_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(leftSection_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(leftSection_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (leftSection_slot)
        leftSection_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_17.name,
    type: "if",
    source: "(42:1) {#if $$slots.leftSection}",
    ctx: ctx8
  });
  return block;
}
function create_if_block10(ctx8) {
  let span;
  let span_class_value;
  let current;
  const rightSection_slot_template = (
    /*#slots*/
    ctx8[15].rightSection
  );
  const rightSection_slot = create_slot(
    rightSection_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[17],
    get_rightSection_slot_context
  );
  const block = {
    c: function create() {
      span = element("span");
      if (rightSection_slot)
        rightSection_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (rightSection_slot)
        rightSection_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*classes*/
      ctx8[4].rightSection);
      add_location(span, file16, 48, 2, 1494);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (rightSection_slot) {
        rightSection_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (rightSection_slot) {
        if (rightSection_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            rightSection_slot,
            rightSection_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[17]
            ) : get_slot_changes(
              rightSection_slot_template,
              /*$$scope*/
              ctx9[17],
              dirty,
              get_rightSection_slot_changes
            ),
            get_rightSection_slot_context
          );
        }
      }
      if (!current || dirty & /*classes*/
      16 && span_class_value !== (span_class_value = /*classes*/
      ctx9[4].rightSection)) {
        attr_dev(span, "class", span_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rightSection_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rightSection_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (rightSection_slot)
        rightSection_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block10.name,
    type: "if",
    source: "(48:1) {#if $$slots.rightSection}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot23(ctx8) {
  let t0;
  let span;
  let span_class_value;
  let t1;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*$$slots*/
    ctx8[8].leftSection && create_if_block_17(ctx8)
  );
  const default_slot_template = (
    /*#slots*/
    ctx8[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[17],
    null
  );
  let if_block1 = (
    /*$$slots*/
    ctx8[8].rightSection && create_if_block10(ctx8)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      span = element("span");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*classes*/
      ctx8[4].inner);
      add_location(span, file16, 46, 1, 1420);
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      insert_hydration_dev(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (
        /*$$slots*/
        ctx9[8].leftSection
      ) {
        if (if_block0) {
          if_block0.p(ctx9, dirty);
          if (dirty & /*$$slots*/
          256) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_17(ctx9);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[17],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classes*/
      16 && span_class_value !== (span_class_value = /*classes*/
      ctx9[4].inner)) {
        attr_dev(span, "class", span_class_value);
      }
      if (
        /*$$slots*/
        ctx9[8].rightSection
      ) {
        if (if_block1) {
          if_block1.p(ctx9, dirty);
          if (dirty & /*$$slots*/
          256) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block10(ctx9);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(default_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(default_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(span);
        detach_dev(t1);
        detach_dev(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot23.name,
    type: "slot",
    source: "(36:0) <Box  use={[forwardEvents, [useActions, use]]}  bind:element  class={cx(className, variant, classes.root)}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment35(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    {
      use: [
        /*forwardEvents*/
        ctx8[6],
        [
          useActions,
          /*use*/
          ctx8[1]
        ]
      ]
    },
    {
      class: (
        /*cx*/
        ctx8[5](
          /*className*/
          ctx8[2],
          /*variant*/
          ctx8[3],
          /*classes*/
          ctx8[4].root
        )
      )
    },
    /*$$restProps*/
    ctx8[7]
  ];
  function box_element_binding(value) {
    ctx8[16](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot23] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*forwardEvents, use, cx, className, variant, classes, $$restProps*/
      254 ? get_spread_update(box_spread_levels, [
        dirty & /*forwardEvents, use*/
        66 && {
          use: [
            /*forwardEvents*/
            ctx9[6],
            [
              useActions,
              /*use*/
              ctx9[1]
            ]
          ]
        },
        dirty & /*cx, className, variant, classes*/
        60 && {
          class: (
            /*cx*/
            ctx9[5](
              /*className*/
              ctx9[2],
              /*variant*/
              ctx9[3],
              /*classes*/
              ctx9[4].root
            )
          )
        },
        dirty & /*$$restProps*/
        128 && get_spread_object(
          /*$$restProps*/
          ctx9[7]
        )
      ]) : {};
      if (dirty & /*$$scope, classes, $$slots*/
      131344) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance35($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "color",
    "variant",
    "gradient",
    "size",
    "radius",
    "fullWidth"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Badge", slots, ["leftSection", "default", "rightSection"]);
  const $$slots = compute_slots(slots);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, color = "blue", variant: variant2 = "light", gradient = { from: "blue", to: "cyan", deg: 45 }, size: size3 = "md", radius: radius2 = "xl", fullWidth = false } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(9, override = $$new_props.override);
    if ("color" in $$new_props)
      $$invalidate(10, color = $$new_props.color);
    if ("variant" in $$new_props)
      $$invalidate(3, variant2 = $$new_props.variant);
    if ("gradient" in $$new_props)
      $$invalidate(11, gradient = $$new_props.gradient);
    if ("size" in $$new_props)
      $$invalidate(12, size3 = $$new_props.size);
    if ("radius" in $$new_props)
      $$invalidate(13, radius2 = $$new_props.radius);
    if ("fullWidth" in $$new_props)
      $$invalidate(14, fullWidth = $$new_props.fullWidth);
    if ("$$scope" in $$new_props)
      $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: Badge_styles_default,
    createEventForwarder,
    useActions,
    get_current_component,
    Box: Box_default,
    use,
    element: element2,
    className,
    override,
    color,
    variant: variant2,
    gradient,
    size: size3,
    radius: radius2,
    fullWidth,
    forwardEvents,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(9, override = $$new_props.override);
    if ("color" in $$props)
      $$invalidate(10, color = $$new_props.color);
    if ("variant" in $$props)
      $$invalidate(3, variant2 = $$new_props.variant);
    if ("gradient" in $$props)
      $$invalidate(11, gradient = $$new_props.gradient);
    if ("size" in $$props)
      $$invalidate(12, size3 = $$new_props.size);
    if ("radius" in $$props)
      $$invalidate(13, radius2 = $$new_props.radius);
    if ("fullWidth" in $$props)
      $$invalidate(14, fullWidth = $$new_props.fullWidth);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(5, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*color, fullWidth, size, radius, gradient, override*/
    32256) {
      $:
        $$invalidate(
          5,
          { cx: cx2, classes } = Badge_styles_default(
            {
              color,
              fullWidth,
              size: size3,
              radius: radius2,
              gradientDeg: gradient.deg,
              gradientFrom: gradient.from,
              gradientTo: gradient.to
            },
            { override, name: "Badge" }
          ),
          cx2,
          ($$invalidate(4, classes), $$invalidate(10, color), $$invalidate(14, fullWidth), $$invalidate(12, size3), $$invalidate(13, radius2), $$invalidate(11, gradient), $$invalidate(9, override))
        );
    }
  };
  return [
    element2,
    use,
    className,
    variant2,
    classes,
    cx2,
    forwardEvents,
    $$restProps,
    $$slots,
    override,
    color,
    gradient,
    size3,
    radius2,
    fullWidth,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Badge = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance35, create_fragment35, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 9,
      color: 10,
      variant: 3,
      gradient: 11,
      size: 12,
      radius: 13,
      fullWidth: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Badge",
      options,
      id: create_fragment35.name
    });
  }
  get use() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gradient() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gradient(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fullWidth() {
    throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fullWidth(value) {
    throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Badge_default = Badge;

// node_modules/@svelteuidev/core/dist/components/Blockquote/Blockquote.styles.js
var Blockquote_styles_default = createStyles((theme4, { color }) => {
  return {
    root: {
      darkMode: {
        color: theme4.fn.themeColor("dark", 0)
      },
      fontFamily: theme4.fonts.standard.value ?? "sans-serif",
      fontSize: theme4.fontSizes.lg.value,
      lineHeight: theme4.lineHeights.md.value,
      color: theme4.fn.themeColor("black"),
      margin: 0,
      borderTopRightRadius: theme4.radii.sm.value,
      borderBottomRightRadius: theme4.radii.sm.value,
      padding: `${theme4.space.mdPX.value} ${theme4.space.lgPX.value}`
    },
    inner: {
      display: "flex"
    },
    body: {
      flex: 1,
      overflow: "hidden",
      textOverflow: "ellipsis"
    },
    icon: {
      darkMode: {
        color: theme4.fn.variant({ variant: "filled", color }).background[0]
      },
      color: theme4.fn.variant({ variant: "filled", color }).background[1],
      marginRight: theme4.space.lgPX.value,
      marginTop: rem(2),
      width: rem(22)
    },
    cite: {
      darkMode: {
        color: theme4.fn.themeColor("dark", 2)
      },
      display: "block",
      fontSize: theme4.fontSizes.sm.value,
      marginTop: theme4.space.xsPX.value,
      color: theme4.fn.themeColor("gray", 6),
      overflow: "hidden",
      textOverflow: "ellipsis"
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Blockquote/QuoteIcon.svelte
var file17 = "node_modules/@svelteuidev/core/dist/components/Blockquote/QuoteIcon.svelte";
function create_fragment36(ctx8) {
  let svg;
  let path;
  let svg_levels = [
    { viewBox: "0 0 409.294 409.294" },
    { fill: "currentColor" },
    { xmlns: "http://www.w3.org/2000/svg" },
    /*$$restProps*/
    ctx8[0]
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign(svg_data, svg_levels[i2]);
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { viewBox: true, fill: true, xmlns: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M0 204.647v175.412h175.412V204.647H58.471c0-64.48 52.461-116.941 116.941-116.941V29.235C78.684 29.235 0 107.919 0 204.647zM409.294 87.706V29.235c-96.728 0-175.412 78.684-175.412 175.412v175.412h175.412V204.647H292.353c0-64.48 52.461-116.941 116.941-116.941z");
      add_location(path, file17, 6, 1, 114);
      set_svg_attributes(svg, svg_data);
      add_location(svg, file17, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx9, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { viewBox: "0 0 409.294 409.294" },
        { fill: "currentColor" },
        { xmlns: "http://www.w3.org/2000/svg" },
        dirty & /*$$restProps*/
        1 && /*$$restProps*/
        ctx9[0]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance36($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("QuoteIcon", slots, []);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
  };
  return [$$restProps];
}
var QuoteIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance36, create_fragment36, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "QuoteIcon",
      options,
      id: create_fragment36.name
    });
  }
};
var QuoteIcon_default = QuoteIcon;

// node_modules/@svelteuidev/core/dist/components/Blockquote/Blockquote.svelte
var file18 = "node_modules/@svelteuidev/core/dist/components/Blockquote/Blockquote.svelte";
var get_cite_slot_changes = (dirty) => ({});
var get_cite_slot_context = (ctx8) => ({});
var get_icon_slot_changes2 = (dirty) => ({});
var get_icon_slot_context2 = (ctx8) => ({});
function create_if_block_18(ctx8) {
  let div;
  let iconrenderer;
  let div_class_value;
  let current;
  iconrenderer = new IconRenderer_default({
    props: {
      icon: (
        /*icon*/
        ctx8[3]
      ),
      iconSize: (
        /*iconSize*/
        ctx8[4]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(iconrenderer.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(iconrenderer.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*classes*/
      ctx8[5].icon);
      add_location(div, file18, 28, 4, 840);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(iconrenderer, div, null);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const iconrenderer_changes = {};
      if (dirty & /*icon*/
      8)
        iconrenderer_changes.icon = /*icon*/
        ctx9[3];
      if (dirty & /*iconSize*/
      16)
        iconrenderer_changes.iconSize = /*iconSize*/
        ctx9[4];
      iconrenderer.$set(iconrenderer_changes);
      if (!current || dirty & /*classes*/
      32 && div_class_value !== (div_class_value = /*classes*/
      ctx9[5].icon)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconrenderer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconrenderer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(iconrenderer);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_18.name,
    type: "if",
    source: "(28:3) {#if icon}",
    ctx: ctx8
  });
  return block;
}
function fallback_block6(ctx8) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*icon*/
    ctx8[3] && create_if_block_18(ctx8)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (
        /*icon*/
        ctx9[3]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
          if (dirty & /*icon*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_18(ctx9);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block6.name,
    type: "fallback",
    source: "(27:20)     ",
    ctx: ctx8
  });
  return block;
}
function create_if_block11(ctx8) {
  let cite;
  let cite_class_value;
  let current;
  const cite_slot_template = (
    /*#slots*/
    ctx8[11].cite
  );
  const cite_slot = create_slot(
    cite_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[13],
    get_cite_slot_context
  );
  const block = {
    c: function create() {
      cite = element("cite");
      if (cite_slot)
        cite_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      cite = claim_element(nodes, "CITE", { class: true });
      var cite_nodes = children(cite);
      if (cite_slot)
        cite_slot.l(cite_nodes);
      cite_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(cite, "class", cite_class_value = /*classes*/
      ctx8[5].cite);
      add_location(cite, file18, 36, 4, 1004);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, cite, anchor);
      if (cite_slot) {
        cite_slot.m(cite, null);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (cite_slot) {
        if (cite_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            cite_slot,
            cite_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[13]
            ) : get_slot_changes(
              cite_slot_template,
              /*$$scope*/
              ctx9[13],
              dirty,
              get_cite_slot_changes
            ),
            get_cite_slot_context
          );
        }
      }
      if (!current || dirty & /*classes*/
      32 && cite_class_value !== (cite_class_value = /*classes*/
      ctx9[5].cite)) {
        attr_dev(cite, "class", cite_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(cite_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(cite_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(cite);
      }
      if (cite_slot)
        cite_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block11.name,
    type: "if",
    source: "(36:3) {#if $$slots.cite}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot24(ctx8) {
  let div1;
  let t0;
  let div0;
  let t1;
  let div0_class_value;
  let div1_class_value;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx8[11].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[13],
    get_icon_slot_context2
  );
  const icon_slot_or_fallback = icon_slot || fallback_block6(ctx8);
  const default_slot_template = (
    /*#slots*/
    ctx8[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[13],
    null
  );
  let if_block = (
    /*$$slots*/
    ctx8[8].cite && create_if_block11(ctx8)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.c();
      t0 = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      t1 = claim_space(div0_nodes);
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = /*classes*/
      ctx8[5].body);
      add_location(div0, file18, 33, 2, 939);
      attr_dev(div1, "class", div1_class_value = /*classes*/
      ctx8[5].inner);
      add_location(div1, file18, 25, 1, 773);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(div1, null);
      }
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append_hydration_dev(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[13]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx9[13],
              dirty,
              get_icon_slot_changes2
            ),
            get_icon_slot_context2
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty & /*classes, icon, iconSize*/
        56)) {
          icon_slot_or_fallback.p(ctx9, !current ? -1 : dirty);
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[13],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*$$slots*/
        ctx9[8].cite
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
          if (dirty & /*$$slots*/
          256) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block11(ctx9);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*classes*/
      32 && div0_class_value !== (div0_class_value = /*classes*/
      ctx9[5].body)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty & /*classes*/
      32 && div1_class_value !== (div1_class_value = /*classes*/
      ctx9[5].inner)) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot_or_fallback, local);
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot_or_fallback, local);
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot24.name,
    type: "slot",
    source: "(25:0) <Box bind:element class={cx(className, classes.root)} {root} {...$$restProps}>",
    ctx: ctx8
  });
  return block;
}
function create_fragment37(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    {
      class: (
        /*cx*/
        ctx8[6](
          /*className*/
          ctx8[1],
          /*classes*/
          ctx8[5].root
        )
      )
    },
    { root: (
      /*root*/
      ctx8[2]
    ) },
    /*$$restProps*/
    ctx8[7]
  ];
  function box_element_binding(value) {
    ctx8[12](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot24] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*cx, className, classes, root, $$restProps*/
      230 ? get_spread_update(box_spread_levels, [
        dirty & /*cx, className, classes*/
        98 && {
          class: (
            /*cx*/
            ctx9[6](
              /*className*/
              ctx9[1],
              /*classes*/
              ctx9[5].root
            )
          )
        },
        dirty & /*root*/
        4 && { root: (
          /*root*/
          ctx9[2]
        ) },
        dirty & /*$$restProps*/
        128 && get_spread_object(
          /*$$restProps*/
          ctx9[7]
        )
      ]) : {};
      if (dirty & /*$$scope, classes, $$slots, icon, iconSize*/
      8504) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance37($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  const omit_props_names = ["element", "class", "override", "root", "color", "icon", "iconSize"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Blockquote", slots, ["icon", "default", "cite"]);
  const $$slots = compute_slots(slots);
  let { element: element2 = void 0, class: className = "", override = {}, root = "blockquote", color = "gray", icon = QuoteIcon_default, iconSize = 20 } = $$props;
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(9, override = $$new_props.override);
    if ("root" in $$new_props)
      $$invalidate(2, root = $$new_props.root);
    if ("color" in $$new_props)
      $$invalidate(10, color = $$new_props.color);
    if ("icon" in $$new_props)
      $$invalidate(3, icon = $$new_props.icon);
    if ("iconSize" in $$new_props)
      $$invalidate(4, iconSize = $$new_props.iconSize);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: Blockquote_styles_default,
    Box: Box_default,
    QuoteIcon: QuoteIcon_default,
    IconRenderer: IconRenderer_default,
    element: element2,
    className,
    override,
    root,
    color,
    icon,
    iconSize,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(9, override = $$new_props.override);
    if ("root" in $$props)
      $$invalidate(2, root = $$new_props.root);
    if ("color" in $$props)
      $$invalidate(10, color = $$new_props.color);
    if ("icon" in $$props)
      $$invalidate(3, icon = $$new_props.icon);
    if ("iconSize" in $$props)
      $$invalidate(4, iconSize = $$new_props.iconSize);
    if ("classes" in $$props)
      $$invalidate(5, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(6, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*color, override*/
    1536) {
      $:
        $$invalidate(6, { cx: cx2, classes } = Blockquote_styles_default({ color }, { override, name: "Blockquote" }), cx2, ($$invalidate(5, classes), $$invalidate(10, color), $$invalidate(9, override)));
    }
  };
  return [
    element2,
    className,
    root,
    icon,
    iconSize,
    classes,
    cx2,
    $$restProps,
    $$slots,
    override,
    color,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Blockquote = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance37, create_fragment37, safe_not_equal, {
      element: 0,
      class: 1,
      override: 9,
      root: 2,
      color: 10,
      icon: 3,
      iconSize: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Blockquote",
      options,
      id: create_fragment37.name
    });
  }
  get element() {
    throw new Error("<Blockquote>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Blockquote>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Blockquote>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Blockquote>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Blockquote>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Blockquote>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get root() {
    throw new Error("<Blockquote>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set root(value) {
    throw new Error("<Blockquote>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Blockquote>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Blockquote>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<Blockquote>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<Blockquote>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconSize() {
    throw new Error("<Blockquote>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconSize(value) {
    throw new Error("<Blockquote>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Blockquote_default = Blockquote;

// node_modules/@svelteuidev/core/dist/components/Breadcrumbs/Breadcrumbs.styles.js
var Breadcrumbs_styles_default = createStyles(() => ({
  root: {
    position: "relative",
    display: "flex"
  }
}));

// node_modules/@svelteuidev/core/dist/components/Breadcrumbs/Breadcrumbs.svelte
function create_default_slot25(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[12],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[12],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot25.name,
    type: "slot",
    source: "(22:0) <Box bind:element {use} class={cx(className, classes.root, getStyles({ css: override }))}>",
    ctx: ctx8
  });
  return block;
}
function create_fragment38(ctx8) {
  let box;
  let updating_element;
  let current;
  function box_element_binding(value) {
    ctx8[11](value);
  }
  let box_props = {
    use: (
      /*use*/
      ctx8[1]
    ),
    class: (
      /*cx*/
      ctx8[6](
        /*className*/
        ctx8[2],
        /*classes*/
        ctx8[5].root,
        /*getStyles*/
        ctx8[4]({ css: (
          /*override*/
          ctx8[3]
        ) })
      )
    ),
    $$slots: { default: [create_default_slot25] },
    $$scope: { ctx: ctx8 }
  };
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = {};
      if (dirty & /*use*/
      2)
        box_changes.use = /*use*/
        ctx9[1];
      if (dirty & /*cx, className, classes, getStyles, override*/
      124)
        box_changes.class = /*cx*/
        ctx9[6](
          /*className*/
          ctx9[2],
          /*classes*/
          ctx9[5].root,
          /*getStyles*/
          ctx9[4]({ css: (
            /*override*/
            ctx9[3]
          ) })
        );
      if (dirty & /*$$scope*/
      4096) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
var ctx = "Breadcrumbs";
function instance38($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Breadcrumbs", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, color = "blue", size: size3 = "md", separator = "/" } = $$props;
  const contextStore = writable({ separator, size: size3, color });
  setContext(ctx, contextStore);
  const writable_props = ["use", "element", "class", "override", "color", "size", "separator"];
  Object.keys($$props).forEach((key3) => {
    if (!~writable_props.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<Breadcrumbs> was created with unknown prop '${key3}'`);
  });
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$props2) => {
    if ("use" in $$props2)
      $$invalidate(1, use = $$props2.use);
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("class" in $$props2)
      $$invalidate(2, className = $$props2.class);
    if ("override" in $$props2)
      $$invalidate(3, override = $$props2.override);
    if ("color" in $$props2)
      $$invalidate(7, color = $$props2.color);
    if ("size" in $$props2)
      $$invalidate(8, size3 = $$props2.size);
    if ("separator" in $$props2)
      $$invalidate(9, separator = $$props2.separator);
    if ("$$scope" in $$props2)
      $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    ctx,
    useStyles: Breadcrumbs_styles_default,
    Box: Box_default,
    setContext,
    writable,
    use,
    element: element2,
    className,
    override,
    color,
    size: size3,
    separator,
    contextStore,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$props2) => {
    if ("use" in $$props2)
      $$invalidate(1, use = $$props2.use);
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("className" in $$props2)
      $$invalidate(2, className = $$props2.className);
    if ("override" in $$props2)
      $$invalidate(3, override = $$props2.override);
    if ("color" in $$props2)
      $$invalidate(7, color = $$props2.color);
    if ("size" in $$props2)
      $$invalidate(8, size3 = $$props2.size);
    if ("separator" in $$props2)
      $$invalidate(9, separator = $$props2.separator);
    if ("getStyles" in $$props2)
      $$invalidate(4, getStyles = $$props2.getStyles);
    if ("classes" in $$props2)
      $$invalidate(5, classes = $$props2.classes);
    if ("cx" in $$props2)
      $$invalidate(6, cx2 = $$props2.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $:
    $$invalidate(6, { cx: cx2, classes, getStyles } = Breadcrumbs_styles_default(null, { name: "Breadcrumbs" }), cx2, $$invalidate(5, classes), $$invalidate(4, getStyles));
  return [
    element2,
    use,
    className,
    override,
    getStyles,
    classes,
    cx2,
    color,
    size3,
    separator,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Breadcrumbs = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance38, create_fragment38, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      color: 7,
      size: 8,
      separator: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Breadcrumbs",
      options,
      id: create_fragment38.name
    });
  }
  get use() {
    throw new Error("<Breadcrumbs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Breadcrumbs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Breadcrumbs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Breadcrumbs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Breadcrumbs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Breadcrumbs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Breadcrumbs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Breadcrumbs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Breadcrumbs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Breadcrumbs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Breadcrumbs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Breadcrumbs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get separator() {
    throw new Error("<Breadcrumbs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set separator(value) {
    throw new Error("<Breadcrumbs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Breadcrumbs_default = Breadcrumbs;

// node_modules/@svelteuidev/core/dist/components/Breadcrumbs/BreadcrumbsItem/BreadcrumbsItem.styles.js
var fontSizes = {
  xs: 12,
  sm: 14,
  md: 16,
  lg: 18,
  xl: 20
};
var BreadcrumbsItem_styles_default = createStyles((theme4, { color, size: size3 }) => ({
  root: {
    position: "relative",
    fontFamily: theme4.fonts.standard.value ?? "sans-serif"
  },
  wrapper: {
    display: "flex",
    gap: size3,
    alignItems: "center",
    overflow: "hidden",
    fontSize: fontSizes[size3],
    "& a": {
      display: "flex",
      alignItems: "center",
      textDecoration: "none",
      color: theme4.fn.themeColor(color, 6)
    }
  },
  innerText: {
    marginLeft: "4px"
  },
  icon: {
    fontSize: fontSizes[size3]
  },
  separator: {
    margin: "0 8px"
  }
}));

// node_modules/@svelteuidev/core/dist/components/Breadcrumbs/BreadcrumbsItem/BreadcrumbsItem.svelte
var file19 = "node_modules/@svelteuidev/core/dist/components/Breadcrumbs/BreadcrumbsItem/BreadcrumbsItem.svelte";
var get_icon_slot_changes_1 = (dirty) => ({ class: dirty & /*cx, classes*/
384 });
var get_icon_slot_context_1 = (ctx8) => ({
  class: (
    /*cx*/
    ctx8[8](
      /*classes*/
      ctx8[7].icon
    )
  )
});
var get_icon_slot_changes3 = (dirty) => ({ class: dirty & /*cx, classes*/
384 });
var get_icon_slot_context3 = (ctx8) => ({
  class: (
    /*cx*/
    ctx8[8](
      /*classes*/
      ctx8[7].icon
    )
  )
});
function create_else_block6(ctx8) {
  let div;
  let t0;
  let span;
  let span_class_value;
  let t1;
  let div_class_value;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx8[11].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[13],
    get_icon_slot_context_1
  );
  const default_slot_template = (
    /*#slots*/
    ctx8[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[13],
    null
  );
  let if_block = !/*active*/
  ctx8[5] && create_if_block_25(ctx8);
  const block = {
    c: function create() {
      div = element("div");
      if (icon_slot)
        icon_slot.c();
      t0 = space();
      span = element("span");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (icon_slot)
        icon_slot.l(div_nodes);
      t0 = claim_space(div_nodes);
      span = claim_element(div_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      t1 = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*cx*/
      ctx8[8](
        /*classes*/
        ctx8[7].innerText
      ));
      add_location(span, file19, 31, 3, 1133);
      attr_dev(div, "class", div_class_value = /*cx*/
      ctx8[8](
        /*classes*/
        ctx8[7].wrapper,
        { active: (
          /*active*/
          ctx8[5]
        ) }
      ));
      add_location(div, file19, 29, 2, 1027);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (icon_slot) {
        icon_slot.m(div, null);
      }
      append_hydration_dev(div, t0);
      append_hydration_dev(div, span);
      if (default_slot) {
        default_slot.m(span, null);
      }
      append_hydration_dev(div, t1);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope, cx, classes*/
        8576)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[13]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx9[13],
              dirty,
              get_icon_slot_changes_1
            ),
            get_icon_slot_context_1
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[13],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*cx, classes*/
      384 && span_class_value !== (span_class_value = /*cx*/
      ctx9[8](
        /*classes*/
        ctx9[7].innerText
      ))) {
        attr_dev(span, "class", span_class_value);
      }
      if (!/*active*/
      ctx9[5]) {
        if (if_block) {
          if_block.p(ctx9, dirty);
        } else {
          if_block = create_if_block_25(ctx9);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & /*cx, classes, active*/
      416 && div_class_value !== (div_class_value = /*cx*/
      ctx9[8](
        /*classes*/
        ctx9[7].wrapper,
        { active: (
          /*active*/
          ctx9[5]
        ) }
      ))) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (icon_slot)
        icon_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block6.name,
    type: "else",
    source: "(29:1) {:else}",
    ctx: ctx8
  });
  return block;
}
function create_if_block12(ctx8) {
  let div;
  let a;
  let t0;
  let span;
  let span_class_value;
  let t1;
  let div_class_value;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx8[11].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[13],
    get_icon_slot_context3
  );
  const default_slot_template = (
    /*#slots*/
    ctx8[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[13],
    null
  );
  let if_block = !/*active*/
  ctx8[5] && create_if_block_19(ctx8);
  const block = {
    c: function create() {
      div = element("div");
      a = element("a");
      if (icon_slot)
        icon_slot.c();
      t0 = space();
      span = element("span");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      a = claim_element(div_nodes, "A", { href: true });
      var a_nodes = children(a);
      if (icon_slot)
        icon_slot.l(a_nodes);
      t0 = claim_space(a_nodes);
      span = claim_element(a_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      t1 = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*cx*/
      ctx8[8](
        /*classes*/
        ctx8[7].innerText
      ));
      add_location(span, file19, 20, 4, 851);
      attr_dev(
        a,
        "href",
        /*href*/
        ctx8[4]
      );
      add_location(a, file19, 18, 3, 786);
      attr_dev(div, "class", div_class_value = /*cx*/
      ctx8[8](
        /*classes*/
        ctx8[7].wrapper,
        { active: (
          /*active*/
          ctx8[5]
        ) }
      ));
      add_location(div, file19, 17, 2, 729);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, a);
      if (icon_slot) {
        icon_slot.m(a, null);
      }
      append_hydration_dev(a, t0);
      append_hydration_dev(a, span);
      if (default_slot) {
        default_slot.m(span, null);
      }
      append_hydration_dev(div, t1);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope, cx, classes*/
        8576)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[13]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx9[13],
              dirty,
              get_icon_slot_changes3
            ),
            get_icon_slot_context3
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[13],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*cx, classes*/
      384 && span_class_value !== (span_class_value = /*cx*/
      ctx9[8](
        /*classes*/
        ctx9[7].innerText
      ))) {
        attr_dev(span, "class", span_class_value);
      }
      if (!current || dirty & /*href*/
      16) {
        attr_dev(
          a,
          "href",
          /*href*/
          ctx9[4]
        );
      }
      if (!/*active*/
      ctx9[5]) {
        if (if_block) {
          if_block.p(ctx9, dirty);
        } else {
          if_block = create_if_block_19(ctx9);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & /*cx, classes, active*/
      416 && div_class_value !== (div_class_value = /*cx*/
      ctx9[8](
        /*classes*/
        ctx9[7].wrapper,
        { active: (
          /*active*/
          ctx9[5]
        ) }
      ))) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (icon_slot)
        icon_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block12.name,
    type: "if",
    source: "(17:1) {#if href}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_25(ctx8) {
  let span;
  let t;
  let span_class_value;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*separator*/
        ctx8[10]
      );
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*separator*/
        ctx8[10]
      );
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*cx*/
      ctx8[8](
        /*classes*/
        ctx8[7].separator
      ));
      add_location(span, file19, 35, 4, 1215);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*cx, classes*/
      384 && span_class_value !== (span_class_value = /*cx*/
      ctx9[8](
        /*classes*/
        ctx9[7].separator
      ))) {
        attr_dev(span, "class", span_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_25.name,
    type: "if",
    source: "(35:3) {#if !active}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_19(ctx8) {
  let span;
  let t;
  let span_class_value;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*separator*/
        ctx8[10]
      );
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*separator*/
        ctx8[10]
      );
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*cx*/
      ctx8[8](
        /*classes*/
        ctx8[7].separator
      ));
      add_location(span, file19, 25, 4, 943);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*cx, classes*/
      384 && span_class_value !== (span_class_value = /*cx*/
      ctx9[8](
        /*classes*/
        ctx9[7].separator
      ))) {
        attr_dev(span, "class", span_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_19.name,
    type: "if",
    source: "(25:3) {#if !active}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot26(ctx8) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block12, create_else_block6];
  const if_blocks = [];
  function select_block_type(ctx9, dirty) {
    if (
      /*href*/
      ctx9[4]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx8, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx8);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx9, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx9, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx9);
          if_block.c();
        } else {
          if_block.p(ctx9, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot26.name,
    type: "slot",
    source: "(16:0) <Box bind:element {use} class={cx(className, classes.root, getStyles({ css: override }))}>",
    ctx: ctx8
  });
  return block;
}
function create_fragment39(ctx8) {
  let box;
  let updating_element;
  let current;
  function box_element_binding(value) {
    ctx8[12](value);
  }
  let box_props = {
    use: (
      /*use*/
      ctx8[1]
    ),
    class: (
      /*cx*/
      ctx8[8](
        /*className*/
        ctx8[2],
        /*classes*/
        ctx8[7].root,
        /*getStyles*/
        ctx8[6]({ css: (
          /*override*/
          ctx8[3]
        ) })
      )
    ),
    $$slots: { default: [create_default_slot26] },
    $$scope: { ctx: ctx8 }
  };
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = {};
      if (dirty & /*use*/
      2)
        box_changes.use = /*use*/
        ctx9[1];
      if (dirty & /*cx, className, classes, getStyles, override*/
      460)
        box_changes.class = /*cx*/
        ctx9[8](
          /*className*/
          ctx9[2],
          /*classes*/
          ctx9[7].root,
          /*getStyles*/
          ctx9[6]({ css: (
            /*override*/
            ctx9[3]
          ) })
        );
      if (dirty & /*$$scope, cx, classes, active, href*/
      8624) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance39($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  let $state;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BreadcrumbsItem", slots, ["icon", "default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, href = void 0, active = false } = $$props;
  const state = getContext(ctx);
  validate_store(state, "state");
  component_subscribe($$self, state, (value) => $$invalidate(14, $state = value));
  let separator = $state.separator;
  let size3 = $state.size;
  let color = $state.color;
  const writable_props = ["use", "element", "class", "override", "href", "active"];
  Object.keys($$props).forEach((key3) => {
    if (!~writable_props.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<BreadcrumbsItem> was created with unknown prop '${key3}'`);
  });
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$props2) => {
    if ("use" in $$props2)
      $$invalidate(1, use = $$props2.use);
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("class" in $$props2)
      $$invalidate(2, className = $$props2.class);
    if ("override" in $$props2)
      $$invalidate(3, override = $$props2.override);
    if ("href" in $$props2)
      $$invalidate(4, href = $$props2.href);
    if ("active" in $$props2)
      $$invalidate(5, active = $$props2.active);
    if ("$$scope" in $$props2)
      $$invalidate(13, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    Box: Box_default,
    ctx,
    useStyles: BreadcrumbsItem_styles_default,
    use,
    element: element2,
    className,
    override,
    href,
    active,
    state,
    separator,
    size: size3,
    color,
    getStyles,
    classes,
    cx: cx2,
    $state
  });
  $$self.$inject_state = ($$props2) => {
    if ("use" in $$props2)
      $$invalidate(1, use = $$props2.use);
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("className" in $$props2)
      $$invalidate(2, className = $$props2.className);
    if ("override" in $$props2)
      $$invalidate(3, override = $$props2.override);
    if ("href" in $$props2)
      $$invalidate(4, href = $$props2.href);
    if ("active" in $$props2)
      $$invalidate(5, active = $$props2.active);
    if ("separator" in $$props2)
      $$invalidate(10, separator = $$props2.separator);
    if ("size" in $$props2)
      $$invalidate(15, size3 = $$props2.size);
    if ("color" in $$props2)
      $$invalidate(16, color = $$props2.color);
    if ("getStyles" in $$props2)
      $$invalidate(6, getStyles = $$props2.getStyles);
    if ("classes" in $$props2)
      $$invalidate(7, classes = $$props2.classes);
    if ("cx" in $$props2)
      $$invalidate(8, cx2 = $$props2.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $:
    $$invalidate(8, { cx: cx2, classes, getStyles } = BreadcrumbsItem_styles_default({ color, size: size3 }, { name: "BreadcrumbsItem" }), cx2, ($$invalidate(7, classes), $$invalidate(16, color), $$invalidate(15, size3)), ($$invalidate(6, getStyles), $$invalidate(16, color), $$invalidate(15, size3)));
  return [
    element2,
    use,
    className,
    override,
    href,
    active,
    getStyles,
    classes,
    cx2,
    state,
    separator,
    slots,
    box_element_binding,
    $$scope
  ];
}
var BreadcrumbsItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance39, create_fragment39, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      href: 4,
      active: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BreadcrumbsItem",
      options,
      id: create_fragment39.name
    });
  }
  get use() {
    throw new Error("<BreadcrumbsItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<BreadcrumbsItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<BreadcrumbsItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<BreadcrumbsItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<BreadcrumbsItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BreadcrumbsItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<BreadcrumbsItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<BreadcrumbsItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<BreadcrumbsItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<BreadcrumbsItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<BreadcrumbsItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<BreadcrumbsItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BreadcrumbsItem_default = BreadcrumbsItem;

// node_modules/@svelteuidev/core/dist/components/Breadcrumbs/combinator.js
Breadcrumbs_default.Item = BreadcrumbsItem_default;
var Breadcrumbs2 = Breadcrumbs_default;

// node_modules/@svelteuidev/core/dist/components/Burger/Burger.styles.js
var sizes4 = {
  xs: 12,
  sm: 18,
  md: 24,
  lg: 34,
  xl: 42
};
var Burger_styles_default = createStyles((theme4, { color, size: size3, opened }) => {
  const sizeValue = theme4.fn.size({ size: size3, sizes: sizes4 });
  return {
    root: {
      borderRadius: theme4.radii.sm.value,
      width: sizeValue + 10,
      height: sizeValue + 10,
      padding: +theme4.space.xs.value / 2,
      cursor: "pointer"
    },
    burger: {
      position: "relative",
      userSelect: "none",
      boxSizing: "border-box",
      "&, &:before, &:after": {
        [`${theme4.dark} &`]: {
          backgroundColor: theme4.fn.themeColor(color, 8)
        },
        display: "block",
        width: sizeValue,
        height: Math.ceil(sizeValue / 12),
        backgroundColor: theme4.fn.themeColor(color, 6),
        outline: "1px solid transparent",
        transitionProperty: "background-color, transform",
        transitionDuration: "300ms",
        "@media (prefers-reduced-motion)": {
          transitionDuration: "0ms"
        }
      },
      "&:before, &:after": {
        position: "absolute",
        content: '""',
        left: 0
      },
      "&:before": {
        top: sizeValue / 3 * -1
      },
      "&:after": {
        top: sizeValue / 3
      },
      "&.opened": opened ? {
        backgroundColor: "transparent",
        "&:before": {
          transform: `translateY(${sizeValue / 3}px) rotate(45deg)`
        },
        "&:after": {
          transform: `translateY(-${sizeValue / 3}px) rotate(-45deg)`
        }
      } : {}
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Burger/Burger.svelte
var file20 = "node_modules/@svelteuidev/core/dist/components/Burger/Burger.svelte";
function create_default_slot27(ctx8) {
  let span;
  let span_class_value;
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      children(span).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*cx*/
      ctx8[5](
        /*classes*/
        ctx8[7].burger,
        { opened: (
          /*opened*/
          ctx8[4]
        ) }
      ));
      add_location(span, file20, 20, 1, 925);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*cx, classes, opened*/
      176 && span_class_value !== (span_class_value = /*cx*/
      ctx9[5](
        /*classes*/
        ctx9[7].burger,
        { opened: (
          /*opened*/
          ctx9[4]
        ) }
      ))) {
        attr_dev(span, "class", span_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot27.name,
    type: "slot",
    source: "(14:0) <UnstyledButton  bind:element  use={[forwardEvents, [useActions, use]]}  override={{ padding: 5 }}  class={cx(className, classes.root, getStyles({ css: override }))}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment40(ctx8) {
  let unstyledbutton;
  let updating_element;
  let current;
  const unstyledbutton_spread_levels = [
    {
      use: [
        /*forwardEvents*/
        ctx8[8],
        [
          useActions,
          /*use*/
          ctx8[1]
        ]
      ]
    },
    { override: { padding: 5 } },
    {
      class: (
        /*cx*/
        ctx8[5](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[7].root,
          /*getStyles*/
          ctx8[6]({ css: (
            /*override*/
            ctx8[3]
          ) })
        )
      )
    },
    /*$$restProps*/
    ctx8[9]
  ];
  function unstyledbutton_element_binding(value) {
    ctx8[14](value);
  }
  let unstyledbutton_props = {
    $$slots: { default: [create_default_slot27] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < unstyledbutton_spread_levels.length; i2 += 1) {
    unstyledbutton_props = assign(unstyledbutton_props, unstyledbutton_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    unstyledbutton_props.element = /*element*/
    ctx8[0];
  }
  unstyledbutton = new UnstyledButton_default({
    props: unstyledbutton_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(unstyledbutton, "element", unstyledbutton_element_binding));
  const block = {
    c: function create() {
      create_component(unstyledbutton.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(unstyledbutton.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(unstyledbutton, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const unstyledbutton_changes = dirty & /*forwardEvents, use, cx, className, classes, getStyles, override, $$restProps*/
      1006 ? get_spread_update(unstyledbutton_spread_levels, [
        dirty & /*forwardEvents, use*/
        258 && {
          use: [
            /*forwardEvents*/
            ctx9[8],
            [
              useActions,
              /*use*/
              ctx9[1]
            ]
          ]
        },
        unstyledbutton_spread_levels[1],
        dirty & /*cx, className, classes, getStyles, override*/
        236 && {
          class: (
            /*cx*/
            ctx9[5](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[7].root,
              /*getStyles*/
              ctx9[6]({ css: (
                /*override*/
                ctx9[3]
              ) })
            )
          )
        },
        dirty & /*$$restProps*/
        512 && get_spread_object(
          /*$$restProps*/
          ctx9[9]
        )
      ]) : {};
      if (dirty & /*$$scope, cx, classes, opened*/
      32944) {
        unstyledbutton_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        unstyledbutton_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      unstyledbutton.$set(unstyledbutton_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(unstyledbutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(unstyledbutton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(unstyledbutton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance40($$self, $$props, $$invalidate) {
  let _color;
  let classes;
  let getStyles;
  let cx2;
  const omit_props_names = ["use", "element", "class", "override", "opened", "color", "size"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $colorScheme;
  validate_store(colorScheme, "colorScheme");
  component_subscribe($$self, colorScheme, ($$value) => $$invalidate(13, $colorScheme = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Burger", slots, []);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, opened = true, color = void 0, size: size3 = "md" } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  function unstyledbutton_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("opened" in $$new_props)
      $$invalidate(4, opened = $$new_props.opened);
    if ("color" in $$new_props)
      $$invalidate(10, color = $$new_props.color);
    if ("size" in $$new_props)
      $$invalidate(11, size3 = $$new_props.size);
  };
  $$self.$capture_state = () => ({
    useStyles: Burger_styles_default,
    UnstyledButton: UnstyledButton_default,
    colorScheme,
    get_current_component,
    createEventForwarder,
    useActions,
    use,
    element: element2,
    className,
    override,
    opened,
    color,
    size: size3,
    forwardEvents,
    _color,
    cx: cx2,
    getStyles,
    classes,
    $colorScheme
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("opened" in $$props)
      $$invalidate(4, opened = $$new_props.opened);
    if ("color" in $$props)
      $$invalidate(10, color = $$new_props.color);
    if ("size" in $$props)
      $$invalidate(11, size3 = $$new_props.size);
    if ("_color" in $$props)
      $$invalidate(12, _color = $$new_props._color);
    if ("cx" in $$props)
      $$invalidate(5, cx2 = $$new_props.cx);
    if ("getStyles" in $$props)
      $$invalidate(6, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(7, classes = $$new_props.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*color, $colorScheme*/
    9216) {
      $:
        $$invalidate(12, _color = color ? color : $colorScheme === "dark" ? "white" : "black");
    }
    if ($$self.$$.dirty & /*_color, size, opened*/
    6160) {
      $:
        $$invalidate(7, { classes, getStyles, cx: cx2 } = Burger_styles_default({ color: _color, size: size3, opened }, { name: "Burger" }), classes, ($$invalidate(6, getStyles), $$invalidate(12, _color), $$invalidate(11, size3), $$invalidate(4, opened), $$invalidate(10, color), $$invalidate(13, $colorScheme)), ($$invalidate(5, cx2), $$invalidate(12, _color), $$invalidate(11, size3), $$invalidate(4, opened), $$invalidate(10, color), $$invalidate(13, $colorScheme)));
    }
  };
  return [
    element2,
    use,
    className,
    override,
    opened,
    cx2,
    getStyles,
    classes,
    forwardEvents,
    $$restProps,
    color,
    size3,
    _color,
    $colorScheme,
    unstyledbutton_element_binding
  ];
}
var Burger = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance40, create_fragment40, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      opened: 4,
      color: 10,
      size: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Burger",
      options,
      id: create_fragment40.name
    });
  }
  get use() {
    throw new Error("<Burger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Burger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Burger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Burger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Burger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Burger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Burger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Burger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opened() {
    throw new Error("<Burger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opened(value) {
    throw new Error("<Burger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Burger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Burger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Burger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Burger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Burger_default = Burger;

// node_modules/@svelteuidev/core/dist/components/Card/Card.styles.js
var Card_styles_default = createStyles((theme4) => {
  return {
    root: {
      position: "relative",
      overflow: "hidden",
      backgroundColor: theme4.colors.white.value
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Paper/Paper.styles.js
var Paper_styles_default = createStyles((theme4, { radius: radius2, shadow, withBorder, padding: padding3 }) => {
  return {
    root: {
      darkMode: {
        backgroundColor: theme4.fn.themeColor("dark", 7),
        color: theme4.fn.themeColor("dark")
      },
      padding: theme4.fn.size({ size: padding3, sizes: theme4.space }),
      outline: 0,
      display: "block",
      textDecoration: "none",
      color: theme4.colors.black.value,
      backgroundColor: theme4.colors.white.value,
      boxSizing: "border-box",
      borderRadius: `$${radius2}`,
      WebkitTapHighlightColor: "transparent",
      boxShadow: theme4.shadows[shadow].value || shadow || "none",
      border: void 0
    },
    withBorder: {
      darkMode: {
        border: `1px solid ${theme4.fn.themeColor("dark", 4)}`
      },
      border: `1px solid ${theme4.fn.themeColor("gray", 3)}`
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Paper/Paper.svelte
function create_default_slot28(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[14],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[14],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot28.name,
    type: "slot",
    source: "(8:0) <Box  bind:element  class={cx(   classes.root,   className,   withBorder && classes.withBorder,   getStyles({ css: override })  )}  {use}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment41(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    {
      class: (
        /*cx*/
        ctx8[7](
          /*classes*/
          ctx8[6].root,
          /*className*/
          ctx8[2],
          /*withBorder*/
          ctx8[4] && /*classes*/
          ctx8[6].withBorder,
          /*getStyles*/
          ctx8[5]({ css: (
            /*override*/
            ctx8[3]
          ) })
        )
      )
    },
    { use: (
      /*use*/
      ctx8[1]
    ) },
    /*$$restProps*/
    ctx8[8]
  ];
  function box_element_binding(value) {
    ctx8[13](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot28] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*cx, classes, className, withBorder, getStyles, override, use, $$restProps*/
      510 ? get_spread_update(box_spread_levels, [
        dirty & /*cx, classes, className, withBorder, getStyles, override*/
        252 && {
          class: (
            /*cx*/
            ctx9[7](
              /*classes*/
              ctx9[6].root,
              /*className*/
              ctx9[2],
              /*withBorder*/
              ctx9[4] && /*classes*/
              ctx9[6].withBorder,
              /*getStyles*/
              ctx9[5]({ css: (
                /*override*/
                ctx9[3]
              ) })
            )
          )
        },
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*$$restProps*/
        256 && get_spread_object(
          /*$$restProps*/
          ctx9[8]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      16384) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment41.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance41($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = ["use", "element", "class", "override", "shadow", "radius", "withBorder", "padding"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Paper", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, shadow = "xs", radius: radius2 = "sm", withBorder = false, padding: padding3 = "md" } = $$props;
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("shadow" in $$new_props)
      $$invalidate(9, shadow = $$new_props.shadow);
    if ("radius" in $$new_props)
      $$invalidate(10, radius2 = $$new_props.radius);
    if ("withBorder" in $$new_props)
      $$invalidate(4, withBorder = $$new_props.withBorder);
    if ("padding" in $$new_props)
      $$invalidate(11, padding3 = $$new_props.padding);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: Paper_styles_default,
    Box: Box_default,
    use,
    element: element2,
    className,
    override,
    shadow,
    radius: radius2,
    withBorder,
    padding: padding3,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("shadow" in $$props)
      $$invalidate(9, shadow = $$new_props.shadow);
    if ("radius" in $$props)
      $$invalidate(10, radius2 = $$new_props.radius);
    if ("withBorder" in $$props)
      $$invalidate(4, withBorder = $$new_props.withBorder);
    if ("padding" in $$props)
      $$invalidate(11, padding3 = $$new_props.padding);
    if ("getStyles" in $$props)
      $$invalidate(5, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(6, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(7, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*radius, shadow, withBorder, padding*/
    3600) {
      $:
        $$invalidate(7, { cx: cx2, classes, getStyles } = Paper_styles_default({ radius: radius2, shadow, withBorder, padding: padding3 }, { name: "Paper" }), cx2, ($$invalidate(6, classes), $$invalidate(10, radius2), $$invalidate(9, shadow), $$invalidate(4, withBorder), $$invalidate(11, padding3)), ($$invalidate(5, getStyles), $$invalidate(10, radius2), $$invalidate(9, shadow), $$invalidate(4, withBorder), $$invalidate(11, padding3)));
    }
  };
  return [
    element2,
    use,
    className,
    override,
    withBorder,
    getStyles,
    classes,
    cx2,
    $$restProps,
    shadow,
    radius2,
    padding3,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Paper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance41, create_fragment41, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      shadow: 9,
      radius: 10,
      withBorder: 4,
      padding: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Paper",
      options,
      id: create_fragment41.name
    });
  }
  get use() {
    throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withBorder() {
    throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withBorder(value) {
    throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Paper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Paper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Paper_default = Paper;

// node_modules/@svelteuidev/core/dist/components/Card/Card.svelte
function create_default_slot29(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[11],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[11],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot29.name,
    type: "slot",
    source: "(22:0) <Paper  bind:element  class={cx(className, classes.root)}  override={{   [`${theme.dark} &`]: {    backgroundColor: theme.fn.themeColor('dark', 6)   },   ...override  }}  {padding}  {use}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment42(ctx8) {
  let paper;
  let updating_element;
  let current;
  const paper_spread_levels = [
    {
      class: (
        /*cx*/
        ctx8[7](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[6].root
        )
      )
    },
    {
      override: {
        [`${/*theme*/
        ctx8[5].dark} &`]: {
          backgroundColor: (
            /*theme*/
            ctx8[5].fn.themeColor("dark", 6)
          )
        },
        .../*override*/
        ctx8[3]
      }
    },
    { padding: (
      /*padding*/
      ctx8[4]
    ) },
    { use: (
      /*use*/
      ctx8[1]
    ) },
    /*$$restProps*/
    ctx8[8]
  ];
  function paper_element_binding(value) {
    ctx8[10](value);
  }
  let paper_props = {
    $$slots: { default: [create_default_slot29] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < paper_spread_levels.length; i2 += 1) {
    paper_props = assign(paper_props, paper_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    paper_props.element = /*element*/
    ctx8[0];
  }
  paper = new Paper_default({ props: paper_props, $$inline: true });
  binding_callbacks.push(() => bind(paper, "element", paper_element_binding));
  const block = {
    c: function create() {
      create_component(paper.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(paper.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(paper, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const paper_changes = dirty & /*cx, className, classes, theme, override, padding, use, $$restProps*/
      510 ? get_spread_update(paper_spread_levels, [
        dirty & /*cx, className, classes*/
        196 && {
          class: (
            /*cx*/
            ctx9[7](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[6].root
            )
          )
        },
        dirty & /*theme, override*/
        40 && {
          override: {
            [`${/*theme*/
            ctx9[5].dark} &`]: {
              backgroundColor: (
                /*theme*/
                ctx9[5].fn.themeColor("dark", 6)
              )
            },
            .../*override*/
            ctx9[3]
          }
        },
        dirty & /*padding*/
        16 && { padding: (
          /*padding*/
          ctx9[4]
        ) },
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*$$restProps*/
        256 && get_spread_object(
          /*$$restProps*/
          ctx9[8]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      2048) {
        paper_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        paper_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      paper.$set(paper_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(paper.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(paper.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(paper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment42.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance42($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let theme4;
  const omit_props_names = ["use", "element", "class", "override", "padding"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Card", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, padding: padding3 = "md" } = $$props;
  onMount(() => {
    const nodeLength = element2.children.length;
    const firstChild = element2.children[0];
    const lastChild = element2.children[nodeLength - 1];
    if ((firstChild == null ? void 0 : firstChild.id) === "svelteui_card_section") {
      firstChild.style.marginTop = `${-1 * theme4.fn.size({ size: padding3, sizes: theme4.space })}px`;
    }
    if ((lastChild == null ? void 0 : lastChild.id) === "svelteui_card_section") {
      lastChild.style.marginBottom = `${-1 * theme4.fn.size({ size: padding3, sizes: theme4.space })}px`;
    }
  });
  function paper_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("padding" in $$new_props)
      $$invalidate(4, padding3 = $$new_props.padding);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: Card_styles_default,
    Paper: Paper_default,
    onMount,
    use,
    element: element2,
    className,
    override,
    padding: padding3,
    theme: theme4,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("padding" in $$props)
      $$invalidate(4, padding3 = $$new_props.padding);
    if ("theme" in $$props)
      $$invalidate(5, theme4 = $$new_props.theme);
    if ("classes" in $$props)
      $$invalidate(6, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(7, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $:
    $$invalidate(7, { cx: cx2, classes, theme: theme4 } = Card_styles_default(null, { name: "Card" }), cx2, $$invalidate(6, classes), $$invalidate(5, theme4));
  return [
    element2,
    use,
    className,
    override,
    padding3,
    theme4,
    classes,
    cx2,
    $$restProps,
    slots,
    paper_element_binding,
    $$scope
  ];
}
var Card = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance42, create_fragment42, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      padding: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Card",
      options,
      id: create_fragment42.name
    });
  }
  get use() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Card_default = Card;

// node_modules/@svelteuidev/core/dist/components/Card/CardSection/CardSection.styles.js
var CardSection_styles_default = createStyles((theme4, { padding: padding3 }) => {
  return {
    root: {
      display: "block",
      marginLeft: -1 * theme4.fn.size({ size: padding3, sizes: theme4.space }),
      marginRight: -1 * theme4.fn.size({ size: padding3, sizes: theme4.space })
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Card/CardSection/CardSection.svelte
function create_default_slot30(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[11],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[11],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot30.name,
    type: "slot",
    source: '(8:0) <Box  id=\\"svelteui_card_section\\"  bind:element  class={cx(className, classes.root, getStyles({ css: override }))}  {use}  {...$$restProps} >',
    ctx: ctx8
  });
  return block;
}
function create_fragment43(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { id: "svelteui_card_section" },
    {
      class: (
        /*cx*/
        ctx8[6](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[5].root,
          /*getStyles*/
          ctx8[4]({ css: (
            /*override*/
            ctx8[3]
          ) })
        )
      )
    },
    { use: (
      /*use*/
      ctx8[1]
    ) },
    /*$$restProps*/
    ctx8[7]
  ];
  function box_element_binding(value) {
    ctx8[10](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot30] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*cx, className, classes, getStyles, override, use, $$restProps*/
      254 ? get_spread_update(box_spread_levels, [
        box_spread_levels[0],
        dirty & /*cx, className, classes, getStyles, override*/
        124 && {
          class: (
            /*cx*/
            ctx9[6](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[5].root,
              /*getStyles*/
              ctx9[4]({ css: (
                /*override*/
                ctx9[3]
              ) })
            )
          )
        },
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*$$restProps*/
        128 && get_spread_object(
          /*$$restProps*/
          ctx9[7]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      2048) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment43.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance43($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = ["use", "element", "class", "override", "padding"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardSection", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, padding: padding3 = "md" } = $$props;
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("padding" in $$new_props)
      $$invalidate(8, padding3 = $$new_props.padding);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: CardSection_styles_default,
    Box: Box_default,
    use,
    element: element2,
    className,
    override,
    padding: padding3,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("padding" in $$props)
      $$invalidate(8, padding3 = $$new_props.padding);
    if ("getStyles" in $$props)
      $$invalidate(4, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(5, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(6, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*padding*/
    256) {
      $:
        $$invalidate(6, { cx: cx2, classes, getStyles } = CardSection_styles_default({ padding: padding3 }), cx2, ($$invalidate(5, classes), $$invalidate(8, padding3)), ($$invalidate(4, getStyles), $$invalidate(8, padding3)));
    }
  };
  return [
    element2,
    use,
    className,
    override,
    getStyles,
    classes,
    cx2,
    $$restProps,
    padding3,
    slots,
    box_element_binding,
    $$scope
  ];
}
var CardSection = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance43, create_fragment43, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      padding: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardSection",
      options,
      id: create_fragment43.name
    });
  }
  get use() {
    throw new Error("<CardSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<CardSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<CardSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<CardSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CardSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CardSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<CardSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<CardSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<CardSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<CardSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardSection_default = CardSection;

// node_modules/@svelteuidev/core/dist/components/Card/combinator.js
Card_default.Section = CardSection_default;
var Card2 = Card_default;

// node_modules/@svelteuidev/core/dist/components/Center/Center.styles.js
var Center_styles_default = createStyles((_, { inline }) => {
  return {
    root: {
      display: inline ? "inline-flex" : "flex",
      alignItems: "center",
      justifyContent: "center"
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Center/Center.svelte
function create_default_slot31(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[11],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[11],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot31.name,
    type: "slot",
    source: "(21:0) <Box  bind:element  {use}  class={cx(className, classes.root, getStyles({ css: override }))}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment44(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { use: (
      /*use*/
      ctx8[1]
    ) },
    {
      class: (
        /*cx*/
        ctx8[6](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[5].root,
          /*getStyles*/
          ctx8[4]({ css: (
            /*override*/
            ctx8[3]
          ) })
        )
      )
    },
    /*$$restProps*/
    ctx8[7]
  ];
  function box_element_binding(value) {
    ctx8[10](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot31] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*use, cx, className, classes, getStyles, override, $$restProps*/
      254 ? get_spread_update(box_spread_levels, [
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*cx, className, classes, getStyles, override*/
        124 && {
          class: (
            /*cx*/
            ctx9[6](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[5].root,
              /*getStyles*/
              ctx9[4]({ css: (
                /*override*/
                ctx9[3]
              ) })
            )
          )
        },
        dirty & /*$$restProps*/
        128 && get_spread_object(
          /*$$restProps*/
          ctx9[7]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      2048) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment44.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance44($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = ["use", "element", "class", "override", "inline"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Center", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, inline = false } = $$props;
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("inline" in $$new_props)
      $$invalidate(8, inline = $$new_props.inline);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: Center_styles_default,
    Box: Box_default,
    use,
    element: element2,
    className,
    override,
    inline,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("inline" in $$props)
      $$invalidate(8, inline = $$new_props.inline);
    if ("getStyles" in $$props)
      $$invalidate(4, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(5, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(6, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*inline*/
    256) {
      $:
        $$invalidate(6, { cx: cx2, classes, getStyles } = Center_styles_default({ inline }, { name: "Center" }), cx2, ($$invalidate(5, classes), $$invalidate(8, inline)), ($$invalidate(4, getStyles), $$invalidate(8, inline)));
    }
  };
  return [
    element2,
    use,
    className,
    override,
    getStyles,
    classes,
    cx2,
    $$restProps,
    inline,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Center = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance44, create_fragment44, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      inline: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Center",
      options,
      id: create_fragment44.name
    });
  }
  get use() {
    throw new Error("<Center>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Center>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Center>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Center>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Center>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Center>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Center>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Center>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error("<Center>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<Center>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Center_default = Center;

// node_modules/@svelteuidev/core/dist/components/Checkbox/Checkbox.styles.js
var sizes5 = {
  xs: 16,
  sm: 20,
  md: 24,
  lg: 30,
  xl: 36
};
var iconSizes = {
  xs: 8,
  sm: 10,
  md: 14,
  lg: 16,
  xl: 20
};
var Checkbox_styles_default = createStyles((theme4, { color, radius: radius2, size: size3, transitionDuration }, getRef) => {
  return {
    root: {
      display: "flex",
      alignItems: "center"
    },
    inner: {
      position: "relative",
      width: sizes5[size3],
      height: sizes5[size3]
    },
    label: {
      cursor: "pointer",
      WebkitTapHighlightColor: "transparent",
      paddingLeft: theme4.fn.size({ size: size3, sizes: theme4.space }),
      fontSize: `$${size3}`,
      lineHeight: `$${size3}`,
      color: "#000000",
      darkMode: {
        color: "$dark000"
      }
    },
    input: {
      cursor: "pointer",
      appearance: "none",
      backgroundColor: "#ffffff",
      borderWidth: "1px",
      borderStyle: "solid",
      borderColor: "$gray400",
      width: sizes5[size3],
      height: sizes5[size3],
      borderRadius: `$${radius2}`,
      padding: 0,
      display: "block",
      margin: 0,
      transition: `border-color ${transitionDuration}ms ease, background-color ${transitionDuration}ms ease`,
      darkMode: {
        "&:not(:checked)": {
          backgroundColor: "$dark400",
          borderColor: "$dark400"
        }
      },
      "&:checked": {
        border: "transparent",
        backgroundColor: theme4.fn.themeColor(color, 6),
        color: "#ffffff",
        borderRadius: `$${radius2}`,
        [`& + .${getRef("iconWrapper")}`]: {
          opacity: 1,
          transform: "translateY(0) scale(1)"
        }
      },
      "&:disabled": {
        backgroundColor: "$gray200",
        borderColor: "$gray300",
        cursor: "not-allowed",
        [`& + .${getRef("iconWrapper")}`]: {
          color: "$gray500",
          backgroundColor: "$gray200",
          borderColor: "$gray300"
        },
        darkMode: {
          backgroundColor: "$dark400",
          borderColor: "$dark600",
          [`& + .${getRef("icon")}`]: {
            color: "$dark600"
          }
        }
      }
    },
    iconWrapper: {
      ref: getRef("iconWrapper"),
      color: "#ffffff",
      transform: "translateY(5px) scale(0.5)",
      opacity: 0,
      transitionProperty: "opacity, transform",
      transitionTimingFunction: "ease",
      transitionDuration: `${transitionDuration}ms`,
      pointerEvents: "none",
      width: sizes5[size3],
      height: sizes5[size3],
      minWidth: sizes5[size3],
      minHeight: sizes5[size3],
      borderRadius: `$${radius2}`,
      position: "absolute",
      zIndex: 1,
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      margin: "auto",
      "@media (prefers-reduced-motion)": {
        transitionDuration: "0ms"
      }
    },
    icon: {
      ref: getRef("icon"),
      color: "#ffffff",
      width: iconSizes[size3],
      height: iconSizes[size3],
      minWidth: iconSizes[size3],
      minHeight: iconSizes[size3],
      "@media (prefers-reduced-motion)": {
        transitionDuration: "0ms"
      }
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/ThemeIcon/ThemeIcon.styles.js
var { rgba: rgba2 } = fns;
var sizes6 = {
  xs: 16,
  sm: 20,
  md: 26,
  lg: 32,
  xl: 40
};
function getVariantStyles2(color, variant2, gradient) {
  const ctx8 = { from: "blue", to: "cyan", deg: 45 };
  if (variant2 === "gradient")
    return getVariant(color, gradient);
  return getVariant(color, ctx8);
}
var getVariant = (color, gradient) => {
  const dtm = {
    lightBg: dark.colors[`${color}800`].value,
    lightHv: dark.colors[`${color}700`].value,
    outlineHv: dark.colors[`${color}400`].value,
    subtleHv: dark.colors[`${color}800`].value
  };
  return {
    /** Filled variant */
    filled: {
      [`${dark.selector} &`]: {
        backgroundColor: `$${color}800`
      },
      border: "transparent",
      backgroundColor: `$${color}600`,
      color: "White"
    },
    /** Light variant */
    light: {
      [`${dark.selector} &`]: {
        backgroundColor: rgba2(dtm.lightBg, 0.35),
        color: color === "dark" ? "$dark50" : `$${color}200`
      },
      border: "transparent",
      backgroundColor: `$${color}50`,
      color: color === "dark" ? "$dark900" : `$${color}600`
    },
    /** Outline variant */
    outline: {
      [`${dark.selector} &`]: {
        border: `1px solid $${color}400`,
        color: `$${color}400`
      },
      border: `1px solid $${color}700`,
      backgroundColor: "transparent",
      color: `$${color}700`
    },
    /** Subtle variant */
    subtle: {
      [`${dark.selector} &`]: {
        color: color === "dark" ? "$dark50" : `$${color}200`
      },
      border: "transparent",
      backgroundColor: "transparent",
      color: color === "dark" ? "$dark900" : `$${color}600`
    },
    /** Default variant */
    default: {
      [`${dark.selector} &`]: {
        border: "1px solid $dark500",
        backgroundColor: "$dark500",
        color: "White"
      },
      border: "1px solid $gray400",
      backgroundColor: "White",
      color: "Black"
    },
    /** White variant */
    white: {
      border: "transparent",
      backgroundColor: "White",
      color: `$${color}700`
    },
    /** Gradient variant */
    gradient: {
      border: "transparent",
      background: `linear-gradient(${gradient.deg}deg, $${gradient.from}600 0%, $${gradient.to}600 100%)`,
      color: "White"
    }
  };
};
var ThemeIcon_styles_default = createStyles((_, { color, gradient, iconSize, radius: radius2, variant: variant2 }) => {
  return {
    root: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      boxSizing: "border-box",
      width: iconSize,
      height: iconSize,
      minWidth: iconSize,
      minHeight: iconSize,
      borderRadius: `$${radius2}`,
      variants: {
        variation: getVariantStyles2(color, variant2, gradient)
      }
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/ThemeIcon/ThemeIcon.svelte
function create_default_slot32(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[16],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[16],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot32.name,
    type: "slot",
    source: "(28:0) <Box  bind:element  {use}  class={cx(className, classes.root, getStyles({ css: override, variation: variant }))}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment45(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { use: (
      /*use*/
      ctx8[1]
    ) },
    {
      class: (
        /*cx*/
        ctx8[7](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[6].root,
          /*getStyles*/
          ctx8[5]({
            css: (
              /*override*/
              ctx8[3]
            ),
            variation: (
              /*variant*/
              ctx8[4]
            )
          })
        )
      )
    },
    /*$$restProps*/
    ctx8[8]
  ];
  function box_element_binding(value) {
    ctx8[15](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot32] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*use, cx, className, classes, getStyles, override, variant, $$restProps*/
      510 ? get_spread_update(box_spread_levels, [
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*cx, className, classes, getStyles, override, variant*/
        252 && {
          class: (
            /*cx*/
            ctx9[7](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[6].root,
              /*getStyles*/
              ctx9[5]({
                css: (
                  /*override*/
                  ctx9[3]
                ),
                variation: (
                  /*variant*/
                  ctx9[4]
                )
              })
            )
          )
        },
        dirty & /*$$restProps*/
        256 && get_spread_object(
          /*$$restProps*/
          ctx9[8]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      65536) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment45.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance45($$self, $$props, $$invalidate) {
  let iconSize;
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "size",
    "radius",
    "color",
    "variant",
    "gradient"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ThemeIcon", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, size: size3 = "md", radius: radius2 = "sm", color = "blue", variant: variant2 = "filled", gradient = { from: "blue", to: "cyan", deg: 45 } } = $$props;
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("size" in $$new_props)
      $$invalidate(9, size3 = $$new_props.size);
    if ("radius" in $$new_props)
      $$invalidate(10, radius2 = $$new_props.radius);
    if ("color" in $$new_props)
      $$invalidate(11, color = $$new_props.color);
    if ("variant" in $$new_props)
      $$invalidate(4, variant2 = $$new_props.variant);
    if ("gradient" in $$new_props)
      $$invalidate(12, gradient = $$new_props.gradient);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Box: Box_default,
    useStyles: ThemeIcon_styles_default,
    sizes: sizes6,
    use,
    element: element2,
    className,
    override,
    size: size3,
    radius: radius2,
    color,
    variant: variant2,
    gradient,
    iconSize,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("size" in $$props)
      $$invalidate(9, size3 = $$new_props.size);
    if ("radius" in $$props)
      $$invalidate(10, radius2 = $$new_props.radius);
    if ("color" in $$props)
      $$invalidate(11, color = $$new_props.color);
    if ("variant" in $$props)
      $$invalidate(4, variant2 = $$new_props.variant);
    if ("gradient" in $$props)
      $$invalidate(12, gradient = $$new_props.gradient);
    if ("iconSize" in $$props)
      $$invalidate(13, iconSize = $$new_props.iconSize);
    if ("getStyles" in $$props)
      $$invalidate(5, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(6, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(7, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*size*/
    512) {
      $:
        $$invalidate(13, iconSize = typeof size3 === "number" ? `${size3}px` : sizes6[size3] ?? sizes6.md);
    }
    if ($$self.$$.dirty & /*color, gradient, iconSize, radius, variant*/
    15376) {
      $:
        $$invalidate(
          7,
          { cx: cx2, classes, getStyles } = ThemeIcon_styles_default(
            {
              color,
              gradient,
              iconSize,
              radius: radius2,
              variant: variant2
            },
            { name: "ThemeIcon" }
          ),
          cx2,
          ($$invalidate(6, classes), $$invalidate(11, color), $$invalidate(12, gradient), $$invalidate(13, iconSize), $$invalidate(10, radius2), $$invalidate(4, variant2), $$invalidate(9, size3)),
          ($$invalidate(5, getStyles), $$invalidate(11, color), $$invalidate(12, gradient), $$invalidate(13, iconSize), $$invalidate(10, radius2), $$invalidate(4, variant2), $$invalidate(9, size3))
        );
    }
  };
  return [
    element2,
    use,
    className,
    override,
    variant2,
    getStyles,
    classes,
    cx2,
    $$restProps,
    size3,
    radius2,
    color,
    gradient,
    iconSize,
    slots,
    box_element_binding,
    $$scope
  ];
}
var ThemeIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance45, create_fragment45, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      size: 9,
      radius: 10,
      color: 11,
      variant: 4,
      gradient: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ThemeIcon",
      options,
      id: create_fragment45.name
    });
  }
  get use() {
    throw new Error("<ThemeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<ThemeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<ThemeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<ThemeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ThemeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ThemeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<ThemeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<ThemeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<ThemeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ThemeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<ThemeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<ThemeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<ThemeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<ThemeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<ThemeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<ThemeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gradient() {
    throw new Error("<ThemeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gradient(value) {
    throw new Error("<ThemeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ThemeIcon_default = ThemeIcon;

// node_modules/@svelteuidev/core/dist/components/Checkbox/CheckboxIcon.svelte
var file21 = "node_modules/@svelteuidev/core/dist/components/Checkbox/CheckboxIcon.svelte";
function create_else_block7(ctx8) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        class: true,
        viewBox: true,
        fill: true,
        xmlns: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", {
        d: true,
        fill: true,
        "fill-rule": true,
        "clip-rule": true
      });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 4.586L1.707 2.293A1 1 0 1 0 .293 3.707l3 3a.997.997 0 0 0 1.414 0l5-5A1 1 0 1 0 8.293.293L4 4.586z");
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "clip-rule", "evenodd");
      add_location(path, file21, 11, 2, 391);
      attr_dev(
        svg,
        "class",
        /*className*/
        ctx8[0]
      );
      attr_dev(svg, "viewBox", "0 0 10 7");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      add_location(svg, file21, 10, 1, 299);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*className*/
      1) {
        attr_dev(
          svg,
          "class",
          /*className*/
          ctx9[0]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block7.name,
    type: "else",
    source: "(10:0) {:else}",
    ctx: ctx8
  });
  return block;
}
function create_if_block13(ctx8) {
  let svg;
  let rect;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        class: true,
        xmlns: true,
        fill: true,
        viewBox: true
      });
      var svg_nodes = children(svg);
      rect = claim_svg_element(svg_nodes, "rect", {
        width: true,
        height: true,
        fill: true,
        rx: true
      });
      children(rect).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "width", "32");
      attr_dev(rect, "height", "6");
      attr_dev(rect, "fill", "currentColor");
      attr_dev(rect, "rx", "3");
      add_location(rect, file21, 7, 2, 224);
      attr_dev(
        svg,
        "class",
        /*className*/
        ctx8[0]
      );
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 32 6");
      add_location(svg, file21, 6, 1, 132);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, rect);
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*className*/
      1) {
        attr_dev(
          svg,
          "class",
          /*className*/
          ctx9[0]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block13.name,
    type: "if",
    source: "(6:0) {#if indeterminate}",
    ctx: ctx8
  });
  return block;
}
function create_fragment46(ctx8) {
  let if_block_anchor;
  function select_block_type(ctx9, dirty) {
    if (
      /*indeterminate*/
      ctx9[1]
    )
      return create_if_block13;
    return create_else_block7;
  }
  let current_block_type = select_block_type(ctx8, -1);
  let if_block = current_block_type(ctx8);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx9, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx9, dirty)) && if_block) {
        if_block.p(ctx9, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx9);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment46.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance46($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CheckboxIcon", slots, []);
  let { class: className = "" } = $$props;
  let { indeterminate = false } = $$props;
  const writable_props = ["class", "indeterminate"];
  Object.keys($$props).forEach((key3) => {
    if (!~writable_props.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<CheckboxIcon> was created with unknown prop '${key3}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2)
      $$invalidate(0, className = $$props2.class);
    if ("indeterminate" in $$props2)
      $$invalidate(1, indeterminate = $$props2.indeterminate);
  };
  $$self.$capture_state = () => ({ className, indeterminate });
  $$self.$inject_state = ($$props2) => {
    if ("className" in $$props2)
      $$invalidate(0, className = $$props2.className);
    if ("indeterminate" in $$props2)
      $$invalidate(1, indeterminate = $$props2.indeterminate);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [className, indeterminate];
}
var CheckboxIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance46, create_fragment46, safe_not_equal, { class: 0, indeterminate: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CheckboxIcon",
      options,
      id: create_fragment46.name
    });
  }
  get class() {
    throw new Error("<CheckboxIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CheckboxIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indeterminate() {
    throw new Error("<CheckboxIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indeterminate(value) {
    throw new Error("<CheckboxIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CheckboxIcon_default = CheckboxIcon;

// node_modules/@svelteuidev/core/dist/components/Checkbox/Checkbox.svelte
var file22 = "node_modules/@svelteuidev/core/dist/components/Checkbox/Checkbox.svelte";
function fallback_block7(ctx8) {
  let checkboxicon;
  let current;
  checkboxicon = new CheckboxIcon_default({
    props: {
      class: (
        /*classes*/
        ctx8[14].icon
      ),
      indeterminate: (
        /*indeterminate*/
        ctx8[8]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(checkboxicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(checkboxicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(checkboxicon, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const checkboxicon_changes = {};
      if (dirty & /*classes*/
      16384)
        checkboxicon_changes.class = /*classes*/
        ctx9[14].icon;
      if (dirty & /*indeterminate*/
      256)
        checkboxicon_changes.indeterminate = /*indeterminate*/
        ctx9[8];
      checkboxicon.$set(checkboxicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkboxicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkboxicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(checkboxicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block7.name,
    type: "fallback",
    source: "(51:9)      ",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_14(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[24],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block7(ctx8);
  const block = {
    c: function create() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16777216)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[24],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[24]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[24],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*classes, indeterminate*/
        16640)) {
          default_slot_or_fallback.p(ctx9, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_14.name,
    type: "slot",
    source: "(50:2) <ThemeIcon class={classes.iconWrapper} variant={null} {size}>",
    ctx: ctx8
  });
  return block;
}
function create_if_block14(ctx8) {
  let label_1;
  let t;
  let label_1_class_value;
  const block = {
    c: function create() {
      label_1 = element("label");
      t = text(
        /*label*/
        ctx8[9]
      );
      this.h();
    },
    l: function claim(nodes) {
      label_1 = claim_element(nodes, "LABEL", { class: true, for: true });
      var label_1_nodes = children(label_1);
      t = claim_text(
        label_1_nodes,
        /*label*/
        ctx8[9]
      );
      label_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(label_1, "class", label_1_class_value = /*classes*/
      ctx8[14].label);
      attr_dev(
        label_1,
        "for",
        /*id*/
        ctx8[5]
      );
      add_location(label_1, file22, 56, 2, 1813);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label_1, anchor);
      append_hydration_dev(label_1, t);
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*label*/
      512)
        set_data_dev(
          t,
          /*label*/
          ctx9[9]
        );
      if (dirty & /*classes*/
      16384 && label_1_class_value !== (label_1_class_value = /*classes*/
      ctx9[14].label)) {
        attr_dev(label_1, "class", label_1_class_value);
      }
      if (dirty & /*id*/
      32) {
        attr_dev(
          label_1,
          "for",
          /*id*/
          ctx9[5]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block14.name,
    type: "if",
    source: "(56:1) {#if label}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot33(ctx8) {
  let div;
  let input;
  let input_class_value;
  let useActions_action;
  let forwardEvents_action;
  let t0;
  let themeicon;
  let div_class_value;
  let t1;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  themeicon = new ThemeIcon_default({
    props: {
      class: (
        /*classes*/
        ctx8[14].iconWrapper
      ),
      variant: null,
      size: (
        /*size*/
        ctx8[10]
      ),
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  let if_block = (
    /*label*/
    ctx8[9] && create_if_block14(ctx8)
  );
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      t0 = space();
      create_component(themeicon.$$.fragment);
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      input = claim_element(div_nodes, "INPUT", {
        class: true,
        type: true,
        id: true,
        name: true
      });
      t0 = claim_space(div_nodes);
      claim_component(themeicon.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "class", input_class_value = /*classes*/
      ctx8[14].input);
      attr_dev(input, "type", "checkbox");
      input.disabled = /*disabled*/
      ctx8[6];
      input.required = /*required*/
      ctx8[12];
      input.__value = /*value*/
      ctx8[7];
      set_input_value(input, input.__value);
      attr_dev(
        input,
        "id",
        /*id*/
        ctx8[5]
      );
      attr_dev(
        input,
        "name",
        /*name*/
        ctx8[11]
      );
      toggle_class(
        input,
        "disabled",
        /*disabled*/
        ctx8[6]
      );
      add_location(input, file22, 36, 2, 1440);
      attr_dev(div, "class", div_class_value = /*classes*/
      ctx8[14].inner);
      add_location(div, file22, 35, 1, 1410);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, input);
      input.checked = /*checked*/
      ctx8[0];
      append_hydration_dev(div, t0);
      mount_component(themeicon, div, null);
      insert_hydration_dev(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            input,
            /*use*/
            ctx8[2]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx8[16].call(null, input)),
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx8[22]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx9, dirty) {
      if (!current || dirty & /*classes*/
      16384 && input_class_value !== (input_class_value = /*classes*/
      ctx9[14].input)) {
        attr_dev(input, "class", input_class_value);
      }
      if (!current || dirty & /*disabled*/
      64) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx9[6]
        );
      }
      if (!current || dirty & /*required*/
      4096) {
        prop_dev(
          input,
          "required",
          /*required*/
          ctx9[12]
        );
      }
      if (!current || dirty & /*value*/
      128) {
        prop_dev(
          input,
          "__value",
          /*value*/
          ctx9[7]
        );
        set_input_value(input, input.__value);
      }
      if (!current || dirty & /*id*/
      32) {
        attr_dev(
          input,
          "id",
          /*id*/
          ctx9[5]
        );
      }
      if (!current || dirty & /*name*/
      2048) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx9[11]
        );
      }
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      4)
        useActions_action.update.call(
          null,
          /*use*/
          ctx9[2]
        );
      if (dirty & /*checked*/
      1) {
        input.checked = /*checked*/
        ctx9[0];
      }
      if (!current || dirty & /*classes, disabled*/
      16448) {
        toggle_class(
          input,
          "disabled",
          /*disabled*/
          ctx9[6]
        );
      }
      const themeicon_changes = {};
      if (dirty & /*classes*/
      16384)
        themeicon_changes.class = /*classes*/
        ctx9[14].iconWrapper;
      if (dirty & /*size*/
      1024)
        themeicon_changes.size = /*size*/
        ctx9[10];
      if (dirty & /*$$scope, classes, indeterminate*/
      16793856) {
        themeicon_changes.$$scope = { dirty, ctx: ctx9 };
      }
      themeicon.$set(themeicon_changes);
      if (!current || dirty & /*classes*/
      16384 && div_class_value !== (div_class_value = /*classes*/
      ctx9[14].inner)) {
        attr_dev(div, "class", div_class_value);
      }
      if (
        /*label*/
        ctx9[9]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
        } else {
          if_block = create_if_block14(ctx9);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(themeicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(themeicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
        detach_dev(t1);
        detach_dev(if_block_anchor);
      }
      destroy_component(themeicon);
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot33.name,
    type: "slot",
    source: "(31:0) <Box  bind:element  class={cx(className, classes.root, getStyles({ css: override }))}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment47(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    {
      class: (
        /*cx*/
        ctx8[15](
          /*className*/
          ctx8[3],
          /*classes*/
          ctx8[14].root,
          /*getStyles*/
          ctx8[13]({ css: (
            /*override*/
            ctx8[4]
          ) })
        )
      )
    },
    /*$$restProps*/
    ctx8[17]
  ];
  function box_element_binding(value) {
    ctx8[23](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot33] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[1] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[1];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*cx, className, classes, getStyles, override, $$restProps*/
      188440 ? get_spread_update(box_spread_levels, [
        dirty & /*cx, className, classes, getStyles, override*/
        57368 && {
          class: (
            /*cx*/
            ctx9[15](
              /*className*/
              ctx9[3],
              /*classes*/
              ctx9[14].root,
              /*getStyles*/
              ctx9[13]({ css: (
                /*override*/
                ctx9[4]
              ) })
            )
          )
        },
        dirty & /*$$restProps*/
        131072 && get_spread_object(
          /*$$restProps*/
          ctx9[17]
        )
      ]) : {};
      if (dirty & /*$$scope, classes, id, label, size, indeterminate, disabled, required, value, name, checked, use*/
      16801765) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      2) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[1];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment47.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance47($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "color",
    "id",
    "disabled",
    "value",
    "checked",
    "indeterminate",
    "label",
    "radius",
    "size",
    "name",
    "required",
    "transitionDuration"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Checkbox", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, color = "blue", id = randomID(), disabled = false, value = null, checked = false, indeterminate = false, label = null, radius: radius2 = "sm", size: size3 = "md", name = "", required = false, transitionDuration = 100 } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  function input_change_handler() {
    checked = this.checked;
    $$invalidate(0, checked), $$invalidate(8, indeterminate);
  }
  function box_element_binding(value2) {
    element2 = value2;
    $$invalidate(1, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(17, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(1, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(4, override = $$new_props.override);
    if ("color" in $$new_props)
      $$invalidate(18, color = $$new_props.color);
    if ("id" in $$new_props)
      $$invalidate(5, id = $$new_props.id);
    if ("disabled" in $$new_props)
      $$invalidate(6, disabled = $$new_props.disabled);
    if ("value" in $$new_props)
      $$invalidate(7, value = $$new_props.value);
    if ("checked" in $$new_props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("indeterminate" in $$new_props)
      $$invalidate(8, indeterminate = $$new_props.indeterminate);
    if ("label" in $$new_props)
      $$invalidate(9, label = $$new_props.label);
    if ("radius" in $$new_props)
      $$invalidate(19, radius2 = $$new_props.radius);
    if ("size" in $$new_props)
      $$invalidate(10, size3 = $$new_props.size);
    if ("name" in $$new_props)
      $$invalidate(11, name = $$new_props.name);
    if ("required" in $$new_props)
      $$invalidate(12, required = $$new_props.required);
    if ("transitionDuration" in $$new_props)
      $$invalidate(20, transitionDuration = $$new_props.transitionDuration);
    if ("$$scope" in $$new_props)
      $$invalidate(24, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: Checkbox_styles_default,
    randomID,
    get_current_component,
    createEventForwarder,
    useActions,
    Box: Box_default,
    ThemeIcon: ThemeIcon_default,
    CheckboxIcon: CheckboxIcon_default,
    use,
    element: element2,
    className,
    override,
    color,
    id,
    disabled,
    value,
    checked,
    indeterminate,
    label,
    radius: radius2,
    size: size3,
    name,
    required,
    transitionDuration,
    forwardEvents,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(1, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(4, override = $$new_props.override);
    if ("color" in $$props)
      $$invalidate(18, color = $$new_props.color);
    if ("id" in $$props)
      $$invalidate(5, id = $$new_props.id);
    if ("disabled" in $$props)
      $$invalidate(6, disabled = $$new_props.disabled);
    if ("value" in $$props)
      $$invalidate(7, value = $$new_props.value);
    if ("checked" in $$props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("indeterminate" in $$props)
      $$invalidate(8, indeterminate = $$new_props.indeterminate);
    if ("label" in $$props)
      $$invalidate(9, label = $$new_props.label);
    if ("radius" in $$props)
      $$invalidate(19, radius2 = $$new_props.radius);
    if ("size" in $$props)
      $$invalidate(10, size3 = $$new_props.size);
    if ("name" in $$props)
      $$invalidate(11, name = $$new_props.name);
    if ("required" in $$props)
      $$invalidate(12, required = $$new_props.required);
    if ("transitionDuration" in $$props)
      $$invalidate(20, transitionDuration = $$new_props.transitionDuration);
    if ("getStyles" in $$props)
      $$invalidate(13, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(14, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(15, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*indeterminate, checked*/
    257) {
      $:
        $$invalidate(0, checked = indeterminate || checked);
    }
    if ($$self.$$.dirty & /*color, radius, size, transitionDuration*/
    1836032) {
      $:
        $$invalidate(15, { cx: cx2, classes, getStyles } = Checkbox_styles_default({ color, radius: radius2, size: size3, transitionDuration }, { name: "Checkbox" }), cx2, ($$invalidate(14, classes), $$invalidate(18, color), $$invalidate(19, radius2), $$invalidate(10, size3), $$invalidate(20, transitionDuration)), ($$invalidate(13, getStyles), $$invalidate(18, color), $$invalidate(19, radius2), $$invalidate(10, size3), $$invalidate(20, transitionDuration)));
    }
  };
  return [
    checked,
    element2,
    use,
    className,
    override,
    id,
    disabled,
    value,
    indeterminate,
    label,
    size3,
    name,
    required,
    getStyles,
    classes,
    cx2,
    forwardEvents,
    $$restProps,
    color,
    radius2,
    transitionDuration,
    slots,
    input_change_handler,
    box_element_binding,
    $$scope
  ];
}
var Checkbox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance47, create_fragment47, safe_not_equal, {
      use: 2,
      element: 1,
      class: 3,
      override: 4,
      color: 18,
      id: 5,
      disabled: 6,
      value: 7,
      checked: 0,
      indeterminate: 8,
      label: 9,
      radius: 19,
      size: 10,
      name: 11,
      required: 12,
      transitionDuration: 20
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Checkbox",
      options,
      id: create_fragment47.name
    });
  }
  get use() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indeterminate() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indeterminate(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionDuration() {
    throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionDuration(value) {
    throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Checkbox_default = Checkbox;

// node_modules/@svelteuidev/core/dist/components/InputWrapper/InputWrapper.styles.js
var InputWrapper_styles_default = createStyles((theme4, { size: size3 }) => {
  return {
    root: {
      lineHeight: theme4.lineHeights.md.value
    },
    label: {
      [`${theme4.dark} &`]: {
        color: theme4.fn.themeColor("dark", 0)
      },
      display: "inline-block",
      marginBottom: 4,
      fontFamily: theme4.fonts.standard.value ?? "sans-serif",
      fontSize: theme4.fontSizes[size3].value,
      fontWeight: 500,
      color: theme4.fn.themeColor("gray", 9),
      wordBreak: "break-word",
      cursor: "default",
      WebkitTapHighlightColor: "transparent"
    },
    error: {
      [`${theme4.dark} &`]: {
        color: theme4.fn.themeColor("red", 6)
      },
      marginTop: 5,
      wordBreak: "break-word",
      color: theme4.fn.themeColor("red", 7)
    },
    description: {
      [`${theme4.dark} &`]: {
        color: `${theme4.fn.themeColor("dark", 2)} !important`
      },
      marginTop: -3,
      marginBottom: 7,
      wordBreak: "break-word",
      color: `${theme4.fn.themeColor("gray", 6)} !important`,
      fontSize: theme4.fontSizes[size3].value,
      lineHeight: 1.2
    },
    required: {
      [`${theme4.dark} &`]: {
        color: theme4.fn.themeColor("red", 5)
      },
      color: theme4.fn.themeColor("red", 7)
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/InputWrapper/LabelElement.svelte
var file23 = "node_modules/@svelteuidev/core/dist/components/InputWrapper/LabelElement.svelte";
function create_if_block15(ctx8) {
  let span;
  let t_value = " *";
  let t;
  let span_class_value;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true, "aria-hidden": true });
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*classes*/
      ctx8[5].required);
      attr_dev(span, "aria-hidden", "");
      add_location(span, file23, 14, 2, 437);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*classes*/
      32 && span_class_value !== (span_class_value = /*classes*/
      ctx9[5].required)) {
        attr_dev(span, "class", span_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block15.name,
    type: "if",
    source: "(14:1) {#if required}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot34(ctx8) {
  let t0;
  let t1;
  let if_block_anchor;
  let if_block = (
    /*required*/
    ctx8[3] && create_if_block15(ctx8)
  );
  const block = {
    c: function create() {
      t0 = text(
        /*label*/
        ctx8[1]
      );
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      t0 = claim_text(
        nodes,
        /*label*/
        ctx8[1]
      );
      t1 = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*label*/
      2)
        set_data_dev(
          t0,
          /*label*/
          ctx9[1]
        );
      if (
        /*required*/
        ctx9[3]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
        } else {
          if_block = create_if_block15(ctx9);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot34.name,
    type: "slot",
    source: "(12:0) <Box for={id} root={labelElement} class={className}>",
    ctx: ctx8
  });
  return block;
}
function create_fragment48(ctx8) {
  let box;
  let current;
  box = new Box_default({
    props: {
      for: (
        /*id*/
        ctx8[4]
      ),
      root: (
        /*labelElement*/
        ctx8[2]
      ),
      class: (
        /*className*/
        ctx8[0]
      ),
      $$slots: { default: [create_default_slot34] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = {};
      if (dirty & /*id*/
      16)
        box_changes.for = /*id*/
        ctx9[4];
      if (dirty & /*labelElement*/
      4)
        box_changes.root = /*labelElement*/
        ctx9[2];
      if (dirty & /*className*/
      1)
        box_changes.class = /*className*/
        ctx9[0];
      if (dirty & /*$$scope, classes, required, label*/
      106) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment48.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance48($$self, $$props, $$invalidate) {
  let classes;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LabelElement", slots, []);
  let { class: className = "label" } = $$props;
  let { label = "label" } = $$props;
  let { labelElement = "label" } = $$props;
  let { required = false } = $$props;
  let { id = void 0 } = $$props;
  const writable_props = ["class", "label", "labelElement", "required", "id"];
  Object.keys($$props).forEach((key3) => {
    if (!~writable_props.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<LabelElement> was created with unknown prop '${key3}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2)
      $$invalidate(0, className = $$props2.class);
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
    if ("labelElement" in $$props2)
      $$invalidate(2, labelElement = $$props2.labelElement);
    if ("required" in $$props2)
      $$invalidate(3, required = $$props2.required);
    if ("id" in $$props2)
      $$invalidate(4, id = $$props2.id);
  };
  $$self.$capture_state = () => ({
    Box: Box_default,
    useStyles: InputWrapper_styles_default,
    className,
    label,
    labelElement,
    required,
    id,
    classes
  });
  $$self.$inject_state = ($$props2) => {
    if ("className" in $$props2)
      $$invalidate(0, className = $$props2.className);
    if ("label" in $$props2)
      $$invalidate(1, label = $$props2.label);
    if ("labelElement" in $$props2)
      $$invalidate(2, labelElement = $$props2.labelElement);
    if ("required" in $$props2)
      $$invalidate(3, required = $$props2.required);
    if ("id" in $$props2)
      $$invalidate(4, id = $$props2.id);
    if ("classes" in $$props2)
      $$invalidate(5, classes = $$props2.classes);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $:
    $$invalidate(5, { classes } = InputWrapper_styles_default({ size: "md" }, { name: "InputWrapper" }), classes);
  return [className, label, labelElement, required, id, classes];
}
var LabelElement = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance48, create_fragment48, safe_not_equal, {
      class: 0,
      label: 1,
      labelElement: 2,
      required: 3,
      id: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LabelElement",
      options,
      id: create_fragment48.name
    });
  }
  get class() {
    throw new Error("<LabelElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<LabelElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<LabelElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<LabelElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelElement() {
    throw new Error("<LabelElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelElement(value) {
    throw new Error("<LabelElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<LabelElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<LabelElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<LabelElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<LabelElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LabelElement_default = LabelElement;

// node_modules/@svelteuidev/core/dist/components/InputWrapper/InputWrapper.svelte
function create_if_block_26(ctx8) {
  let labelelement;
  let current;
  const labelelement_spread_levels = [
    { class: (
      /*classes*/
      ctx8[15].label
    ) },
    /*labelProps*/
    ctx8[8],
    { label: (
      /*label*/
      ctx8[4]
    ) },
    { id: (
      /*id*/
      ctx8[11]
    ) },
    { labelElement: (
      /*labelElement*/
      ctx8[12]
    ) },
    { required: (
      /*required*/
      ctx8[7]
    ) }
  ];
  let labelelement_props = {};
  for (let i2 = 0; i2 < labelelement_spread_levels.length; i2 += 1) {
    labelelement_props = assign(labelelement_props, labelelement_spread_levels[i2]);
  }
  labelelement = new LabelElement_default({
    props: labelelement_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(labelelement.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(labelelement.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(labelelement, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const labelelement_changes = dirty & /*classes, labelProps, label, id, labelElement, required*/
      39312 ? get_spread_update(labelelement_spread_levels, [
        dirty & /*classes*/
        32768 && { class: (
          /*classes*/
          ctx9[15].label
        ) },
        dirty & /*labelProps*/
        256 && get_spread_object(
          /*labelProps*/
          ctx9[8]
        ),
        dirty & /*label*/
        16 && { label: (
          /*label*/
          ctx9[4]
        ) },
        dirty & /*id*/
        2048 && { id: (
          /*id*/
          ctx9[11]
        ) },
        dirty & /*labelElement*/
        4096 && { labelElement: (
          /*labelElement*/
          ctx9[12]
        ) },
        dirty & /*required*/
        128 && { required: (
          /*required*/
          ctx9[7]
        ) }
      ]) : {};
      labelelement.$set(labelelement_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(labelelement.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(labelelement.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(labelelement, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_26.name,
    type: "if",
    source: "(16:1) {#if label}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_110(ctx8) {
  let text_1;
  let current;
  const text_1_spread_levels = [
    /*descriptionProps*/
    ctx8[9],
    { color: "gray" },
    { class: (
      /*classes*/
      ctx8[15].description
    ) }
  ];
  let text_1_props = {
    $$slots: { default: [create_default_slot_22] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < text_1_spread_levels.length; i2 += 1) {
    text_1_props = assign(text_1_props, text_1_spread_levels[i2]);
  }
  text_1 = new Text_default({ props: text_1_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(text_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(text_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(text_1, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const text_1_changes = dirty & /*descriptionProps, classes*/
      33280 ? get_spread_update(text_1_spread_levels, [
        dirty & /*descriptionProps*/
        512 && get_spread_object(
          /*descriptionProps*/
          ctx9[9]
        ),
        text_1_spread_levels[1],
        dirty & /*classes*/
        32768 && { class: (
          /*classes*/
          ctx9[15].description
        ) }
      ]) : {};
      if (dirty & /*$$scope, description*/
      1048608) {
        text_1_changes.$$scope = { dirty, ctx: ctx9 };
      }
      text_1.$set(text_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(text_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_110.name,
    type: "if",
    source: "(19:1) {#if description}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_22(ctx8) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*description*/
        ctx8[5]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*description*/
        ctx8[5]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*description*/
      32)
        set_data_dev(
          t,
          /*description*/
          ctx9[5]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_22.name,
    type: "slot",
    source: '(20:2) <Text {...descriptionProps} color=\\"gray\\" class={classes.description}>',
    ctx: ctx8
  });
  return block;
}
function create_if_block16(ctx8) {
  let text_1;
  let current;
  const text_1_spread_levels = [
    /*errorProps*/
    ctx8[10],
    { size: (
      /*size*/
      ctx8[13]
    ) },
    { class: (
      /*classes*/
      ctx8[15].error
    ) }
  ];
  let text_1_props = {
    $$slots: { default: [create_default_slot_15] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < text_1_spread_levels.length; i2 += 1) {
    text_1_props = assign(text_1_props, text_1_spread_levels[i2]);
  }
  text_1 = new Text_default({ props: text_1_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(text_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(text_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(text_1, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const text_1_changes = dirty & /*errorProps, size, classes*/
      41984 ? get_spread_update(text_1_spread_levels, [
        dirty & /*errorProps*/
        1024 && get_spread_object(
          /*errorProps*/
          ctx9[10]
        ),
        dirty & /*size*/
        8192 && { size: (
          /*size*/
          ctx9[13]
        ) },
        dirty & /*classes*/
        32768 && { class: (
          /*classes*/
          ctx9[15].error
        ) }
      ]) : {};
      if (dirty & /*$$scope, error*/
      1048640) {
        text_1_changes.$$scope = { dirty, ctx: ctx9 };
      }
      text_1.$set(text_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(text_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block16.name,
    type: "if",
    source: "(25:1) {#if typeof error !== 'boolean' && error}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_15(ctx8) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*error*/
        ctx8[6]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*error*/
        ctx8[6]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*error*/
      64)
        set_data_dev(
          t,
          /*error*/
          ctx9[6]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_15.name,
    type: "slot",
    source: "(26:2) <Text {...errorProps} {size} class={classes.error}>",
    ctx: ctx8
  });
  return block;
}
function create_default_slot35(ctx8) {
  let t0;
  let t1;
  let t2;
  let if_block2_anchor;
  let current;
  let if_block0 = (
    /*label*/
    ctx8[4] && create_if_block_26(ctx8)
  );
  let if_block1 = (
    /*description*/
    ctx8[5] && create_if_block_110(ctx8)
  );
  const default_slot_template = (
    /*#slots*/
    ctx8[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[20],
    null
  );
  let if_block2 = typeof /*error*/
  ctx8[6] !== "boolean" && /*error*/
  ctx8[6] && create_if_block16(ctx8);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t1 = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
      t2 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      if_block2_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert_hydration_dev(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (
        /*label*/
        ctx9[4]
      ) {
        if (if_block0) {
          if_block0.p(ctx9, dirty);
          if (dirty & /*label*/
          16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_26(ctx9);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*description*/
        ctx9[5]
      ) {
        if (if_block1) {
          if_block1.p(ctx9, dirty);
          if (dirty & /*description*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_110(ctx9);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[20],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (typeof /*error*/
      ctx9[6] !== "boolean" && /*error*/
      ctx9[6]) {
        if (if_block2) {
          if_block2.p(ctx9, dirty);
          if (dirty & /*error*/
          64) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block16(ctx9);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(default_slot, local);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(default_slot, local);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
        detach_dev(if_block2_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block2)
        if_block2.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot35.name,
    type: "slot",
    source: "(10:0) <Box  bind:element  {use}  class={cx(className, classes.root, getStyles({ css: override }))}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment49(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { use: (
      /*use*/
      ctx8[1]
    ) },
    {
      class: (
        /*cx*/
        ctx8[16](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[15].root,
          /*getStyles*/
          ctx8[14]({ css: (
            /*override*/
            ctx8[3]
          ) })
        )
      )
    },
    /*$$restProps*/
    ctx8[17]
  ];
  function box_element_binding(value) {
    ctx8[19](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot35] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*use, cx, className, classes, getStyles, override, $$restProps*/
      245774 ? get_spread_update(box_spread_levels, [
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*cx, className, classes, getStyles, override*/
        114700 && {
          class: (
            /*cx*/
            ctx9[16](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[15].root,
              /*getStyles*/
              ctx9[14]({ css: (
                /*override*/
                ctx9[3]
              ) })
            )
          )
        },
        dirty & /*$$restProps*/
        131072 && get_spread_object(
          /*$$restProps*/
          ctx9[17]
        )
      ]) : {};
      if (dirty & /*$$scope, errorProps, size, classes, error, descriptionProps, description, labelProps, label, id, labelElement, required*/
      1097712) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment49.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance49($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "label",
    "description",
    "error",
    "required",
    "labelProps",
    "descriptionProps",
    "errorProps",
    "id",
    "labelElement",
    "size"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InputWrapper", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, label = "label", description = null, error = null, required = false, labelProps = {}, descriptionProps = {}, errorProps = {}, id = "input-id", labelElement = "label", size: size3 = "sm" } = $$props;
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(17, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("label" in $$new_props)
      $$invalidate(4, label = $$new_props.label);
    if ("description" in $$new_props)
      $$invalidate(5, description = $$new_props.description);
    if ("error" in $$new_props)
      $$invalidate(6, error = $$new_props.error);
    if ("required" in $$new_props)
      $$invalidate(7, required = $$new_props.required);
    if ("labelProps" in $$new_props)
      $$invalidate(8, labelProps = $$new_props.labelProps);
    if ("descriptionProps" in $$new_props)
      $$invalidate(9, descriptionProps = $$new_props.descriptionProps);
    if ("errorProps" in $$new_props)
      $$invalidate(10, errorProps = $$new_props.errorProps);
    if ("id" in $$new_props)
      $$invalidate(11, id = $$new_props.id);
    if ("labelElement" in $$new_props)
      $$invalidate(12, labelElement = $$new_props.labelElement);
    if ("size" in $$new_props)
      $$invalidate(13, size3 = $$new_props.size);
    if ("$$scope" in $$new_props)
      $$invalidate(20, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: InputWrapper_styles_default,
    Box: Box_default,
    Text: Text_default,
    LabelElement: LabelElement_default,
    use,
    element: element2,
    className,
    override,
    label,
    description,
    error,
    required,
    labelProps,
    descriptionProps,
    errorProps,
    id,
    labelElement,
    size: size3,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("label" in $$props)
      $$invalidate(4, label = $$new_props.label);
    if ("description" in $$props)
      $$invalidate(5, description = $$new_props.description);
    if ("error" in $$props)
      $$invalidate(6, error = $$new_props.error);
    if ("required" in $$props)
      $$invalidate(7, required = $$new_props.required);
    if ("labelProps" in $$props)
      $$invalidate(8, labelProps = $$new_props.labelProps);
    if ("descriptionProps" in $$props)
      $$invalidate(9, descriptionProps = $$new_props.descriptionProps);
    if ("errorProps" in $$props)
      $$invalidate(10, errorProps = $$new_props.errorProps);
    if ("id" in $$props)
      $$invalidate(11, id = $$new_props.id);
    if ("labelElement" in $$props)
      $$invalidate(12, labelElement = $$new_props.labelElement);
    if ("size" in $$props)
      $$invalidate(13, size3 = $$new_props.size);
    if ("getStyles" in $$props)
      $$invalidate(14, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(15, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(16, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*size*/
    8192) {
      $:
        $$invalidate(16, { cx: cx2, classes, getStyles } = InputWrapper_styles_default({ size: size3 }, { name: "InputWrapper" }), cx2, ($$invalidate(15, classes), $$invalidate(13, size3)), ($$invalidate(14, getStyles), $$invalidate(13, size3)));
    }
  };
  return [
    element2,
    use,
    className,
    override,
    label,
    description,
    error,
    required,
    labelProps,
    descriptionProps,
    errorProps,
    id,
    labelElement,
    size3,
    getStyles,
    classes,
    cx2,
    $$restProps,
    slots,
    box_element_binding,
    $$scope
  ];
}
var InputWrapper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance49, create_fragment49, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      label: 4,
      description: 5,
      error: 6,
      required: 7,
      labelProps: 8,
      descriptionProps: 9,
      errorProps: 10,
      id: 11,
      labelElement: 12,
      size: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputWrapper",
      options,
      id: create_fragment49.name
    });
  }
  get use() {
    throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get description() {
    throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set description(value) {
    throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value) {
    throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelProps() {
    throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelProps(value) {
    throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get descriptionProps() {
    throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set descriptionProps(value) {
    throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get errorProps() {
    throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set errorProps(value) {
    throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelElement() {
    throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelElement(value) {
    throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<InputWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<InputWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputWrapper_default = InputWrapper;

// node_modules/@svelteuidev/core/dist/components/Group/Group.styles.js
var POSITIONS = {
  left: "flex-start",
  center: "center",
  right: "flex-end",
  apart: "space-between"
};
var Group_styles_default = createStyles((theme4, { align, direction, grow, noWrap, position, spacing, children: children2 }) => {
  return {
    root: {
      boxSizing: "border-box",
      display: "flex",
      flexDirection: direction,
      alignItems: align || (direction === "row" ? "center" : grow ? "stretch" : position === "apart" ? "flex-start" : POSITIONS[position]),
      flexWrap: noWrap ? "nowrap" : "wrap",
      justifyContent: direction === "row" ? POSITIONS[position] : void 0,
      gap: theme4.fn.size({ size: spacing, sizes: theme4.space }),
      "& > *": {
        boxSizing: "border-box",
        maxWidth: grow && direction === "row" ? `calc(${100 / children2}% - ${theme4.fn.size({ size: spacing, sizes: theme4.space }) - theme4.fn.size({ size: spacing, sizes: theme4.space }) / children2}px)` : void 0,
        flexGrow: grow ? 1 : 0
      }
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Group/Group.svelte
function create_default_slot36(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[17],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[17],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot36.name,
    type: "slot",
    source: "(39:0) <Box  bind:element  {use}  class={cx(className, classes.root, getStyles({ css: override }))}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment50(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { use: (
      /*use*/
      ctx8[1]
    ) },
    {
      class: (
        /*cx*/
        ctx8[6](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[5].root,
          /*getStyles*/
          ctx8[4]({ css: (
            /*override*/
            ctx8[3]
          ) })
        )
      )
    },
    /*$$restProps*/
    ctx8[7]
  ];
  function box_element_binding(value) {
    ctx8[16](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot36] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*use, cx, className, classes, getStyles, override, $$restProps*/
      254 ? get_spread_update(box_spread_levels, [
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*cx, className, classes, getStyles, override*/
        124 && {
          class: (
            /*cx*/
            ctx9[6](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[5].root,
              /*getStyles*/
              ctx9[4]({ css: (
                /*override*/
                ctx9[3]
              ) })
            )
          )
        },
        dirty & /*$$restProps*/
        128 && get_spread_object(
          /*$$restProps*/
          ctx9[7]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      131072) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment50.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance50($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "position",
    "noWrap",
    "grow",
    "spacing",
    "direction",
    "align"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Group", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, position = "left", noWrap = false, grow = false, spacing = "md", direction = "row", align = "center" } = $$props;
  let children2;
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("position" in $$new_props)
      $$invalidate(8, position = $$new_props.position);
    if ("noWrap" in $$new_props)
      $$invalidate(9, noWrap = $$new_props.noWrap);
    if ("grow" in $$new_props)
      $$invalidate(10, grow = $$new_props.grow);
    if ("spacing" in $$new_props)
      $$invalidate(11, spacing = $$new_props.spacing);
    if ("direction" in $$new_props)
      $$invalidate(12, direction = $$new_props.direction);
    if ("align" in $$new_props)
      $$invalidate(13, align = $$new_props.align);
    if ("$$scope" in $$new_props)
      $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: Group_styles_default,
    onMount,
    Box: Box_default,
    use,
    element: element2,
    className,
    override,
    position,
    noWrap,
    grow,
    spacing,
    direction,
    align,
    children: children2,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("position" in $$props)
      $$invalidate(8, position = $$new_props.position);
    if ("noWrap" in $$props)
      $$invalidate(9, noWrap = $$new_props.noWrap);
    if ("grow" in $$props)
      $$invalidate(10, grow = $$new_props.grow);
    if ("spacing" in $$props)
      $$invalidate(11, spacing = $$new_props.spacing);
    if ("direction" in $$props)
      $$invalidate(12, direction = $$new_props.direction);
    if ("align" in $$props)
      $$invalidate(13, align = $$new_props.align);
    if ("children" in $$props)
      $$invalidate(14, children2 = $$new_props.children);
    if ("getStyles" in $$props)
      $$invalidate(4, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(5, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(6, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*element*/
    1) {
      $:
        onMount(() => {
          $$invalidate(14, children2 = element2.childElementCount);
        });
    }
    if ($$self.$$.dirty & /*align, children, direction, grow, noWrap, position, spacing*/
    32512) {
      $:
        $$invalidate(
          6,
          { cx: cx2, classes, getStyles } = Group_styles_default(
            {
              align,
              children: children2,
              direction,
              grow,
              noWrap,
              position,
              spacing
            },
            { name: "Group" }
          ),
          cx2,
          ($$invalidate(5, classes), $$invalidate(13, align), $$invalidate(14, children2), $$invalidate(12, direction), $$invalidate(10, grow), $$invalidate(9, noWrap), $$invalidate(8, position), $$invalidate(11, spacing), $$invalidate(0, element2)),
          ($$invalidate(4, getStyles), $$invalidate(13, align), $$invalidate(14, children2), $$invalidate(12, direction), $$invalidate(10, grow), $$invalidate(9, noWrap), $$invalidate(8, position), $$invalidate(11, spacing), $$invalidate(0, element2))
        );
    }
  };
  return [
    element2,
    use,
    className,
    override,
    getStyles,
    classes,
    cx2,
    $$restProps,
    position,
    noWrap,
    grow,
    spacing,
    direction,
    align,
    children2,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Group = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance50, create_fragment50, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      position: 8,
      noWrap: 9,
      grow: 10,
      spacing: 11,
      direction: 12,
      align: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Group",
      options,
      id: create_fragment50.name
    });
  }
  get use() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noWrap() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noWrap(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get grow() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set grow(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<Group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<Group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Group_default = Group;

// node_modules/@svelteuidev/core/dist/components/Checkbox/CheckboxGroup/CheckboxGroup.svelte
function get_each_context(ctx8, list, i2) {
  const child_ctx = ctx8.slice();
  child_ctx[18] = list[i2];
  return child_ctx;
}
function create_each_block(ctx8) {
  let checkbox;
  let current;
  function change_handler(...args) {
    return (
      /*change_handler*/
      ctx8[15](
        /*item*/
        ctx8[18],
        ...args
      )
    );
  }
  checkbox = new Checkbox_default({
    props: {
      use: (
        /*use*/
        ctx8[2]
      ),
      label: (
        /*item*/
        ctx8[18].label
      ),
      value: (
        /*item*/
        ctx8[18].value
      ),
      checked: (
        /*value*/
        ctx8[1].includes(
          /*item*/
          ctx8[18].value
        )
      ),
      radius: (
        /*radius*/
        ctx8[9]
      ),
      size: (
        /*size*/
        ctx8[8]
      ),
      color: (
        /*color*/
        ctx8[5]
      )
    },
    $$inline: true
  });
  checkbox.$on("change", change_handler);
  const block = {
    c: function create() {
      create_component(checkbox.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(checkbox.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(checkbox, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx8 = new_ctx;
      const checkbox_changes = {};
      if (dirty & /*use*/
      4)
        checkbox_changes.use = /*use*/
        ctx8[2];
      if (dirty & /*items*/
      64)
        checkbox_changes.label = /*item*/
        ctx8[18].label;
      if (dirty & /*items*/
      64)
        checkbox_changes.value = /*item*/
        ctx8[18].value;
      if (dirty & /*value, items*/
      66)
        checkbox_changes.checked = /*value*/
        ctx8[1].includes(
          /*item*/
          ctx8[18].value
        );
      if (dirty & /*radius*/
      512)
        checkbox_changes.radius = /*radius*/
        ctx8[9];
      if (dirty & /*size*/
      256)
        checkbox_changes.size = /*size*/
        ctx8[8];
      if (dirty & /*color*/
      32)
        checkbox_changes.color = /*color*/
        ctx8[5];
      checkbox.$set(checkbox_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(checkbox.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(checkbox.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(checkbox, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(34:2) {#each items as item}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_16(ctx8) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*items*/
    ctx8[6]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block(get_each_context(ctx8, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  const block = {
    c: function create() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*use, items, value, radius, size, color, onChanged*/
      9062) {
        each_value = ensure_array_like_dev(
          /*items*/
          ctx9[6]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context(ctx9, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_16.name,
    type: "slot",
    source: "(33:1) <Group {direction} {spacing} {align}>",
    ctx: ctx8
  });
  return block;
}
function create_default_slot37(ctx8) {
  let group;
  let current;
  group = new Group_default({
    props: {
      direction: (
        /*direction*/
        ctx8[10]
      ),
      spacing: (
        /*spacing*/
        ctx8[12]
      ),
      align: (
        /*align*/
        ctx8[11]
      ),
      $$slots: { default: [create_default_slot_16] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(group.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(group.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(group, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const group_changes = {};
      if (dirty & /*direction*/
      1024)
        group_changes.direction = /*direction*/
        ctx9[10];
      if (dirty & /*spacing*/
      4096)
        group_changes.spacing = /*spacing*/
        ctx9[12];
      if (dirty & /*align*/
      2048)
        group_changes.align = /*align*/
        ctx9[11];
      if (dirty & /*$$scope, items, use, value, radius, size, color*/
      2098022) {
        group_changes.$$scope = { dirty, ctx: ctx9 };
      }
      group.$set(group_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(group.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(group.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(group, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot37.name,
    type: "slot",
    source: "(32:0) <InputWrapper bind:element class={className} {label} {override} {size} {...$$restProps}>",
    ctx: ctx8
  });
  return block;
}
function create_fragment51(ctx8) {
  let inputwrapper;
  let updating_element;
  let current;
  const inputwrapper_spread_levels = [
    { class: (
      /*className*/
      ctx8[3]
    ) },
    { label: (
      /*label*/
      ctx8[7]
    ) },
    { override: (
      /*override*/
      ctx8[4]
    ) },
    { size: (
      /*size*/
      ctx8[8]
    ) },
    /*$$restProps*/
    ctx8[14]
  ];
  function inputwrapper_element_binding(value) {
    ctx8[16](value);
  }
  let inputwrapper_props = {
    $$slots: { default: [create_default_slot37] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < inputwrapper_spread_levels.length; i2 += 1) {
    inputwrapper_props = assign(inputwrapper_props, inputwrapper_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    inputwrapper_props.element = /*element*/
    ctx8[0];
  }
  inputwrapper = new InputWrapper_default({
    props: inputwrapper_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(inputwrapper, "element", inputwrapper_element_binding));
  const block = {
    c: function create() {
      create_component(inputwrapper.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(inputwrapper.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(inputwrapper, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const inputwrapper_changes = dirty & /*className, label, override, size, $$restProps*/
      16792 ? get_spread_update(inputwrapper_spread_levels, [
        dirty & /*className*/
        8 && { class: (
          /*className*/
          ctx9[3]
        ) },
        dirty & /*label*/
        128 && { label: (
          /*label*/
          ctx9[7]
        ) },
        dirty & /*override*/
        16 && { override: (
          /*override*/
          ctx9[4]
        ) },
        dirty & /*size*/
        256 && { size: (
          /*size*/
          ctx9[8]
        ) },
        dirty & /*$$restProps*/
        16384 && get_spread_object(
          /*$$restProps*/
          ctx9[14]
        )
      ]) : {};
      if (dirty & /*$$scope, direction, spacing, align, items, use, value, radius, size, color*/
      2105190) {
        inputwrapper_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        inputwrapper_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      inputwrapper.$set(inputwrapper_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(inputwrapper.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(inputwrapper.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(inputwrapper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment51.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance51($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "color",
    "items",
    "value",
    "label",
    "size",
    "radius",
    "direction",
    "align",
    "spacing"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CheckboxGroup", slots, []);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, color = "gray", items = [], value = [], label = null, size: size3 = "md", radius: radius2 = "sm", direction = "row", align = "flex-start", spacing = "md" } = $$props;
  const dispatch = createEventDispatcher();
  function onChanged(item, el) {
    if (el.checked)
      $$invalidate(1, value = [...value, item]);
    else
      $$invalidate(1, value = value.filter((val) => val !== item));
    dispatch("change", value);
  }
  const change_handler = (item, e) => onChanged(item.value, e.target);
  function inputwrapper_element_binding(value2) {
    element2 = value2;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(14, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(4, override = $$new_props.override);
    if ("color" in $$new_props)
      $$invalidate(5, color = $$new_props.color);
    if ("items" in $$new_props)
      $$invalidate(6, items = $$new_props.items);
    if ("value" in $$new_props)
      $$invalidate(1, value = $$new_props.value);
    if ("label" in $$new_props)
      $$invalidate(7, label = $$new_props.label);
    if ("size" in $$new_props)
      $$invalidate(8, size3 = $$new_props.size);
    if ("radius" in $$new_props)
      $$invalidate(9, radius2 = $$new_props.radius);
    if ("direction" in $$new_props)
      $$invalidate(10, direction = $$new_props.direction);
    if ("align" in $$new_props)
      $$invalidate(11, align = $$new_props.align);
    if ("spacing" in $$new_props)
      $$invalidate(12, spacing = $$new_props.spacing);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    InputWrapper: InputWrapper_default,
    Group: Group_default,
    Checkbox: Checkbox_default,
    use,
    element: element2,
    className,
    override,
    color,
    items,
    value,
    label,
    size: size3,
    radius: radius2,
    direction,
    align,
    spacing,
    dispatch,
    onChanged
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(4, override = $$new_props.override);
    if ("color" in $$props)
      $$invalidate(5, color = $$new_props.color);
    if ("items" in $$props)
      $$invalidate(6, items = $$new_props.items);
    if ("value" in $$props)
      $$invalidate(1, value = $$new_props.value);
    if ("label" in $$props)
      $$invalidate(7, label = $$new_props.label);
    if ("size" in $$props)
      $$invalidate(8, size3 = $$new_props.size);
    if ("radius" in $$props)
      $$invalidate(9, radius2 = $$new_props.radius);
    if ("direction" in $$props)
      $$invalidate(10, direction = $$new_props.direction);
    if ("align" in $$props)
      $$invalidate(11, align = $$new_props.align);
    if ("spacing" in $$props)
      $$invalidate(12, spacing = $$new_props.spacing);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    value,
    use,
    className,
    override,
    color,
    items,
    label,
    size3,
    radius2,
    direction,
    align,
    spacing,
    onChanged,
    $$restProps,
    change_handler,
    inputwrapper_element_binding
  ];
}
var CheckboxGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance51, create_fragment51, safe_not_equal, {
      use: 2,
      element: 0,
      class: 3,
      override: 4,
      color: 5,
      items: 6,
      value: 1,
      label: 7,
      size: 8,
      radius: 9,
      direction: 10,
      align: 11,
      spacing: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CheckboxGroup",
      options,
      id: create_fragment51.name
    });
  }
  get use() {
    throw new Error("<CheckboxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<CheckboxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<CheckboxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<CheckboxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CheckboxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CheckboxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<CheckboxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<CheckboxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<CheckboxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<CheckboxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get items() {
    throw new Error("<CheckboxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<CheckboxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<CheckboxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<CheckboxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<CheckboxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<CheckboxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<CheckboxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<CheckboxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<CheckboxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<CheckboxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<CheckboxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<CheckboxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<CheckboxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<CheckboxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<CheckboxGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<CheckboxGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CheckboxGroup_default = CheckboxGroup;

// node_modules/@svelteuidev/core/dist/components/Chip/Chip.styles.js
var sizes7 = {
  xs: 24,
  sm: 28,
  md: 32,
  lg: 36,
  xl: 40
};
var iconSizes2 = {
  xs: 10,
  sm: 12,
  md: 14,
  lg: 16,
  xl: 18
};
var padding = {
  xs: 16,
  sm: 20,
  md: 24,
  lg: 28,
  xl: 32
};
var checkedPadding = {
  xs: 7.5,
  sm: 10,
  md: 11.5,
  lg: 13,
  xl: 15
};
var Chip_styles_default = createStyles((theme4, { color, radius: radius2, size: size3, transitionDuration }, getRef) => {
  return {
    root: {},
    label: {
      ref: getRef("label"),
      boxSizing: "border-box",
      color: theme4.colors.black.value,
      [`${theme4.dark} &`]: {
        color: theme4.fn.themeColor("dark", 0)
      },
      display: "inline-block",
      alignItems: "center",
      userSelect: "none",
      border: "1px solid transparent",
      borderRadius: theme4.fn.radius(radius2),
      height: theme4.fn.size({ size: size3, sizes: sizes7 }),
      fontFamily: theme4.fonts.standard.value ?? "sans-serif",
      fontSize: theme4.fn.size({ size: size3, sizes: theme4.fontSizes }),
      lineHeight: `${theme4.fn.size({ size: size3, sizes: sizes7 }) - 2}px`,
      paddingLeft: theme4.fn.size({ size: size3, sizes: padding }),
      paddingRight: theme4.fn.size({ size: size3, sizes: padding }),
      cursor: "pointer",
      whiteSpace: "nowrap",
      transition: `border-color ${transitionDuration}ms ease, background-color ${transitionDuration}ms ease`,
      WebkitTapHighlightColor: "transparent",
      "&.outline": {
        [`${theme4.dark} &`]: {
          border: `1px solid ${theme4.fn.themeColor("dark", 4)}`,
          backgroundColor: theme4.fn.themeColor("dark", 6)
        },
        border: `1px solid ${theme4.fn.themeColor("gray", 4)}`,
        backgroundColor: theme4.colors.white.value
      },
      "&.filled": {
        [`${theme4.dark} &`]: {
          backgroundColor: theme4.fn.themeColor("dark", 4)
        },
        backgroundColor: theme4.fn.themeColor("gray", 1)
      },
      "&:hover": {
        backgroundColor: theme4.fn.themeColor("gray", 2)
      },
      [`${theme4.dark} &:hover`]: {
        backgroundColor: theme4.fn.themeColor("dark", 5)
      },
      "&.disabled": {
        backgroundColor: `${theme4.fn.themeColor("gray", 1)} !important`,
        borderColor: `${theme4.fn.themeColor("gray", 1)} !important`,
        color: theme4.fn.themeColor("gray", 5),
        [`${theme4.dark} &`]: {
          backgroundColor: `${theme4.fn.themeColor("dark", 5)} !important`,
          borderColor: `${theme4.fn.themeColor("dark", 5)} !important`,
          color: theme4.fn.themeColor("dark", 3)
        },
        cursor: "not-allowed",
        [`& .iconWrapper`]: {
          color: theme4.fn.themeColor("gray", 5),
          [`${theme4.dark} &`]: {
            color: theme4.fn.themeColor("dark", 3)
          }
        }
      },
      "&.checked": {
        paddingLeft: theme4.fn.size({ size: size3, sizes: checkedPadding }),
        paddingRight: theme4.fn.size({ size: size3, sizes: checkedPadding }),
        "&.outline": {
          border: `1px solid ${theme4.fn.themeColor(color, 5)}`
        },
        "&.filled": {
          [`${theme4.dark} &`]: {
            backgroundColor: theme4.fn.variant({ color, variant: "light" }).background[0],
            "&:hover": {
              backgroundColor: theme4.fn.variant({ color, variant: "light" }).background[0]
            }
          },
          backgroundColor: theme4.fn.themeColor(color, 1),
          "&:hover": {
            backgroundColor: theme4.fn.themeColor(color, 2)
          }
        }
      }
    },
    iconWrapper: {
      ref: getRef("iconWrapper"),
      width: theme4.fn.size({ size: size3, sizes: iconSizes2 }) + theme4.fn.size({ size: size3, sizes: theme4.space }) / 1.5,
      maxWidth: theme4.fn.size({ size: size3, sizes: iconSizes2 }) + theme4.fn.size({ size: size3, sizes: theme4.space }) / 1.5,
      height: theme4.fn.size({ size: size3, sizes: iconSizes2 }),
      display: "inline-block",
      verticalAlign: "middle",
      overflow: "hidden",
      color: theme4.fn.themeColor(color, 5)
    },
    checkIcon: {
      width: theme4.fn.size({ size: size3, sizes: iconSizes2 }),
      height: theme4.fn.size({ size: size3, sizes: iconSizes2 }) / 1.1,
      display: "block"
    },
    inputContainer: {
      width: 0,
      height: 0,
      padding: 0,
      opacity: 0,
      margin: 0,
      overflow: "hidden",
      "&:focus": {
        outline: "none",
        [`& + .${getRef("label")}`]: {
          outline: "none",
          [`${theme4.dark} &`]: {
            boxShadow: `0 0 0 2px ${theme4.fn.themeColor("dark", 9)}, 0 0 0 4px ${theme4.colors.primary}`
          },
          boxShadow: `0 0 0 2px ${theme4.colors.white.value}, 0 0 0 4px ${theme4.colors.primary}`
        },
        "&:focus:not(:focus-visible)": {
          [`& + .${getRef("label")}`]: {
            boxShadow: "none"
          }
        }
      }
    },
    input: {
      visibility: "hidden"
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Chip/Chip.svelte
var file24 = "node_modules/@svelteuidev/core/dist/components/Chip/Chip.svelte";
function create_if_block17(ctx8) {
  let div;
  let svg;
  let path;
  let svg_class_value;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      svg = claim_svg_element(div_nodes, "svg", {
        class: true,
        viewBox: true,
        fill: true,
        xmlns: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", {
        d: true,
        fill: true,
        "fill-rule": true,
        "clip-rule": true
      });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 4.586L1.707 2.293A1 1 0 1 0 .293 3.707l3 3a.997.997 0 0 0 1.414 0l5-5A1 1 0 1 0 8.293.293L4 4.586z");
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "clip-rule", "evenodd");
      add_location(path, file24, 55, 5, 1640);
      attr_dev(svg, "class", svg_class_value = /*classes*/
      ctx8[11].checkIcon);
      attr_dev(svg, "viewBox", "0 0 10 7");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      add_location(svg, file24, 49, 4, 1512);
      attr_dev(div, "class", div_class_value = /*classes*/
      ctx8[11].iconWrapper);
      add_location(div, file24, 48, 3, 1474);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, svg);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*classes*/
      2048 && svg_class_value !== (svg_class_value = /*classes*/
      ctx9[11].checkIcon)) {
        attr_dev(svg, "class", svg_class_value);
      }
      if (dirty & /*classes*/
      2048 && div_class_value !== (div_class_value = /*classes*/
      ctx9[11].iconWrapper)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block17.name,
    type: "if",
    source: "(48:2) {#if checked}",
    ctx: ctx8
  });
  return block;
}
function fallback_block8(ctx8) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*label*/
        ctx8[8]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*label*/
        ctx8[8]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*label*/
      256)
        set_data_dev(
          t,
          /*label*/
          ctx9[8]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block8.name,
    type: "fallback",
    source: "(65:8) {label}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot38(ctx8) {
  let div;
  let input;
  let input_class_value;
  let useActions_action;
  let forwardEvents_action;
  let div_class_value;
  let t0;
  let label_1;
  let t1;
  let label_1_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*checked*/
    ctx8[1] && create_if_block17(ctx8)
  );
  const default_slot_template = (
    /*#slots*/
    ctx8[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[22],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block8(ctx8);
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      t0 = space();
      label_1 = element("label");
      if (if_block)
        if_block.c();
      t1 = space();
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      input = claim_element(div_nodes, "INPUT", { class: true, type: true, id: true });
      div_nodes.forEach(detach_dev);
      t0 = claim_space(nodes);
      label_1 = claim_element(nodes, "LABEL", { class: true, for: true });
      var label_1_nodes = children(label_1);
      if (if_block)
        if_block.l(label_1_nodes);
      t1 = claim_space(label_1_nodes);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(label_1_nodes);
      label_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "class", input_class_value = /*classes*/
      ctx8[11].input);
      attr_dev(input, "type", "checkbox");
      input.disabled = /*disabled*/
      ctx8[6];
      input.__value = /*value*/
      ctx8[7];
      set_input_value(input, input.__value);
      attr_dev(
        input,
        "id",
        /*id*/
        ctx8[5]
      );
      toggle_class(
        input,
        "disabled",
        /*disabled*/
        ctx8[6]
      );
      add_location(input, file24, 33, 2, 1196);
      attr_dev(div, "class", div_class_value = /*classes*/
      ctx8[11].inputContainer);
      add_location(div, file24, 32, 1, 1157);
      attr_dev(label_1, "class", label_1_class_value = /*cx*/
      ctx8[12](
        /*classes*/
        ctx8[11].label,
        /*variant*/
        ctx8[9]
      ));
      attr_dev(
        label_1,
        "for",
        /*id*/
        ctx8[5]
      );
      toggle_class(
        label_1,
        "checked",
        /*checked*/
        ctx8[1]
      );
      toggle_class(
        label_1,
        "disabled",
        /*disabled*/
        ctx8[6]
      );
      add_location(label_1, file24, 46, 1, 1374);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, input);
      input.checked = /*checked*/
      ctx8[1];
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, label_1, anchor);
      if (if_block)
        if_block.m(label_1, null);
      append_hydration_dev(label_1, t1);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(label_1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            input,
            /*use*/
            ctx8[2]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx8[13].call(null, input)),
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx8[20]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx9, dirty) {
      if (!current || dirty & /*classes*/
      2048 && input_class_value !== (input_class_value = /*classes*/
      ctx9[11].input)) {
        attr_dev(input, "class", input_class_value);
      }
      if (!current || dirty & /*disabled*/
      64) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx9[6]
        );
      }
      if (!current || dirty & /*value*/
      128) {
        prop_dev(
          input,
          "__value",
          /*value*/
          ctx9[7]
        );
        set_input_value(input, input.__value);
      }
      if (!current || dirty & /*id*/
      32) {
        attr_dev(
          input,
          "id",
          /*id*/
          ctx9[5]
        );
      }
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      4)
        useActions_action.update.call(
          null,
          /*use*/
          ctx9[2]
        );
      if (dirty & /*checked*/
      2) {
        input.checked = /*checked*/
        ctx9[1];
      }
      if (!current || dirty & /*classes, disabled*/
      2112) {
        toggle_class(
          input,
          "disabled",
          /*disabled*/
          ctx9[6]
        );
      }
      if (!current || dirty & /*classes*/
      2048 && div_class_value !== (div_class_value = /*classes*/
      ctx9[11].inputContainer)) {
        attr_dev(div, "class", div_class_value);
      }
      if (
        /*checked*/
        ctx9[1]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
        } else {
          if_block = create_if_block17(ctx9);
          if_block.c();
          if_block.m(label_1, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[22]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[22],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*label*/
        256)) {
          default_slot_or_fallback.p(ctx9, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*cx, classes, variant*/
      6656 && label_1_class_value !== (label_1_class_value = /*cx*/
      ctx9[12](
        /*classes*/
        ctx9[11].label,
        /*variant*/
        ctx9[9]
      ))) {
        attr_dev(label_1, "class", label_1_class_value);
      }
      if (!current || dirty & /*id*/
      32) {
        attr_dev(
          label_1,
          "for",
          /*id*/
          ctx9[5]
        );
      }
      if (!current || dirty & /*cx, classes, variant, checked*/
      6658) {
        toggle_class(
          label_1,
          "checked",
          /*checked*/
          ctx9[1]
        );
      }
      if (!current || dirty & /*cx, classes, variant, disabled*/
      6720) {
        toggle_class(
          label_1,
          "disabled",
          /*disabled*/
          ctx9[6]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
        detach_dev(t0);
        detach_dev(label_1);
      }
      if (if_block)
        if_block.d();
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot38.name,
    type: "slot",
    source: "(28:0) <Box  bind:element  class={cx(className, classes.root, getStyles({ css: override }))}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment52(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    {
      class: (
        /*cx*/
        ctx8[12](
          /*className*/
          ctx8[3],
          /*classes*/
          ctx8[11].root,
          /*getStyles*/
          ctx8[10]({ css: (
            /*override*/
            ctx8[4]
          ) })
        )
      )
    },
    /*$$restProps*/
    ctx8[14]
  ];
  function box_element_binding(value) {
    ctx8[21](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot38] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*cx, className, classes, getStyles, override, $$restProps*/
      23576 ? get_spread_update(box_spread_levels, [
        dirty & /*cx, className, classes, getStyles, override*/
        7192 && {
          class: (
            /*cx*/
            ctx9[12](
              /*className*/
              ctx9[3],
              /*classes*/
              ctx9[11].root,
              /*getStyles*/
              ctx9[10]({ css: (
                /*override*/
                ctx9[4]
              ) })
            )
          )
        },
        dirty & /*$$restProps*/
        16384 && get_spread_object(
          /*$$restProps*/
          ctx9[14]
        )
      ]) : {};
      if (dirty & /*$$scope, cx, classes, variant, id, checked, disabled, label, value, use*/
      4201446) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment52.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance52($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "color",
    "id",
    "disabled",
    "value",
    "checked",
    "label",
    "radius",
    "size",
    "variant",
    "transitionDuration"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Chip", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, color = "blue", id = randomID(), disabled = false, value = void 0, checked = false, label = "", radius: radius2 = "xl", size: size3 = "sm", variant: variant2 = "outline", transitionDuration = 100 } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  function input_change_handler() {
    checked = this.checked;
    $$invalidate(1, checked);
  }
  function box_element_binding(value2) {
    element2 = value2;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(14, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(4, override = $$new_props.override);
    if ("color" in $$new_props)
      $$invalidate(15, color = $$new_props.color);
    if ("id" in $$new_props)
      $$invalidate(5, id = $$new_props.id);
    if ("disabled" in $$new_props)
      $$invalidate(6, disabled = $$new_props.disabled);
    if ("value" in $$new_props)
      $$invalidate(7, value = $$new_props.value);
    if ("checked" in $$new_props)
      $$invalidate(1, checked = $$new_props.checked);
    if ("label" in $$new_props)
      $$invalidate(8, label = $$new_props.label);
    if ("radius" in $$new_props)
      $$invalidate(16, radius2 = $$new_props.radius);
    if ("size" in $$new_props)
      $$invalidate(17, size3 = $$new_props.size);
    if ("variant" in $$new_props)
      $$invalidate(9, variant2 = $$new_props.variant);
    if ("transitionDuration" in $$new_props)
      $$invalidate(18, transitionDuration = $$new_props.transitionDuration);
    if ("$$scope" in $$new_props)
      $$invalidate(22, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: Chip_styles_default,
    randomID,
    get_current_component,
    createEventForwarder,
    useActions,
    Box: Box_default,
    use,
    element: element2,
    className,
    override,
    color,
    id,
    disabled,
    value,
    checked,
    label,
    radius: radius2,
    size: size3,
    variant: variant2,
    transitionDuration,
    forwardEvents,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(4, override = $$new_props.override);
    if ("color" in $$props)
      $$invalidate(15, color = $$new_props.color);
    if ("id" in $$props)
      $$invalidate(5, id = $$new_props.id);
    if ("disabled" in $$props)
      $$invalidate(6, disabled = $$new_props.disabled);
    if ("value" in $$props)
      $$invalidate(7, value = $$new_props.value);
    if ("checked" in $$props)
      $$invalidate(1, checked = $$new_props.checked);
    if ("label" in $$props)
      $$invalidate(8, label = $$new_props.label);
    if ("radius" in $$props)
      $$invalidate(16, radius2 = $$new_props.radius);
    if ("size" in $$props)
      $$invalidate(17, size3 = $$new_props.size);
    if ("variant" in $$props)
      $$invalidate(9, variant2 = $$new_props.variant);
    if ("transitionDuration" in $$props)
      $$invalidate(18, transitionDuration = $$new_props.transitionDuration);
    if ("getStyles" in $$props)
      $$invalidate(10, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(11, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(12, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*color, radius, size, transitionDuration*/
    491520) {
      $:
        $$invalidate(12, { cx: cx2, classes, getStyles } = Chip_styles_default({ color, radius: radius2, size: size3, transitionDuration }, { name: "Chip" }), cx2, ($$invalidate(11, classes), $$invalidate(15, color), $$invalidate(16, radius2), $$invalidate(17, size3), $$invalidate(18, transitionDuration)), ($$invalidate(10, getStyles), $$invalidate(15, color), $$invalidate(16, radius2), $$invalidate(17, size3), $$invalidate(18, transitionDuration)));
    }
  };
  return [
    element2,
    checked,
    use,
    className,
    override,
    id,
    disabled,
    value,
    label,
    variant2,
    getStyles,
    classes,
    cx2,
    forwardEvents,
    $$restProps,
    color,
    radius2,
    size3,
    transitionDuration,
    slots,
    input_change_handler,
    box_element_binding,
    $$scope
  ];
}
var Chip = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance52, create_fragment52, safe_not_equal, {
      use: 2,
      element: 0,
      class: 3,
      override: 4,
      color: 15,
      id: 5,
      disabled: 6,
      value: 7,
      checked: 1,
      label: 8,
      radius: 16,
      size: 17,
      variant: 9,
      transitionDuration: 18
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Chip",
      options,
      id: create_fragment52.name
    });
  }
  get use() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionDuration() {
    throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionDuration(value) {
    throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Chip_default = Chip;

// node_modules/@svelteuidev/core/dist/components/Chip/ChipGroup/ChipGroup.svelte
function get_each_context2(ctx8, list, i2) {
  const child_ctx = ctx8.slice();
  child_ctx[22] = list[i2];
  return child_ctx;
}
function create_each_block2(ctx8) {
  let chip;
  let current;
  function change_handler(...args) {
    return (
      /*change_handler*/
      ctx8[19](
        /*item*/
        ctx8[22],
        ...args
      )
    );
  }
  chip = new Chip_default({
    props: {
      use: (
        /*use*/
        ctx8[2]
      ),
      label: (
        /*item*/
        ctx8[22].label
      ),
      value: (
        /*item*/
        ctx8[22].value
      ),
      checked: Array.isArray(
        /*value*/
        ctx8[1]
      ) ? (
        /*value*/
        ctx8[1].includes(
          /*item*/
          ctx8[22].value
        )
      ) : (
        /*value*/
        ctx8[1] === /*item*/
        ctx8[22].value
      ),
      radius: (
        /*radius*/
        ctx8[11]
      ),
      size: (
        /*size*/
        ctx8[10]
      ),
      color: (
        /*color*/
        ctx8[5]
      ),
      variant: (
        /*variant*/
        ctx8[9]
      ),
      disabled: (
        /*disabled*/
        ctx8[8]
      )
    },
    $$inline: true
  });
  chip.$on("change", change_handler);
  const block = {
    c: function create() {
      create_component(chip.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(chip.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(chip, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx8 = new_ctx;
      const chip_changes = {};
      if (dirty & /*use*/
      4)
        chip_changes.use = /*use*/
        ctx8[2];
      if (dirty & /*items*/
      64)
        chip_changes.label = /*item*/
        ctx8[22].label;
      if (dirty & /*items*/
      64)
        chip_changes.value = /*item*/
        ctx8[22].value;
      if (dirty & /*value, items*/
      66)
        chip_changes.checked = Array.isArray(
          /*value*/
          ctx8[1]
        ) ? (
          /*value*/
          ctx8[1].includes(
            /*item*/
            ctx8[22].value
          )
        ) : (
          /*value*/
          ctx8[1] === /*item*/
          ctx8[22].value
        );
      if (dirty & /*radius*/
      2048)
        chip_changes.radius = /*radius*/
        ctx8[11];
      if (dirty & /*size*/
      1024)
        chip_changes.size = /*size*/
        ctx8[10];
      if (dirty & /*color*/
      32)
        chip_changes.color = /*color*/
        ctx8[5];
      if (dirty & /*variant*/
      512)
        chip_changes.variant = /*variant*/
        ctx8[9];
      if (dirty & /*disabled*/
      256)
        chip_changes.disabled = /*disabled*/
        ctx8[8];
      chip.$set(chip_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chip.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chip.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(chip, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(37:2) {#each items as item}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_17(ctx8) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*items*/
    ctx8[6]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block2(get_each_context2(ctx8, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  const block = {
    c: function create() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*use, items, Array, value, radius, size, color, variant, disabled, onChanged*/
      69478) {
        each_value = ensure_array_like_dev(
          /*items*/
          ctx9[6]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context2(ctx9, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block2(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_17.name,
    type: "slot",
    source: "(36:1) <Group {direction} {spacing} {align} {position}>",
    ctx: ctx8
  });
  return block;
}
function create_default_slot39(ctx8) {
  let group;
  let current;
  group = new Group_default({
    props: {
      direction: (
        /*direction*/
        ctx8[12]
      ),
      spacing: (
        /*spacing*/
        ctx8[15]
      ),
      align: (
        /*align*/
        ctx8[13]
      ),
      position: (
        /*position*/
        ctx8[14]
      ),
      $$slots: { default: [create_default_slot_17] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(group.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(group.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(group, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const group_changes = {};
      if (dirty & /*direction*/
      4096)
        group_changes.direction = /*direction*/
        ctx9[12];
      if (dirty & /*spacing*/
      32768)
        group_changes.spacing = /*spacing*/
        ctx9[15];
      if (dirty & /*align*/
      8192)
        group_changes.align = /*align*/
        ctx9[13];
      if (dirty & /*position*/
      16384)
        group_changes.position = /*position*/
        ctx9[14];
      if (dirty & /*$$scope, items, use, value, radius, size, color, variant, disabled*/
      33558374) {
        group_changes.$$scope = { dirty, ctx: ctx9 };
      }
      group.$set(group_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(group.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(group.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(group, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot39.name,
    type: "slot",
    source: "(35:0) <InputWrapper bind:element class={className} {label} {override} {size} {...$$restProps}>",
    ctx: ctx8
  });
  return block;
}
function create_fragment53(ctx8) {
  let inputwrapper;
  let updating_element;
  let current;
  const inputwrapper_spread_levels = [
    { class: (
      /*className*/
      ctx8[3]
    ) },
    { label: (
      /*label*/
      ctx8[7]
    ) },
    { override: (
      /*override*/
      ctx8[4]
    ) },
    { size: (
      /*size*/
      ctx8[10]
    ) },
    /*$$restProps*/
    ctx8[17]
  ];
  function inputwrapper_element_binding(value) {
    ctx8[20](value);
  }
  let inputwrapper_props = {
    $$slots: { default: [create_default_slot39] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < inputwrapper_spread_levels.length; i2 += 1) {
    inputwrapper_props = assign(inputwrapper_props, inputwrapper_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    inputwrapper_props.element = /*element*/
    ctx8[0];
  }
  inputwrapper = new InputWrapper_default({
    props: inputwrapper_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(inputwrapper, "element", inputwrapper_element_binding));
  const block = {
    c: function create() {
      create_component(inputwrapper.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(inputwrapper.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(inputwrapper, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const inputwrapper_changes = dirty & /*className, label, override, size, $$restProps*/
      132248 ? get_spread_update(inputwrapper_spread_levels, [
        dirty & /*className*/
        8 && { class: (
          /*className*/
          ctx9[3]
        ) },
        dirty & /*label*/
        128 && { label: (
          /*label*/
          ctx9[7]
        ) },
        dirty & /*override*/
        16 && { override: (
          /*override*/
          ctx9[4]
        ) },
        dirty & /*size*/
        1024 && { size: (
          /*size*/
          ctx9[10]
        ) },
        dirty & /*$$restProps*/
        131072 && get_spread_object(
          /*$$restProps*/
          ctx9[17]
        )
      ]) : {};
      if (dirty & /*$$scope, direction, spacing, align, position, items, use, value, radius, size, color, variant, disabled*/
      33619814) {
        inputwrapper_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        inputwrapper_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      inputwrapper.$set(inputwrapper_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(inputwrapper.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(inputwrapper.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(inputwrapper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment53.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance53($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "color",
    "multiple",
    "items",
    "value",
    "label",
    "disabled",
    "variant",
    "size",
    "radius",
    "direction",
    "align",
    "position",
    "spacing"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ChipGroup", slots, []);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, color = void 0, multiple = false, items = [], value = multiple ? [] : void 0, label = null, disabled = false, variant: variant2 = "outline", size: size3 = void 0, radius: radius2 = void 0, direction = "row", align = "flex-start", position = "left", spacing = "md" } = $$props;
  const dispatch = createEventDispatcher();
  function onChanged(item, el) {
    const checked = el.checked;
    if (Array.isArray(value)) {
      $$invalidate(1, value = checked ? [...value, item] : value.filter((val) => val !== item));
    } else {
      $$invalidate(1, value = checked ? item : void 0);
    }
    dispatch("change", value);
  }
  const change_handler = (item, e) => onChanged(item.value, e.target);
  function inputwrapper_element_binding(value2) {
    element2 = value2;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(17, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(4, override = $$new_props.override);
    if ("color" in $$new_props)
      $$invalidate(5, color = $$new_props.color);
    if ("multiple" in $$new_props)
      $$invalidate(18, multiple = $$new_props.multiple);
    if ("items" in $$new_props)
      $$invalidate(6, items = $$new_props.items);
    if ("value" in $$new_props)
      $$invalidate(1, value = $$new_props.value);
    if ("label" in $$new_props)
      $$invalidate(7, label = $$new_props.label);
    if ("disabled" in $$new_props)
      $$invalidate(8, disabled = $$new_props.disabled);
    if ("variant" in $$new_props)
      $$invalidate(9, variant2 = $$new_props.variant);
    if ("size" in $$new_props)
      $$invalidate(10, size3 = $$new_props.size);
    if ("radius" in $$new_props)
      $$invalidate(11, radius2 = $$new_props.radius);
    if ("direction" in $$new_props)
      $$invalidate(12, direction = $$new_props.direction);
    if ("align" in $$new_props)
      $$invalidate(13, align = $$new_props.align);
    if ("position" in $$new_props)
      $$invalidate(14, position = $$new_props.position);
    if ("spacing" in $$new_props)
      $$invalidate(15, spacing = $$new_props.spacing);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    InputWrapper: InputWrapper_default,
    Group: Group_default,
    Chip: Chip_default,
    use,
    element: element2,
    className,
    override,
    color,
    multiple,
    items,
    value,
    label,
    disabled,
    variant: variant2,
    size: size3,
    radius: radius2,
    direction,
    align,
    position,
    spacing,
    dispatch,
    onChanged
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(4, override = $$new_props.override);
    if ("color" in $$props)
      $$invalidate(5, color = $$new_props.color);
    if ("multiple" in $$props)
      $$invalidate(18, multiple = $$new_props.multiple);
    if ("items" in $$props)
      $$invalidate(6, items = $$new_props.items);
    if ("value" in $$props)
      $$invalidate(1, value = $$new_props.value);
    if ("label" in $$props)
      $$invalidate(7, label = $$new_props.label);
    if ("disabled" in $$props)
      $$invalidate(8, disabled = $$new_props.disabled);
    if ("variant" in $$props)
      $$invalidate(9, variant2 = $$new_props.variant);
    if ("size" in $$props)
      $$invalidate(10, size3 = $$new_props.size);
    if ("radius" in $$props)
      $$invalidate(11, radius2 = $$new_props.radius);
    if ("direction" in $$props)
      $$invalidate(12, direction = $$new_props.direction);
    if ("align" in $$props)
      $$invalidate(13, align = $$new_props.align);
    if ("position" in $$props)
      $$invalidate(14, position = $$new_props.position);
    if ("spacing" in $$props)
      $$invalidate(15, spacing = $$new_props.spacing);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    value,
    use,
    className,
    override,
    color,
    items,
    label,
    disabled,
    variant2,
    size3,
    radius2,
    direction,
    align,
    position,
    spacing,
    onChanged,
    $$restProps,
    multiple,
    change_handler,
    inputwrapper_element_binding
  ];
}
var ChipGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance53, create_fragment53, safe_not_equal, {
      use: 2,
      element: 0,
      class: 3,
      override: 4,
      color: 5,
      multiple: 18,
      items: 6,
      value: 1,
      label: 7,
      disabled: 8,
      variant: 9,
      size: 10,
      radius: 11,
      direction: 12,
      align: 13,
      position: 14,
      spacing: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChipGroup",
      options,
      id: create_fragment53.name
    });
  }
  get use() {
    throw new Error("<ChipGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<ChipGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<ChipGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<ChipGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ChipGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ChipGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<ChipGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<ChipGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<ChipGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<ChipGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiple() {
    throw new Error("<ChipGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<ChipGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get items() {
    throw new Error("<ChipGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<ChipGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<ChipGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ChipGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<ChipGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<ChipGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<ChipGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<ChipGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<ChipGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<ChipGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<ChipGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ChipGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<ChipGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<ChipGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<ChipGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<ChipGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<ChipGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<ChipGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<ChipGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<ChipGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<ChipGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<ChipGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ChipGroup_default = ChipGroup;

// node_modules/@svelteuidev/core/dist/components/Code/Code.styles.js
var { rgba: rgba3 } = fns;
var Code_styles_default = createStyles((theme4, { color, block, noMono, width }) => {
  const { themeColor: themeColor2 } = theme4.fn;
  return {
    root: {
      darkMode: {
        backgroundColor: color === "dark" ? themeColor2(color, 4) : rgba3(themeColor2(color, 8), 0.35),
        color: color === "dark" ? themeColor2("dark", 0) : "white"
      },
      position: "relative",
      lineHeight: noMono ? 0 : theme4.lineHeights.md.value,
      padding: `2px 10px`,
      borderRadius: theme4.radii.sm.value,
      color: themeColor2("dark", 7),
      backgroundColor: themeColor2(color, 0),
      fontFamily: noMono ? "$standard" : "$mono",
      fontSize: "$sm",
      width: block ? `${width}%` : "auto"
    },
    copy: {
      darkMode: {
        backgroundColor: "rgba(52, 58, 64, 0.35);",
        color: "white"
      },
      position: "sticky",
      bottom: "60%",
      left: "99%",
      zIndex: "2",
      backgroundColor: "white"
    },
    block: {
      margin: 0,
      padding: theme4.space.xsPX.value,
      overflowX: "auto"
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Code/CopyIcon.svelte
var file25 = "node_modules/@svelteuidev/core/dist/components/Code/CopyIcon.svelte";
function create_else_block8(ctx8) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true,
        fill: true,
        "fill-rule": true,
        "clip-rule": true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5 2V1H10V2H5ZM4.75 0C4.33579 0 4 0.335786 4 0.75V1H3.5C2.67157 1 2 1.67157 2 2.5V12.5C2 13.3284 2.67157 14 3.5 14H11.5C12.3284 14 13 13.3284 13 12.5V2.5C13 1.67157 12.3284 1 11.5 1H11V0.75C11 0.335786 10.6642 0 10.25 0H4.75ZM11 2V2.25C11 2.66421 10.6642 3 10.25 3H4.75C4.33579 3 4 2.66421 4 2.25V2H3.5C3.22386 2 3 2.22386 3 2.5V12.5C3 12.7761 3.22386 13 3.5 13H11.5C11.7761 13 12 12.7761 12 12.5V2.5C12 2.22386 11.7761 2 11.5 2H11Z");
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "clip-rule", "evenodd");
      add_location(path, file25, 12, 2, 622);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block8.name,
    type: "else",
    source: "(12:1) {:else}",
    ctx: ctx8
  });
  return block;
}
function create_if_block18(ctx8) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true,
        fill: true,
        "fill-rule": true,
        "clip-rule": true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M11.4669 3.72684C11.7558 3.91574 11.8369 4.30308 11.648 4.59198L7.39799 11.092C7.29783 11.2452 7.13556 11.3467 6.95402 11.3699C6.77247 11.3931 6.58989 11.3355 6.45446 11.2124L3.70446 8.71241C3.44905 8.48022 3.43023 8.08494 3.66242 7.82953C3.89461 7.57412 4.28989 7.55529 4.5453 7.78749L6.75292 9.79441L10.6018 3.90792C10.7907 3.61902 11.178 3.53795 11.4669 3.72684Z");
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "clip-rule", "evenodd");
      add_location(path, file25, 5, 2, 158);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(path);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block18.name,
    type: "if",
    source: "(5:1) {#if copied}",
    ctx: ctx8
  });
  return block;
}
function create_fragment54(ctx8) {
  let svg;
  function select_block_type(ctx9, dirty) {
    if (
      /*copied*/
      ctx9[0]
    )
      return create_if_block18;
    return create_else_block8;
  }
  let current_block_type = select_block_type(ctx8, -1);
  let if_block = current_block_type(ctx8);
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        fill: true,
        xmlns: true
      });
      var svg_nodes = children(svg);
      if_block.l(svg_nodes);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(svg, "width", "20");
      attr_dev(svg, "height", "20");
      attr_dev(svg, "viewBox", "0 0 15 15");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      add_location(svg, file25, 3, 0, 46);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if_block.m(svg, null);
    },
    p: function update(ctx9, [dirty]) {
      if (current_block_type !== (current_block_type = select_block_type(ctx9, dirty))) {
        if_block.d(1);
        if_block = current_block_type(ctx9);
        if (if_block) {
          if_block.c();
          if_block.m(svg, null);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
      if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment54.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance54($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CopyIcon", slots, []);
  let { copied = false } = $$props;
  const writable_props = ["copied"];
  Object.keys($$props).forEach((key3) => {
    if (!~writable_props.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<CopyIcon> was created with unknown prop '${key3}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("copied" in $$props2)
      $$invalidate(0, copied = $$props2.copied);
  };
  $$self.$capture_state = () => ({ copied });
  $$self.$inject_state = ($$props2) => {
    if ("copied" in $$props2)
      $$invalidate(0, copied = $$props2.copied);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [copied];
}
var CopyIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance54, create_fragment54, safe_not_equal, { copied: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CopyIcon",
      options,
      id: create_fragment54.name
    });
  }
  get copied() {
    throw new Error("<CopyIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set copied(value) {
    throw new Error("<CopyIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CopyIcon_default = CopyIcon;

// node_modules/@svelteuidev/core/dist/components/Code/Code.errors.js
var Code_errors_exports = {};
__export(Code_errors_exports, {
  CodeErrors: () => CodeErrors
});
var CodeErrors = Object.freeze([
  {
    error: true,
    message: "Width can only be modified when block prop is true",
    solution: `
        If your component looks like this:

        &lt;Code width={50} ...&gt; Code Text &lt;/Code&gt;
               ^^^^^^^^^^ - Try adding the block prop 
        `
  },
  {
    error: true,
    message: "If using the copy prop, a message must be associated with it",
    solution: `
        <strong>If your component looks like this:</strong>
    
        &lt;Code copy block ...&gt; Code Text &lt;/Code&gt;
               ^^^^^^^^^^ - Try adding the message prop
        `
  },
  {
    error: true,
    message: "If using the copy prop, the block prop must be set as well",
    solution: `
        <strong>If your component looks like this:</strong>

        &lt;Code copy ...&gt; Code Text &lt;/Code&gt;
               ^^^^ - Try adding the block prop
        `
  }
]);

// node_modules/@svelteuidev/core/dist/components/Code/Code.svelte
var { Error: Error_15 } = globals;
var file26 = "node_modules/@svelteuidev/core/dist/components/Code/Code.svelte";
function add_css3(target) {
  append_styles(target, "svelte-xdvchn", "button.svelte-xdvchn{border:0;padding:0;background:none;cursor:pointer}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29kZS5zdmVsdGUiLCJtYXBwaW5ncyI6IiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiL1VzZXJzL21hbnZpc2luZ2hhbC9Eb2N1bWVudHMvR2l0SHViL2JhY2twYWNray1zdmVsdGUvbm9kZV9tb2R1bGVzL0BzdmVsdGV1aWRldi9jb3JlL2Rpc3QvY29tcG9uZW50cy9Db2RlL0NvZGUuc3ZlbHRlIl19 */");
}
function create_else_block_1(ctx8) {
  let code;
  let code_class_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx8[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[19],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block_22(ctx8);
  let code_levels = [
    {
      class: code_class_value = /*cx*/
      ctx8[13](
        /*className*/
        ctx8[3],
        /*classes*/
        ctx8[12].root,
        /*getStyles*/
        ctx8[11]({ css: (
          /*override*/
          ctx8[1]
        ) })
      )
    },
    /*$$restProps*/
    ctx8[16]
  ];
  let code_data = {};
  for (let i2 = 0; i2 < code_levels.length; i2 += 1) {
    code_data = assign(code_data, code_levels[i2]);
  }
  const block_1 = {
    c: function create() {
      code = element("code");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      code = claim_element(nodes, "CODE", { class: true });
      var code_nodes = children(code);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(code_nodes);
      code_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(code, code_data);
      add_location(code, file26, 71, 1, 2205);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, code, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(code, null);
      }
      ctx8[22](code);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            code,
            /*use*/
            ctx8[2]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx8[14].call(null, code))
        ];
        mounted = true;
      }
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[19],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(code, code_data = get_spread_update(code_levels, [
        (!current || dirty & /*cx, className, classes, getStyles, override*/
        14346 && code_class_value !== (code_class_value = /*cx*/
        ctx9[13](
          /*className*/
          ctx9[3],
          /*classes*/
          ctx9[12].root,
          /*getStyles*/
          ctx9[11]({ css: (
            /*override*/
            ctx9[1]
          ) })
        ))) && { class: code_class_value },
        dirty & /*$$restProps*/
        65536 && /*$$restProps*/
        ctx9[16]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      4)
        useActions_action.update.call(
          null,
          /*use*/
          ctx9[2]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(code);
      }
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx8[22](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_else_block_1.name,
    type: "else",
    source: "(71:0) {:else}",
    ctx: ctx8
  });
  return block_1;
}
function create_if_block19(ctx8) {
  let pre;
  let t0;
  let current_block_type_index;
  let if_block0;
  let t1;
  let t2;
  let pre_class_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_27, create_else_block9];
  const if_blocks = [];
  function select_block_type_1(ctx9, dirty) {
    if (!/*noMono*/
    ctx9[7])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx8, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx8);
  let if_block1 = (
    /*copy*/
    ctx8[5] && create_if_block_111(ctx8)
  );
  let pre_levels = [
    {
      class: pre_class_value = /*cx*/
      ctx8[13](
        /*className*/
        ctx8[3],
        /*classes*/
        ctx8[12].root,
        /*getStyles*/
        ctx8[11]({ css: (
          /*override*/
          ctx8[1]
        ) })
      )
    },
    /*$$restProps*/
    ctx8[16]
  ];
  let pre_data = {};
  for (let i2 = 0; i2 < pre_levels.length; i2 += 1) {
    pre_data = assign(pre_data, pre_levels[i2]);
  }
  const block_1 = {
    c: function create() {
      pre = element("pre");
      t0 = text("		");
      if_block0.c();
      t1 = text("\n      ");
      if (if_block1)
        if_block1.c();
      t2 = text("\n    ");
      this.h();
    },
    l: function claim(nodes) {
      pre = claim_element(nodes, "PRE", { class: true });
      var pre_nodes = children(pre);
      t0 = claim_text(pre_nodes, "		");
      if_block0.l(pre_nodes);
      t1 = claim_text(pre_nodes, "\n      ");
      if (if_block1)
        if_block1.l(pre_nodes);
      t2 = claim_text(pre_nodes, "\n    ");
      pre_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(pre, pre_data);
      add_location(pre, file26, 53, 1, 1734);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, pre, anchor);
      append_hydration_dev(pre, t0);
      if_blocks[current_block_type_index].m(pre, null);
      append_hydration_dev(pre, t1);
      if (if_block1)
        if_block1.m(pre, null);
      append_hydration_dev(pre, t2);
      ctx8[21](pre);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            pre,
            /*use*/
            ctx8[2]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx8[14].call(null, pre))
        ];
        mounted = true;
      }
    },
    p: function update(ctx9, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx9, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx9, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx9);
          if_block0.c();
        } else {
          if_block0.p(ctx9, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(pre, t1);
      }
      if (
        /*copy*/
        ctx9[5]
      ) {
        if (if_block1) {
          if_block1.p(ctx9, dirty);
          if (dirty & /*copy*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_111(ctx9);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(pre, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      set_attributes(pre, pre_data = get_spread_update(pre_levels, [
        (!current || dirty & /*cx, className, classes, getStyles, override*/
        14346 && pre_class_value !== (pre_class_value = /*cx*/
        ctx9[13](
          /*className*/
          ctx9[3],
          /*classes*/
          ctx9[12].root,
          /*getStyles*/
          ctx9[11]({ css: (
            /*override*/
            ctx9[1]
          ) })
        ))) && { class: pre_class_value },
        dirty & /*$$restProps*/
        65536 && /*$$restProps*/
        ctx9[16]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      4)
        useActions_action.update.call(
          null,
          /*use*/
          ctx9[2]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(pre);
      }
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      ctx8[21](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block19.name,
    type: "if",
    source: "(53:0) {#if block}",
    ctx: ctx8
  });
  return block_1;
}
function fallback_block_22(ctx8) {
  let t;
  const block_1 = {
    c: function create() {
      t = text("Write some code");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Write some code");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: fallback_block_22.name,
    type: "fallback",
    source: "(79:8) Write some code",
    ctx: ctx8
  });
  return block_1;
}
function create_else_block9(ctx8) {
  let p;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[19],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block_12(ctx8);
  const block_1 = {
    c: function create() {
      p = element("p");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(p_nodes);
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        p,
        "class",
        /*className*/
        ctx8[3]
      );
      add_location(p, file26, 62, 3, 1984);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(p, null);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[19],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*className*/
      8) {
        attr_dev(
          p,
          "class",
          /*className*/
          ctx9[3]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_else_block9.name,
    type: "else",
    source: "(62:2) {:else}",
    ctx: ctx8
  });
  return block_1;
}
function create_if_block_27(ctx8) {
  let code;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[19],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block9(ctx8);
  const block_1 = {
    c: function create() {
      code = element("code");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      code = claim_element(nodes, "CODE", { class: true });
      var code_nodes = children(code);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(code_nodes);
      code_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        code,
        "class",
        /*className*/
        ctx8[3]
      );
      add_location(code, file26, 60, 3, 1911);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, code, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(code, null);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[19],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*className*/
      8) {
        attr_dev(
          code,
          "class",
          /*className*/
          ctx9[3]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(code);
      }
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block_27.name,
    type: "if",
    source: "(60:2) {#if !noMono}",
    ctx: ctx8
  });
  return block_1;
}
function fallback_block_12(ctx8) {
  let t;
  const block_1 = {
    c: function create() {
      t = text("Write some code");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Write some code");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: fallback_block_12.name,
    type: "fallback",
    source: "(63:30) Write some code",
    ctx: ctx8
  });
  return block_1;
}
function fallback_block9(ctx8) {
  let t;
  const block_1 = {
    c: function create() {
      t = text("Write some code");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Write some code");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: fallback_block9.name,
    type: "fallback",
    source: "(61:33) Write some code",
    ctx: ctx8
  });
  return block_1;
}
function create_if_block_111(ctx8) {
  let button;
  let copyicon;
  let button_class_value;
  let clipboard_action;
  let current;
  let mounted;
  let dispose;
  copyicon = new CopyIcon_default({
    props: { copied: (
      /*copied*/
      ctx8[9]
    ) },
    $$inline: true
  });
  const block_1 = {
    c: function create() {
      button = element("button");
      create_component(copyicon.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      claim_component(copyicon.$$.fragment, button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", button_class_value = null_to_empty(
        /*classes*/
        ctx8[12].copy
      ) + " svelte-xdvchn");
      add_location(button, file26, 65, 3, 2066);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      mount_component(copyicon, button, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*toggle*/
            ctx8[15],
            false,
            false,
            false,
            false
          ),
          action_destroyer(clipboard_action = clipboard.call(
            null,
            button,
            /*message*/
            ctx8[6]
          ))
        ];
        mounted = true;
      }
    },
    p: function update(ctx9, dirty) {
      const copyicon_changes = {};
      if (dirty & /*copied*/
      512)
        copyicon_changes.copied = /*copied*/
        ctx9[9];
      copyicon.$set(copyicon_changes);
      if (!current || dirty & /*classes*/
      4096 && button_class_value !== (button_class_value = null_to_empty(
        /*classes*/
        ctx9[12].copy
      ) + " svelte-xdvchn")) {
        attr_dev(button, "class", button_class_value);
      }
      if (clipboard_action && is_function(clipboard_action.update) && dirty & /*message*/
      64)
        clipboard_action.update.call(
          null,
          /*message*/
          ctx9[6]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(copyicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(copyicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      destroy_component(copyicon);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_if_block_111.name,
    type: "if",
    source: "(65:6) {#if copy}",
    ctx: ctx8
  });
  return block_1;
}
function create_fragment55(ctx8) {
  let error;
  let t;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  error = new Error_default({
    props: {
      observable: (
        /*observable*/
        ctx8[8]
      ),
      component: "Code",
      code: (
        /*err*/
        ctx8[10]
      )
    },
    $$inline: true
  });
  const if_block_creators = [create_if_block19, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx9, dirty) {
    if (
      /*block*/
      ctx9[4]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx8, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx8);
  const block_1 = {
    c: function create() {
      create_component(error.$$.fragment);
      t = space();
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(error.$$.fragment, nodes);
      t = claim_space(nodes);
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(error, target, anchor);
      insert_hydration_dev(target, t, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const error_changes = {};
      if (dirty & /*observable*/
      256)
        error_changes.observable = /*observable*/
        ctx9[8];
      if (dirty & /*err*/
      1024)
        error_changes.code = /*err*/
        ctx9[10];
      error.$set(error_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx9, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx9, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx9);
          if_block.c();
        } else {
          if_block.p(ctx9, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(error.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(error.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(if_block_anchor);
      }
      destroy_component(error, detaching);
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block: block_1,
    id: create_fragment55.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block_1;
}
function instance55($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "color",
    "block",
    "width",
    "copy",
    "message",
    "noMono"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Code", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, color = "gray", block = false, width = 100, copy = false, message = "Copied", noMono = false } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  let copied = false;
  function toggle() {
    $$invalidate(9, copied = true);
    setTimeout(() => $$invalidate(9, copied = false), 3e3);
  }
  let observable = false;
  let err;
  if (!block && width < 100) {
    observable = true;
    err = CodeErrors[0];
  }
  if (copy && message === "Copied") {
    observable = true;
    err = CodeErrors[1];
  }
  if (copy && !block) {
    observable = true;
    err = CodeErrors[2];
  }
  function pre_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  function code_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(1, override = $$new_props.override);
    if ("color" in $$new_props)
      $$invalidate(17, color = $$new_props.color);
    if ("block" in $$new_props)
      $$invalidate(4, block = $$new_props.block);
    if ("width" in $$new_props)
      $$invalidate(18, width = $$new_props.width);
    if ("copy" in $$new_props)
      $$invalidate(5, copy = $$new_props.copy);
    if ("message" in $$new_props)
      $$invalidate(6, message = $$new_props.message);
    if ("noMono" in $$new_props)
      $$invalidate(7, noMono = $$new_props.noMono);
    if ("$$scope" in $$new_props)
      $$invalidate(19, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    get_current_component,
    clipboard,
    useActions,
    createEventForwarder,
    Error: Error_default,
    useStyles: Code_styles_default,
    CopyIcon: CopyIcon_default,
    CodeErrors,
    use,
    element: element2,
    className,
    override,
    color,
    block,
    width,
    copy,
    message,
    noMono,
    forwardEvents,
    copied,
    toggle,
    observable,
    err,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(1, override = $$new_props.override);
    if ("color" in $$props)
      $$invalidate(17, color = $$new_props.color);
    if ("block" in $$props)
      $$invalidate(4, block = $$new_props.block);
    if ("width" in $$props)
      $$invalidate(18, width = $$new_props.width);
    if ("copy" in $$props)
      $$invalidate(5, copy = $$new_props.copy);
    if ("message" in $$props)
      $$invalidate(6, message = $$new_props.message);
    if ("noMono" in $$props)
      $$invalidate(7, noMono = $$new_props.noMono);
    if ("copied" in $$props)
      $$invalidate(9, copied = $$new_props.copied);
    if ("observable" in $$props)
      $$invalidate(8, observable = $$new_props.observable);
    if ("err" in $$props)
      $$invalidate(10, err = $$new_props.err);
    if ("getStyles" in $$props)
      $$invalidate(11, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(12, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(13, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*observable*/
    256) {
      $:
        if (observable)
          $$invalidate(1, override = { display: "none" });
    }
    if ($$self.$$.dirty & /*color, block, noMono, width*/
    393360) {
      $:
        $$invalidate(13, { cx: cx2, classes, getStyles } = Code_styles_default({ color, block, noMono, width }, { name: "Code" }), cx2, ($$invalidate(12, classes), $$invalidate(17, color), $$invalidate(4, block), $$invalidate(7, noMono), $$invalidate(18, width)), ($$invalidate(11, getStyles), $$invalidate(17, color), $$invalidate(4, block), $$invalidate(7, noMono), $$invalidate(18, width)));
    }
  };
  return [
    element2,
    override,
    use,
    className,
    block,
    copy,
    message,
    noMono,
    observable,
    copied,
    err,
    getStyles,
    classes,
    cx2,
    forwardEvents,
    toggle,
    $$restProps,
    color,
    width,
    $$scope,
    slots,
    pre_binding,
    code_binding
  ];
}
var Code = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance55,
      create_fragment55,
      safe_not_equal,
      {
        use: 2,
        element: 0,
        class: 3,
        override: 1,
        color: 17,
        block: 4,
        width: 18,
        copy: 5,
        message: 6,
        noMono: 7
      },
      add_css3
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Code",
      options,
      id: create_fragment55.name
    });
  }
  get use() {
    throw new Error_15("<Code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error_15("<Code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error_15("<Code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error_15("<Code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error_15("<Code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error_15("<Code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error_15("<Code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error_15("<Code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error_15("<Code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error_15("<Code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get block() {
    throw new Error_15("<Code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set block(value) {
    throw new Error_15("<Code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error_15("<Code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error_15("<Code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get copy() {
    throw new Error_15("<Code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set copy(value) {
    throw new Error_15("<Code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get message() {
    throw new Error_15("<Code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set message(value) {
    throw new Error_15("<Code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noMono() {
    throw new Error_15("<Code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noMono(value) {
    throw new Error_15("<Code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Code_default = Code;

// node_modules/@svelteuidev/core/dist/components/Container/Container.styles.js
var Container_styles_default = createStyles((theme4, { fluid, size: size3, sizes: sizes15 }) => {
  return {
    root: {
      paddingLeft: theme4.fn.size({ size: size3, sizes: theme4.space }),
      paddingRight: theme4.fn.size({ size: size3, sizes: theme4.space }),
      maxWidth: fluid ? "100%" : typeof size3 === "number" ? `${size3}px` : sizes15[size3] ?? sizes15.md,
      marginLeft: "auto",
      marginRight: "auto"
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Container/Container.svelte
function create_default_slot40(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[13],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[13],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot40.name,
    type: "slot",
    source: "(35:0) <Box  bind:element  {use}  class={cx(className, classes.root, getStyles({ css: override }))}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment56(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { use: (
      /*use*/
      ctx8[1]
    ) },
    {
      class: (
        /*cx*/
        ctx8[6](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[5].root,
          /*getStyles*/
          ctx8[4]({ css: (
            /*override*/
            ctx8[3]
          ) })
        )
      )
    },
    /*$$restProps*/
    ctx8[7]
  ];
  function box_element_binding(value) {
    ctx8[12](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot40] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*use, cx, className, classes, getStyles, override, $$restProps*/
      254 ? get_spread_update(box_spread_levels, [
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*cx, className, classes, getStyles, override*/
        124 && {
          class: (
            /*cx*/
            ctx9[6](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[5].root,
              /*getStyles*/
              ctx9[4]({ css: (
                /*override*/
                ctx9[3]
              ) })
            )
          )
        },
        dirty & /*$$restProps*/
        128 && get_spread_object(
          /*$$restProps*/
          ctx9[7]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      8192) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment56.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance56($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = ["use", "element", "class", "override", "size", "fluid", "sizes"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Container", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, size: size3 = "md", fluid = false, sizes: sizes15 = {
    xs: 540,
    sm: 720,
    md: 960,
    lg: 1140,
    xl: 1320
  } } = $$props;
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("size" in $$new_props)
      $$invalidate(8, size3 = $$new_props.size);
    if ("fluid" in $$new_props)
      $$invalidate(9, fluid = $$new_props.fluid);
    if ("sizes" in $$new_props)
      $$invalidate(10, sizes15 = $$new_props.sizes);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: Container_styles_default,
    Box: Box_default,
    use,
    element: element2,
    className,
    override,
    size: size3,
    fluid,
    sizes: sizes15,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("size" in $$props)
      $$invalidate(8, size3 = $$new_props.size);
    if ("fluid" in $$props)
      $$invalidate(9, fluid = $$new_props.fluid);
    if ("sizes" in $$props)
      $$invalidate(10, sizes15 = $$new_props.sizes);
    if ("getStyles" in $$props)
      $$invalidate(4, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(5, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(6, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*fluid, size, sizes*/
    1792) {
      $:
        $$invalidate(6, { cx: cx2, classes, getStyles } = Container_styles_default({ fluid, size: size3, sizes: sizes15 }, { name: "Container" }), cx2, ($$invalidate(5, classes), $$invalidate(9, fluid), $$invalidate(8, size3), $$invalidate(10, sizes15)), ($$invalidate(4, getStyles), $$invalidate(9, fluid), $$invalidate(8, size3), $$invalidate(10, sizes15)));
    }
  };
  return [
    element2,
    use,
    className,
    override,
    getStyles,
    classes,
    cx2,
    $$restProps,
    size3,
    fluid,
    sizes15,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Container = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance56, create_fragment56, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      size: 8,
      fluid: 9,
      sizes: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Container",
      options,
      id: create_fragment56.name
    });
  }
  get use() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fluid() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fluid(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sizes() {
    throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sizes(value) {
    throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Container_default = Container;

// node_modules/@svelteuidev/core/dist/components/Divider/Divider.styles.js
var sizes8 = {
  xs: 1,
  sm: 2,
  md: 3,
  lg: 4,
  xl: 5
};
var Divider_styles_default = createStyles((theme4, { color, size: size3, variant: variant2 }) => {
  const { size: sizeFn, themeColor: themeColor2 } = theme4.fn;
  return {
    root: {},
    horizontal: {
      border: 0,
      borderTopWidth: typeof size3 === "number" ? `${size3}px` : sizeFn({ size: size3, sizes: sizes8 }),
      borderTopColor: themeColor2(color, 4),
      borderTopStyle: variant2,
      margin: "12px 0px 12px 0px"
    },
    vertical: {
      border: 0,
      alignSelf: "stretch",
      height: "100%",
      borderLeftWidth: typeof size3 === "number" ? `${size3}px` : sizeFn({ size: size3, sizes: sizes8 }),
      borderLeftColor: themeColor2(color, 4),
      borderLeftStyle: variant2
    },
    showsLabel: {
      borderTop: "0 !important"
    },
    label: {
      display: "flex",
      alignItems: "center",
      color: color === "dark" ? themeColor2("dark", 1) : themeColor2(color, 6),
      [`${theme4.dark} &`]: {
        color: color === "dark" ? themeColor2("dark", 1) : themeColor2(color, 5)
      },
      "&.left": {
        "&::before": {
          display: "none"
        }
      },
      "&.right": {
        "&::after": {
          display: "none"
        }
      },
      "&::before": {
        content: '""',
        flex: 1,
        height: 1,
        borderTopWidth: typeof size3 === "number" ? `${size3}px` : sizeFn({ size: size3, sizes: sizes8 }),
        borderTopStyle: `${variant2}`,
        borderTopColor: themeColor2(color, 4),
        marginRight: "10px",
        [`${theme4.dark} &`]: {
          borderTopColor: themeColor2(color, 3)
        }
      },
      "&::after": {
        content: '""',
        flex: 1,
        borderTopWidth: typeof size3 === "number" ? `${size3}px` : sizeFn({ size: size3, sizes: sizes8 }),
        borderTopStyle: `${variant2}`,
        borderTopColor: themeColor2(color, 3),
        marginLeft: "10px"
      }
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Divider/Divider.errors.js
var Divider_errors_exports = {};
__export(Divider_errors_exports, {
  DividerErrors: () => DividerErrors
});
var DividerErrors = Object.freeze([
  {
    error: true,
    message: "If using label or label slot, it cannot use orientation 'vertical'",
    solution: `
                If your component looks like this:
                
                &lt;Divider orientation='vertical' label='text...'&lt;/Divider&gt;
                                        ^^^^^^^^^ - Try changing orientation to 'horizontal'
                `
  }
]);

// node_modules/@svelteuidev/core/dist/components/Divider/Divider.svelte
var { Error: Error_16 } = globals;
var get_label_slot_changes = (dirty) => ({});
var get_label_slot_context = (ctx8) => ({});
function create_if_block20(ctx8) {
  var _a;
  let text_1;
  let current;
  const text_1_spread_levels = [
    {
      class: (
        /*cx*/
        ctx8[12](
          /*classes*/
          ctx8[11].label,
          /*labelPosition*/
          ctx8[6]
        )
      )
    },
    /*labelProps*/
    ctx8[7],
    {
      size: (
        /*labelProps*/
        ((_a = ctx8[7]) == null ? void 0 : _a.size) || /*size*/
        ctx8[4]
      )
    }
  ];
  let text_1_props = {
    $$slots: { default: [create_default_slot_18] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < text_1_spread_levels.length; i2 += 1) {
    text_1_props = assign(text_1_props, text_1_spread_levels[i2]);
  }
  text_1 = new Text_default({ props: text_1_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(text_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(text_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(text_1, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      var _a2;
      const text_1_changes = dirty & /*cx, classes, labelPosition, labelProps, size*/
      6352 ? get_spread_update(text_1_spread_levels, [
        dirty & /*cx, classes, labelPosition*/
        6208 && {
          class: (
            /*cx*/
            ctx9[12](
              /*classes*/
              ctx9[11].label,
              /*labelPosition*/
              ctx9[6]
            )
          )
        },
        dirty & /*labelProps*/
        128 && get_spread_object(
          /*labelProps*/
          ctx9[7]
        ),
        dirty & /*labelProps, size*/
        144 && {
          size: (
            /*labelProps*/
            ((_a2 = ctx9[7]) == null ? void 0 : _a2.size) || /*size*/
            ctx9[4]
          )
        }
      ]) : {};
      if (dirty & /*$$scope, label*/
      4194336) {
        text_1_changes.$$scope = { dirty, ctx: ctx9 };
      }
      text_1.$set(text_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(text_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block20.name,
    type: "if",
    source: "(57:1) {#if showsLabel}",
    ctx: ctx8
  });
  return block;
}
function fallback_block10(ctx8) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*label*/
        ctx8[5]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*label*/
        ctx8[5]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*label*/
      32)
        set_data_dev(
          t,
          /*label*/
          ctx9[5]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block10.name,
    type: "fallback",
    source: "(59:22)      ",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_18(ctx8) {
  let current;
  const label_slot_template = (
    /*#slots*/
    ctx8[20].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[22],
    get_label_slot_context
  );
  const label_slot_or_fallback = label_slot || fallback_block10(ctx8);
  const block = {
    c: function create() {
      if (label_slot_or_fallback)
        label_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (label_slot_or_fallback)
        label_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (label_slot_or_fallback) {
        label_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty & /*$$scope*/
        4194304)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[22]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx9[22],
              dirty,
              get_label_slot_changes
            ),
            get_label_slot_context
          );
        }
      } else {
        if (label_slot_or_fallback && label_slot_or_fallback.p && (!current || dirty & /*label*/
        32)) {
          label_slot_or_fallback.p(ctx9, !current ? -1 : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (label_slot_or_fallback)
        label_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_18.name,
    type: "slot",
    source: "(58:2) <Text class={cx(classes.label, labelPosition)} {...labelProps} size={labelProps?.size || size}>",
    ctx: ctx8
  });
  return block;
}
function create_default_slot41(ctx8) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*showsLabel*/
    ctx8[15] && create_if_block20(ctx8)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (
        /*showsLabel*/
        ctx9[15]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
          if (dirty & /*showsLabel*/
          32768) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block20(ctx9);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot41.name,
    type: "slot",
    source: "(44:0) <Box  bind:element  {use}  class={cx(   className,   classes.root,   isHorizontal ? classes.horizontal : {},   isVertical ? classes.vertical : {},   showsLabel ? classes.showsLabel : {},   getStyles({ css: override })  )}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment57(ctx8) {
  let error;
  let t;
  let box;
  let updating_element;
  let current;
  error = new Error_default({
    props: {
      observable: (
        /*observable*/
        ctx8[8]
      ),
      component: "Divider",
      code: (
        /*err*/
        ctx8[9]
      )
    },
    $$inline: true
  });
  const box_spread_levels = [
    { use: (
      /*use*/
      ctx8[2]
    ) },
    {
      class: (
        /*cx*/
        ctx8[12](
          /*className*/
          ctx8[3],
          /*classes*/
          ctx8[11].root,
          /*isHorizontal*/
          ctx8[14] ? (
            /*classes*/
            ctx8[11].horizontal
          ) : {},
          /*isVertical*/
          ctx8[13] ? (
            /*classes*/
            ctx8[11].vertical
          ) : {},
          /*showsLabel*/
          ctx8[15] ? (
            /*classes*/
            ctx8[11].showsLabel
          ) : {},
          /*getStyles*/
          ctx8[10]({ css: (
            /*override*/
            ctx8[1]
          ) })
        )
      )
    },
    /*$$restProps*/
    ctx8[16]
  ];
  function box_element_binding(value) {
    ctx8[21](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot41] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(error.$$.fragment);
      t = space();
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(error.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(error, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const error_changes = {};
      if (dirty & /*observable*/
      256)
        error_changes.observable = /*observable*/
        ctx9[8];
      if (dirty & /*err*/
      512)
        error_changes.code = /*err*/
        ctx9[9];
      error.$set(error_changes);
      const box_changes = dirty & /*use, cx, className, classes, isHorizontal, isVertical, showsLabel, getStyles, override, $$restProps*/
      130062 ? get_spread_update(box_spread_levels, [
        dirty & /*use*/
        4 && { use: (
          /*use*/
          ctx9[2]
        ) },
        dirty & /*cx, className, classes, isHorizontal, isVertical, showsLabel, getStyles, override*/
        64522 && {
          class: (
            /*cx*/
            ctx9[12](
              /*className*/
              ctx9[3],
              /*classes*/
              ctx9[11].root,
              /*isHorizontal*/
              ctx9[14] ? (
                /*classes*/
                ctx9[11].horizontal
              ) : {},
              /*isVertical*/
              ctx9[13] ? (
                /*classes*/
                ctx9[11].vertical
              ) : {},
              /*showsLabel*/
              ctx9[15] ? (
                /*classes*/
                ctx9[11].showsLabel
              ) : {},
              /*getStyles*/
              ctx9[10]({ css: (
                /*override*/
                ctx9[1]
              ) })
            )
          )
        },
        dirty & /*$$restProps*/
        65536 && get_spread_object(
          /*$$restProps*/
          ctx9[16]
        )
      ]) : {};
      if (dirty & /*$$scope, cx, classes, labelPosition, labelProps, size, label, showsLabel*/
      4233456) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(error.$$.fragment, local);
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(error.$$.fragment, local);
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_component(error, detaching);
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment57.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance57($$self, $$props, $$invalidate) {
  let showsLabel;
  let isVertical;
  let isHorizontal;
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "color",
    "orientation",
    "size",
    "label",
    "labelPosition",
    "labelProps",
    "variant"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Divider", slots, ["label"]);
  const $$slots = compute_slots(slots);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, color = "gray", orientation = "horizontal", size: size3 = "xs", label = null, labelPosition = "left", labelProps = null, variant: variant2 = "solid" } = $$props;
  let observable = false;
  let err;
  if (isVertical && (label || $$slots.label)) {
    observable = true;
    err = DividerErrors[0];
  }
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(1, override = $$new_props.override);
    if ("color" in $$new_props)
      $$invalidate(17, color = $$new_props.color);
    if ("orientation" in $$new_props)
      $$invalidate(18, orientation = $$new_props.orientation);
    if ("size" in $$new_props)
      $$invalidate(4, size3 = $$new_props.size);
    if ("label" in $$new_props)
      $$invalidate(5, label = $$new_props.label);
    if ("labelPosition" in $$new_props)
      $$invalidate(6, labelPosition = $$new_props.labelPosition);
    if ("labelProps" in $$new_props)
      $$invalidate(7, labelProps = $$new_props.labelProps);
    if ("variant" in $$new_props)
      $$invalidate(19, variant2 = $$new_props.variant);
    if ("$$scope" in $$new_props)
      $$invalidate(22, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Error: Error_default,
    Box: Box_default,
    Text: Text_default,
    useStyles: Divider_styles_default,
    DividerErrors,
    use,
    element: element2,
    className,
    override,
    color,
    orientation,
    size: size3,
    label,
    labelPosition,
    labelProps,
    variant: variant2,
    observable,
    err,
    getStyles,
    classes,
    cx: cx2,
    isVertical,
    isHorizontal,
    showsLabel
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(1, override = $$new_props.override);
    if ("color" in $$props)
      $$invalidate(17, color = $$new_props.color);
    if ("orientation" in $$props)
      $$invalidate(18, orientation = $$new_props.orientation);
    if ("size" in $$props)
      $$invalidate(4, size3 = $$new_props.size);
    if ("label" in $$props)
      $$invalidate(5, label = $$new_props.label);
    if ("labelPosition" in $$props)
      $$invalidate(6, labelPosition = $$new_props.labelPosition);
    if ("labelProps" in $$props)
      $$invalidate(7, labelProps = $$new_props.labelProps);
    if ("variant" in $$props)
      $$invalidate(19, variant2 = $$new_props.variant);
    if ("observable" in $$props)
      $$invalidate(8, observable = $$new_props.observable);
    if ("err" in $$props)
      $$invalidate(9, err = $$new_props.err);
    if ("getStyles" in $$props)
      $$invalidate(10, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(11, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(12, cx2 = $$new_props.cx);
    if ("isVertical" in $$props)
      $$invalidate(13, isVertical = $$new_props.isVertical);
    if ("isHorizontal" in $$props)
      $$invalidate(14, isHorizontal = $$new_props.isHorizontal);
    if ("showsLabel" in $$props)
      $$invalidate(15, showsLabel = $$new_props.showsLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*label, orientation*/
    262176) {
      $:
        $$invalidate(15, showsLabel = (label || $$slots.label) && orientation === "horizontal");
    }
    if ($$self.$$.dirty & /*orientation*/
    262144) {
      $:
        $$invalidate(13, isVertical = orientation === "vertical");
    }
    if ($$self.$$.dirty & /*orientation*/
    262144) {
      $:
        $$invalidate(14, isHorizontal = orientation === "horizontal");
    }
    if ($$self.$$.dirty & /*observable*/
    256) {
      $:
        if (observable)
          $$invalidate(1, override = { display: "none" });
    }
    if ($$self.$$.dirty & /*color, size, variant*/
    655376) {
      $:
        $$invalidate(12, { cx: cx2, classes, getStyles } = Divider_styles_default({ color, size: size3, variant: variant2 }, { name: "Divider" }), cx2, ($$invalidate(11, classes), $$invalidate(17, color), $$invalidate(4, size3), $$invalidate(19, variant2)), ($$invalidate(10, getStyles), $$invalidate(17, color), $$invalidate(4, size3), $$invalidate(19, variant2)));
    }
  };
  return [
    element2,
    override,
    use,
    className,
    size3,
    label,
    labelPosition,
    labelProps,
    observable,
    err,
    getStyles,
    classes,
    cx2,
    isVertical,
    isHorizontal,
    showsLabel,
    $$restProps,
    color,
    orientation,
    variant2,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Divider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance57, create_fragment57, safe_not_equal, {
      use: 2,
      element: 0,
      class: 3,
      override: 1,
      color: 17,
      orientation: 18,
      size: 4,
      label: 5,
      labelPosition: 6,
      labelProps: 7,
      variant: 19
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Divider",
      options,
      id: create_fragment57.name
    });
  }
  get use() {
    throw new Error_16("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error_16("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error_16("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error_16("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error_16("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error_16("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error_16("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error_16("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error_16("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error_16("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get orientation() {
    throw new Error_16("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orientation(value) {
    throw new Error_16("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error_16("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error_16("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error_16("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error_16("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelPosition() {
    throw new Error_16("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelPosition(value) {
    throw new Error_16("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelProps() {
    throw new Error_16("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelProps(value) {
    throw new Error_16("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error_16("<Divider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error_16("<Divider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Divider_default = Divider;

// node_modules/@svelteuidev/core/dist/components/FileUpload/FileUpload.styles.js
var fontSizes2 = {
  xs: 12,
  sm: 14,
  md: 16,
  lg: 18,
  xl: 20
};
var heights = {
  xs: 30,
  sm: 38,
  md: 48,
  lg: 58,
  xl: 68
};
var FileUpload_styles_default = createStyles((theme4, { color, size: size3 }) => ({
  root: {
    position: "relative",
    display: "flex"
  },
  drag: {
    [`${theme4.dark} &`]: {
      background: theme4.fn.themeColor("dark", 4),
      border: `1px dashed ${theme4.fn.themeColor("dark", 4)}`
    },
    position: "relative",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    flexDirection: "column",
    gap: "12px",
    padding: "20px 10px",
    width: "100%",
    height: "100%",
    textAlign: "center",
    background: "#fafafa",
    border: `1px dashed ${theme4.fn.themeColor("gray", 4)}`,
    borderRadius: "2px",
    cursor: "pointer",
    "&:hover": {
      border: `1px dashed ${color}`
    },
    "&.disabled *": {
      [`${theme4.dark} &`]: {
        background: theme4.fn.themeColor("dark", 4),
        border: `1px dashed ${theme4.fn.themeColor("dark", 4)}`,
        color: theme4.fn.themeColor("gray", 6)
      },
      background: theme4.fn.themeColor("light", 4),
      border: `1px dashed ${theme4.fn.themeColor("light", 4)}`,
      color: theme4.fn.themeColor("gray", 4)
    }
  },
  inputContainer: {
    width: 0,
    height: 0,
    padding: 0,
    opacity: 0,
    margin: 0,
    overflow: "hidden"
  },
  input: {
    visibility: "hidden"
  },
  icon: {
    fontSize: "30px"
  },
  uploadIcon: {
    paddingRight: "15px"
  },
  active: {
    backgroundColor: `${color}`
  },
  fileItemWrapper: {
    [`${theme4.dark} &`]: {
      border: `1px solid ${theme4.fn.themeColor("dark", 4)}`
    },
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
    height: heights[size3],
    padding: "8px",
    border: `1px solid ${theme4.fn.themeColor("gray", 4)}`,
    borderRadius: "2px",
    margin: "8px 0px"
  },
  fileItemIcon: {
    lineHeight: "60px",
    textAlign: "center",
    opacity: ".8",
    flex: "none"
  },
  fileItemName: {
    flex: "auto",
    margin: 0,
    padding: "0 8px",
    fontSize: fontSizes2[size3]
  },
  fileItemAction: {
    position: "static",
    marginLeft: "8px",
    marginRight: "8px"
  },
  buttonType: {
    display: "flex",
    gap: "10px"
  }
}));

// node_modules/@svelteuidev/core/dist/components/FileUpload/FileUpload.svelte
var file_1 = "node_modules/@svelteuidev/core/dist/components/FileUpload/FileUpload.svelte";
function get_each_context3(ctx8, list, i2) {
  const child_ctx = ctx8.slice();
  child_ctx[41] = list[i2].file;
  child_ctx[43] = i2;
  return child_ctx;
}
var get_removeIcon_slot_changes = (dirty) => ({});
var get_removeIcon_slot_context = (ctx8) => ({});
var get_fileIcon_slot_changes = (dirty) => ({});
var get_fileIcon_slot_context = (ctx8) => ({});
var get_leftIcon_slot_changes_12 = (dirty) => ({});
var get_leftIcon_slot_context_12 = (ctx8) => ({});
var get_leftIcon_slot_changes2 = (dirty) => ({});
var get_leftIcon_slot_context2 = (ctx8) => ({});
function create_else_block10(ctx8) {
  let div;
  let button;
  let t;
  let div_class_value;
  let current;
  button = new Button_default({
    props: {
      size: (
        /*size*/
        ctx8[11]
      ),
      disabled: (
        /*disabled*/
        ctx8[12]
      ),
      color: (
        /*color*/
        ctx8[10]
      ),
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  button.$on(
    "click",
    /*click_handler*/
    ctx8[36]
  );
  let if_block = (
    /*reset*/
    ctx8[17] && create_if_block_28(ctx8)
  );
  const block = {
    c: function create() {
      div = element("div");
      create_component(button.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(button.$$.fragment, div_nodes);
      t = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*classes*/
      ctx8[24].buttonType);
      add_location(div, file_1, 87, 2, 2685);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(button, div, null);
      append_hydration_dev(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const button_changes = {};
      if (dirty[0] & /*size*/
      2048)
        button_changes.size = /*size*/
        ctx9[11];
      if (dirty[0] & /*disabled*/
      4096)
        button_changes.disabled = /*disabled*/
        ctx9[12];
      if (dirty[0] & /*color*/
      1024)
        button_changes.color = /*color*/
        ctx9[10];
      if (dirty[0] & /*label, icon*/
      16896 | dirty[1] & /*$$scope*/
      256) {
        button_changes.$$scope = { dirty, ctx: ctx9 };
      }
      button.$set(button_changes);
      if (
        /*reset*/
        ctx9[17]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
          if (dirty[0] & /*reset*/
          131072) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_28(ctx9);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*classes*/
      16777216 && div_class_value !== (div_class_value = /*classes*/
      ctx9[24].buttonType)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(button);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block10.name,
    type: "else",
    source: "(87:1) {:else}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_112(ctx8) {
  let label_1;
  let label_1_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx8[31].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[39],
    null
  );
  const block = {
    c: function create() {
      label_1 = element("label");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      label_1 = claim_element(nodes, "LABEL", { for: true, class: true });
      var label_1_nodes = children(label_1);
      if (default_slot)
        default_slot.l(label_1_nodes);
      label_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        label_1,
        "for",
        /*id*/
        ctx8[13]
      );
      attr_dev(label_1, "class", label_1_class_value = /*cx*/
      ctx8[25](
        /*classes*/
        ctx8[24].drag,
        /*getStyles*/
        ctx8[23]({ css: (
          /*override*/
          ctx8[4]
        ) })
      ));
      toggle_class(
        label_1,
        "disabled",
        /*disabled*/
        ctx8[12]
      );
      add_location(label_1, file_1, 72, 2, 2372);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label_1, anchor);
      if (default_slot) {
        default_slot.m(label_1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            label_1,
            "dragleave",
            /*dragleave_handler*/
            ctx8[32],
            false,
            false,
            false,
            false
          ),
          listen_dev(label_1, "dragover", dragover_handler, false, false, false, false),
          listen_dev(label_1, "drop", stop_propagation(prevent_default(
            /*drop_handler*/
            ctx8[35]
          )), false, true, true, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[39],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[39]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[39],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*id*/
      8192) {
        attr_dev(
          label_1,
          "for",
          /*id*/
          ctx9[13]
        );
      }
      if (!current || dirty[0] & /*cx, classes, getStyles, override*/
      58720272 && label_1_class_value !== (label_1_class_value = /*cx*/
      ctx9[25](
        /*classes*/
        ctx9[24].drag,
        /*getStyles*/
        ctx9[23]({ css: (
          /*override*/
          ctx9[4]
        ) })
      ))) {
        attr_dev(label_1, "class", label_1_class_value);
      }
      if (!current || dirty[0] & /*cx, classes, getStyles, override, disabled*/
      58724368) {
        toggle_class(
          label_1,
          "disabled",
          /*disabled*/
          ctx9[12]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label_1);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_112.name,
    type: "if",
    source: "(72:1) {#if type && type == 'drag'}",
    ctx: ctx8
  });
  return block;
}
function fallback_block_32(ctx8) {
  let iconrenderer;
  let current;
  iconrenderer = new IconRenderer_default({
    props: { icon: (
      /*icon*/
      ctx8[14]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(iconrenderer.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconrenderer.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconrenderer, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const iconrenderer_changes = {};
      if (dirty[0] & /*icon*/
      16384)
        iconrenderer_changes.icon = /*icon*/
        ctx9[14];
      iconrenderer.$set(iconrenderer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconrenderer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconrenderer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconrenderer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_32.name,
    type: "fallback",
    source: "(97:26)       ",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_3(ctx8) {
  let t0;
  let t1;
  let current;
  const leftIcon_slot_template = (
    /*#slots*/
    ctx8[31].leftIcon
  );
  const leftIcon_slot = create_slot(
    leftIcon_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[39],
    get_leftIcon_slot_context2
  );
  const leftIcon_slot_or_fallback = leftIcon_slot || fallback_block_32(ctx8);
  const block = {
    c: function create() {
      if (leftIcon_slot_or_fallback)
        leftIcon_slot_or_fallback.c();
      t0 = space();
      t1 = text(
        /*label*/
        ctx8[9]
      );
    },
    l: function claim(nodes) {
      if (leftIcon_slot_or_fallback)
        leftIcon_slot_or_fallback.l(nodes);
      t0 = claim_space(nodes);
      t1 = claim_text(
        nodes,
        /*label*/
        ctx8[9]
      );
    },
    m: function mount(target, anchor) {
      if (leftIcon_slot_or_fallback) {
        leftIcon_slot_or_fallback.m(target, anchor);
      }
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (leftIcon_slot) {
        if (leftIcon_slot.p && (!current || dirty[1] & /*$$scope*/
        256)) {
          update_slot_base(
            leftIcon_slot,
            leftIcon_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[39],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[39]
            ) : get_slot_changes(
              leftIcon_slot_template,
              /*$$scope*/
              ctx9[39],
              dirty,
              get_leftIcon_slot_changes2
            ),
            get_leftIcon_slot_context2
          );
        }
      } else {
        if (leftIcon_slot_or_fallback && leftIcon_slot_or_fallback.p && (!current || dirty[0] & /*icon*/
        16384)) {
          leftIcon_slot_or_fallback.p(ctx9, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*label*/
      512)
        set_data_dev(
          t1,
          /*label*/
          ctx9[9]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(leftIcon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(leftIcon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
      if (leftIcon_slot_or_fallback)
        leftIcon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: "(89:3) <Button     {size}     {disabled}     {color}     on:click={() => {      fileUploadComponent.click();     }}    >",
    ctx: ctx8
  });
  return block;
}
function create_if_block_28(ctx8) {
  let button;
  let current;
  button = new Button_default({
    props: {
      size: (
        /*size*/
        ctx8[11]
      ),
      color: (
        /*resetColor*/
        ctx8[19]
      ),
      disabled: (
        /*files*/
        ctx8[1].length == 0
      ),
      $$slots: { default: [create_default_slot_23] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  button.$on(
    "click",
    /*resetFiles*/
    ctx8[29]
  );
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const button_changes = {};
      if (dirty[0] & /*size*/
      2048)
        button_changes.size = /*size*/
        ctx9[11];
      if (dirty[0] & /*resetColor*/
      524288)
        button_changes.color = /*resetColor*/
        ctx9[19];
      if (dirty[0] & /*files*/
      2)
        button_changes.disabled = /*files*/
        ctx9[1].length == 0;
      if (dirty[0] & /*resetLabel, resetIcon*/
      1310720 | dirty[1] & /*$$scope*/
      256) {
        button_changes.$$scope = { dirty, ctx: ctx9 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_28.name,
    type: "if",
    source: "(103:3) {#if reset}",
    ctx: ctx8
  });
  return block;
}
function fallback_block_23(ctx8) {
  let iconrenderer;
  let current;
  iconrenderer = new IconRenderer_default({
    props: { icon: (
      /*resetIcon*/
      ctx8[20]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(iconrenderer.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconrenderer.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconrenderer, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const iconrenderer_changes = {};
      if (dirty[0] & /*resetIcon*/
      1048576)
        iconrenderer_changes.icon = /*resetIcon*/
        ctx9[20];
      iconrenderer.$set(iconrenderer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconrenderer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconrenderer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconrenderer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_23.name,
    type: "fallback",
    source: "(105:27)        ",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_23(ctx8) {
  let t0;
  let t1;
  let current;
  const leftIcon_slot_template = (
    /*#slots*/
    ctx8[31].leftIcon
  );
  const leftIcon_slot = create_slot(
    leftIcon_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[39],
    get_leftIcon_slot_context_12
  );
  const leftIcon_slot_or_fallback = leftIcon_slot || fallback_block_23(ctx8);
  const block = {
    c: function create() {
      if (leftIcon_slot_or_fallback)
        leftIcon_slot_or_fallback.c();
      t0 = space();
      t1 = text(
        /*resetLabel*/
        ctx8[18]
      );
    },
    l: function claim(nodes) {
      if (leftIcon_slot_or_fallback)
        leftIcon_slot_or_fallback.l(nodes);
      t0 = claim_space(nodes);
      t1 = claim_text(
        nodes,
        /*resetLabel*/
        ctx8[18]
      );
    },
    m: function mount(target, anchor) {
      if (leftIcon_slot_or_fallback) {
        leftIcon_slot_or_fallback.m(target, anchor);
      }
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (leftIcon_slot) {
        if (leftIcon_slot.p && (!current || dirty[1] & /*$$scope*/
        256)) {
          update_slot_base(
            leftIcon_slot,
            leftIcon_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[39],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[39]
            ) : get_slot_changes(
              leftIcon_slot_template,
              /*$$scope*/
              ctx9[39],
              dirty,
              get_leftIcon_slot_changes_12
            ),
            get_leftIcon_slot_context_12
          );
        }
      } else {
        if (leftIcon_slot_or_fallback && leftIcon_slot_or_fallback.p && (!current || dirty[0] & /*resetIcon*/
        1048576)) {
          leftIcon_slot_or_fallback.p(ctx9, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*resetLabel*/
      262144)
        set_data_dev(
          t1,
          /*resetLabel*/
          ctx9[18]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(leftIcon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(leftIcon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
      }
      if (leftIcon_slot_or_fallback)
        leftIcon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_23.name,
    type: "slot",
    source: "(104:4) <Button {size} color={resetColor} disabled={files.length == 0} on:click={resetFiles}>",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_19(ctx8) {
  let div;
  let input;
  let useActions_action;
  let forwardEvents_action;
  let div_class_value;
  let t;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_112, create_else_block10];
  const if_blocks = [];
  function select_block_type(ctx9, dirty) {
    if (
      /*type*/
      ctx9[6] && /*type*/
      ctx9[6] == "drag"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx8, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx8);
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      t = space();
      if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      input = claim_element(div_nodes, "INPUT", {
        type: true,
        accept: true,
        id: true,
        tabindex: true,
        name: true
      });
      div_nodes.forEach(detach_dev);
      t = claim_space(nodes);
      if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "file");
      input.multiple = /*multiple*/
      ctx8[8];
      attr_dev(
        input,
        "accept",
        /*accept*/
        ctx8[5]
      );
      attr_dev(
        input,
        "id",
        /*id*/
        ctx8[13]
      );
      input.disabled = /*disabled*/
      ctx8[12];
      attr_dev(input, "tabindex", "-1");
      attr_dev(
        input,
        "name",
        /*name*/
        ctx8[7]
      );
      add_location(input, file_1, 54, 2, 2083);
      attr_dev(div, "class", div_class_value = /*classes*/
      ctx8[24].inputContainer);
      add_location(div, file_1, 53, 1, 2044);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, input);
      ctx8[33](input);
      insert_hydration_dev(target, t, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx8[34],
            false,
            false,
            false,
            false
          ),
          action_destroyer(useActions_action = useActions.call(
            null,
            input,
            /*use*/
            ctx8[2]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx8[26].call(null, input))
        ];
        mounted = true;
      }
    },
    p: function update(ctx9, dirty) {
      if (!current || dirty[0] & /*multiple*/
      256) {
        prop_dev(
          input,
          "multiple",
          /*multiple*/
          ctx9[8]
        );
      }
      if (!current || dirty[0] & /*accept*/
      32) {
        attr_dev(
          input,
          "accept",
          /*accept*/
          ctx9[5]
        );
      }
      if (!current || dirty[0] & /*id*/
      8192) {
        attr_dev(
          input,
          "id",
          /*id*/
          ctx9[13]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      4096) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx9[12]
        );
      }
      if (!current || dirty[0] & /*name*/
      128) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx9[7]
        );
      }
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/
      4)
        useActions_action.update.call(
          null,
          /*use*/
          ctx9[2]
        );
      if (!current || dirty[0] & /*classes*/
      16777216 && div_class_value !== (div_class_value = /*classes*/
      ctx9[24].inputContainer)) {
        attr_dev(div, "class", div_class_value);
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx9, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx9, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx9);
          if_block.c();
        } else {
          if_block.p(ctx9, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
        detach_dev(t);
        detach_dev(if_block_anchor);
      }
      ctx8[33](null);
      if_blocks[current_block_type_index].d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_19.name,
    type: "slot",
    source: "(53:0) <Box bind:element {use} class={cx(className, classes.root)} {...$$restProps}>",
    ctx: ctx8
  });
  return block;
}
function create_if_block21(ctx8) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*files*/
    ctx8[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block3(get_each_context3(ctx8, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  const block = {
    c: function create() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*classes, size, remove, removeIcon, files, fileIcon*/
      285313026 | dirty[1] & /*$$scope*/
      256) {
        each_value = ensure_array_like_dev(
          /*files*/
          ctx9[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context3(ctx9, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block3(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block21.name,
    type: "if",
    source: "(114:0) {#if preview}",
    ctx: ctx8
  });
  return block;
}
function fallback_block_13(ctx8) {
  let iconrenderer;
  let current;
  iconrenderer = new IconRenderer_default({
    props: {
      iconSize: fontSizes2[
        /*size*/
        ctx8[11]
      ] * 1.8,
      icon: (
        /*fileIcon*/
        ctx8[15]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(iconrenderer.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconrenderer.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconrenderer, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const iconrenderer_changes = {};
      if (dirty[0] & /*size*/
      2048)
        iconrenderer_changes.iconSize = fontSizes2[
          /*size*/
          ctx9[11]
        ] * 1.8;
      if (dirty[0] & /*fileIcon*/
      32768)
        iconrenderer_changes.icon = /*fileIcon*/
        ctx9[15];
      iconrenderer.$set(iconrenderer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconrenderer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconrenderer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconrenderer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_13.name,
    type: "fallback",
    source: "(118:26)       ",
    ctx: ctx8
  });
  return block;
}
function fallback_block11(ctx8) {
  let iconrenderer;
  let current;
  iconrenderer = new IconRenderer_default({
    props: {
      iconSize: fontSizes2[
        /*size*/
        ctx8[11]
      ] * 1.5,
      icon: (
        /*removeIcon*/
        ctx8[16]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(iconrenderer.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconrenderer.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconrenderer, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const iconrenderer_changes = {};
      if (dirty[0] & /*size*/
      2048)
        iconrenderer_changes.iconSize = fontSizes2[
          /*size*/
          ctx9[11]
        ] * 1.5;
      if (dirty[0] & /*removeIcon*/
      65536)
        iconrenderer_changes.icon = /*removeIcon*/
        ctx9[16];
      iconrenderer.$set(iconrenderer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconrenderer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconrenderer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconrenderer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block11.name,
    type: "fallback",
    source: "(128:30)         ",
    ctx: ctx8
  });
  return block;
}
function create_default_slot42(ctx8) {
  let current;
  const removeIcon_slot_template = (
    /*#slots*/
    ctx8[31].removeIcon
  );
  const removeIcon_slot = create_slot(
    removeIcon_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[39],
    get_removeIcon_slot_context
  );
  const removeIcon_slot_or_fallback = removeIcon_slot || fallback_block11(ctx8);
  const block = {
    c: function create() {
      if (removeIcon_slot_or_fallback)
        removeIcon_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (removeIcon_slot_or_fallback)
        removeIcon_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (removeIcon_slot_or_fallback) {
        removeIcon_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (removeIcon_slot) {
        if (removeIcon_slot.p && (!current || dirty[1] & /*$$scope*/
        256)) {
          update_slot_base(
            removeIcon_slot,
            removeIcon_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[39],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[39]
            ) : get_slot_changes(
              removeIcon_slot_template,
              /*$$scope*/
              ctx9[39],
              dirty,
              get_removeIcon_slot_changes
            ),
            get_removeIcon_slot_context
          );
        }
      } else {
        if (removeIcon_slot_or_fallback && removeIcon_slot_or_fallback.p && (!current || dirty[0] & /*size, removeIcon*/
        67584)) {
          removeIcon_slot_or_fallback.p(ctx9, !current ? [-1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(removeIcon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(removeIcon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (removeIcon_slot_or_fallback)
        removeIcon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot42.name,
    type: "slot",
    source: '(127:5) <Button variant=\\"default\\" {size} on:click={() => remove(i)}>',
    ctx: ctx8
  });
  return block;
}
function create_each_block3(ctx8) {
  let div1;
  let div0;
  let div0_class_value;
  let t0;
  let span0;
  let t1_value = (
    /*file*/
    ctx8[41].name + ""
  );
  let t1;
  let span0_class_value;
  let t2;
  let span2;
  let span1;
  let button;
  let span2_class_value;
  let t3;
  let div1_class_value;
  let current;
  const fileIcon_slot_template = (
    /*#slots*/
    ctx8[31].fileIcon
  );
  const fileIcon_slot = create_slot(
    fileIcon_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[39],
    get_fileIcon_slot_context
  );
  const fileIcon_slot_or_fallback = fileIcon_slot || fallback_block_13(ctx8);
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx8[38](
        /*i*/
        ctx8[43]
      )
    );
  }
  button = new Button_default({
    props: {
      variant: "default",
      size: (
        /*size*/
        ctx8[11]
      ),
      $$slots: { default: [create_default_slot42] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  button.$on("click", click_handler_1);
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (fileIcon_slot_or_fallback)
        fileIcon_slot_or_fallback.c();
      t0 = space();
      span0 = element("span");
      t1 = text(t1_value);
      t2 = space();
      span2 = element("span");
      span1 = element("span");
      create_component(button.$$.fragment);
      t3 = space();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (fileIcon_slot_or_fallback)
        fileIcon_slot_or_fallback.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div1_nodes);
      span0 = claim_element(div1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t1 = claim_text(span0_nodes, t1_value);
      span0_nodes.forEach(detach_dev);
      t2 = claim_space(div1_nodes);
      span2 = claim_element(div1_nodes, "SPAN", { class: true });
      var span2_nodes = children(span2);
      span1 = claim_element(span2_nodes, "SPAN", {});
      var span1_nodes = children(span1);
      claim_component(button.$$.fragment, span1_nodes);
      span1_nodes.forEach(detach_dev);
      span2_nodes.forEach(detach_dev);
      t3 = claim_space(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = /*classes*/
      ctx8[24].fileItemIcon);
      add_location(div0, file_1, 116, 3, 3266);
      attr_dev(span0, "class", span0_class_value = /*classes*/
      ctx8[24].fileItemName);
      add_location(span0, file_1, 121, 3, 3424);
      add_location(span1, file_1, 125, 4, 3532);
      attr_dev(span2, "class", span2_class_value = /*classes*/
      ctx8[24].fileItemAction);
      add_location(span2, file_1, 124, 3, 3490);
      attr_dev(div1, "class", div1_class_value = /*classes*/
      ctx8[24].fileItemWrapper);
      add_location(div1, file_1, 115, 2, 3225);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (fileIcon_slot_or_fallback) {
        fileIcon_slot_or_fallback.m(div0, null);
      }
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, span0);
      append_hydration_dev(span0, t1);
      append_hydration_dev(div1, t2);
      append_hydration_dev(div1, span2);
      append_hydration_dev(span2, span1);
      mount_component(button, span1, null);
      append_hydration_dev(div1, t3);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx8 = new_ctx;
      if (fileIcon_slot) {
        if (fileIcon_slot.p && (!current || dirty[1] & /*$$scope*/
        256)) {
          update_slot_base(
            fileIcon_slot,
            fileIcon_slot_template,
            ctx8,
            /*$$scope*/
            ctx8[39],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx8[39]
            ) : get_slot_changes(
              fileIcon_slot_template,
              /*$$scope*/
              ctx8[39],
              dirty,
              get_fileIcon_slot_changes
            ),
            get_fileIcon_slot_context
          );
        }
      } else {
        if (fileIcon_slot_or_fallback && fileIcon_slot_or_fallback.p && (!current || dirty[0] & /*size, fileIcon*/
        34816)) {
          fileIcon_slot_or_fallback.p(ctx8, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*classes*/
      16777216 && div0_class_value !== (div0_class_value = /*classes*/
      ctx8[24].fileItemIcon)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if ((!current || dirty[0] & /*files*/
      2) && t1_value !== (t1_value = /*file*/
      ctx8[41].name + ""))
        set_data_dev(t1, t1_value);
      if (!current || dirty[0] & /*classes*/
      16777216 && span0_class_value !== (span0_class_value = /*classes*/
      ctx8[24].fileItemName)) {
        attr_dev(span0, "class", span0_class_value);
      }
      const button_changes = {};
      if (dirty[0] & /*size*/
      2048)
        button_changes.size = /*size*/
        ctx8[11];
      if (dirty[0] & /*size, removeIcon*/
      67584 | dirty[1] & /*$$scope*/
      256) {
        button_changes.$$scope = { dirty, ctx: ctx8 };
      }
      button.$set(button_changes);
      if (!current || dirty[0] & /*classes*/
      16777216 && span2_class_value !== (span2_class_value = /*classes*/
      ctx8[24].fileItemAction)) {
        attr_dev(span2, "class", span2_class_value);
      }
      if (!current || dirty[0] & /*classes*/
      16777216 && div1_class_value !== (div1_class_value = /*classes*/
      ctx8[24].fileItemWrapper)) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(fileIcon_slot_or_fallback, local);
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(fileIcon_slot_or_fallback, local);
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (fileIcon_slot_or_fallback)
        fileIcon_slot_or_fallback.d(detaching);
      destroy_component(button);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(115:1) {#each files as { file }",
    ctx: ctx8
  });
  return block;
}
function create_fragment58(ctx8) {
  let box;
  let updating_element;
  let t;
  let if_block_anchor;
  let current;
  const box_spread_levels = [
    { use: (
      /*use*/
      ctx8[2]
    ) },
    {
      class: (
        /*cx*/
        ctx8[25](
          /*className*/
          ctx8[3],
          /*classes*/
          ctx8[24].root
        )
      )
    },
    /*$$restProps*/
    ctx8[30]
  ];
  function box_element_binding(value) {
    ctx8[37](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot_19] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  let if_block = (
    /*preview*/
    ctx8[21] && create_if_block21(ctx8)
  );
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
      t = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const box_changes = dirty[0] & /*use, cx, className, classes, $$restProps*/
      1124073484 ? get_spread_update(box_spread_levels, [
        dirty[0] & /*use*/
        4 && { use: (
          /*use*/
          ctx9[2]
        ) },
        dirty[0] & /*cx, className, classes*/
        50331656 && {
          class: (
            /*cx*/
            ctx9[25](
              /*className*/
              ctx9[3],
              /*classes*/
              ctx9[24].root
            )
          )
        },
        dirty[0] & /*$$restProps*/
        1073741824 && get_spread_object(
          /*$$restProps*/
          ctx9[30]
        )
      ]) : {};
      if (dirty[0] & /*id, cx, classes, getStyles, override, disabled, type, size, resetColor, files, resetLabel, resetIcon, reset, color, fileUploadComponent, label, icon, multiple, accept, name, use*/
      64913398 | dirty[1] & /*$$scope*/
      256) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty[0] & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
      if (
        /*preview*/
        ctx9[21]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
          if (dirty[0] & /*preview*/
          2097152) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block21(ctx9);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(if_block_anchor);
      }
      destroy_component(box, detaching);
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment58.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
var ctx2 = "Upload";
var dragover_handler = (ev) => {
  ev.preventDefault();
};
function instance58($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "accept",
    "type",
    "name",
    "multiple",
    "files",
    "label",
    "color",
    "size",
    "disabled",
    "id",
    "icon",
    "fileIcon",
    "removeIcon",
    "reset",
    "resetLabel",
    "resetColor",
    "resetIcon",
    "preview"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FileUpload", slots, ["default", "leftIcon", "fileIcon", "removeIcon"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, accept = void 0, type = void 0, name = void 0, multiple = false, files = [], label = "Upload", color = "blue", size: size3 = "sm", disabled = false, id = randomID(), icon = void 0, fileIcon = void 0, removeIcon = void 0, reset: reset2 = true, resetLabel = "Reset", resetColor = "red", resetIcon = void 0, preview = true } = $$props;
  let fileUploadComponent = void 0;
  const dispatch = createEventDispatcher();
  const forwardEvents = createEventForwarder(get_current_component(), ["selected", "removed", "reset"]);
  function onFileSelected(e) {
    let localFile = [];
    for (let i2 = 0; i2 < e.files.length; i2++) {
      let file48 = e.files[i2];
      localFile.push({
        name: file48.name,
        icon: file48.name,
        size: file48.size,
        file: file48
      });
    }
    if (multiple) {
      $$invalidate(1, files = [...files, ...localFile]);
    } else {
      $$invalidate(1, files = [...localFile]);
    }
    dispatch("selected", files);
  }
  function remove(index) {
    $$invalidate(22, fileUploadComponent.value = "", fileUploadComponent);
    dispatch("removed", { file: files[index], index });
    $$invalidate(1, files = files.filter((e, i2) => i2 !== index));
  }
  function resetFiles() {
    $$invalidate(22, fileUploadComponent.value = "", fileUploadComponent);
    $$invalidate(1, files = []);
    dispatch("reset");
  }
  function dragleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      fileUploadComponent = $$value;
      $$invalidate(22, fileUploadComponent);
    });
  }
  const change_handler = ({ target }) => {
    onFileSelected(target);
  };
  const drop_handler = ({ dataTransfer }) => {
    onFileSelected(dataTransfer);
  };
  const click_handler = () => {
    fileUploadComponent.click();
  };
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  const click_handler_1 = (i2) => remove(i2);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(30, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(4, override = $$new_props.override);
    if ("accept" in $$new_props)
      $$invalidate(5, accept = $$new_props.accept);
    if ("type" in $$new_props)
      $$invalidate(6, type = $$new_props.type);
    if ("name" in $$new_props)
      $$invalidate(7, name = $$new_props.name);
    if ("multiple" in $$new_props)
      $$invalidate(8, multiple = $$new_props.multiple);
    if ("files" in $$new_props)
      $$invalidate(1, files = $$new_props.files);
    if ("label" in $$new_props)
      $$invalidate(9, label = $$new_props.label);
    if ("color" in $$new_props)
      $$invalidate(10, color = $$new_props.color);
    if ("size" in $$new_props)
      $$invalidate(11, size3 = $$new_props.size);
    if ("disabled" in $$new_props)
      $$invalidate(12, disabled = $$new_props.disabled);
    if ("id" in $$new_props)
      $$invalidate(13, id = $$new_props.id);
    if ("icon" in $$new_props)
      $$invalidate(14, icon = $$new_props.icon);
    if ("fileIcon" in $$new_props)
      $$invalidate(15, fileIcon = $$new_props.fileIcon);
    if ("removeIcon" in $$new_props)
      $$invalidate(16, removeIcon = $$new_props.removeIcon);
    if ("reset" in $$new_props)
      $$invalidate(17, reset2 = $$new_props.reset);
    if ("resetLabel" in $$new_props)
      $$invalidate(18, resetLabel = $$new_props.resetLabel);
    if ("resetColor" in $$new_props)
      $$invalidate(19, resetColor = $$new_props.resetColor);
    if ("resetIcon" in $$new_props)
      $$invalidate(20, resetIcon = $$new_props.resetIcon);
    if ("preview" in $$new_props)
      $$invalidate(21, preview = $$new_props.preview);
    if ("$$scope" in $$new_props)
      $$invalidate(39, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    ctx: ctx2,
    useStyles: FileUpload_styles_default,
    fontSizes: fontSizes2,
    Box: Box_default,
    createEventForwarder,
    useActions,
    createEventDispatcher,
    get_current_component,
    randomID,
    IconRenderer: IconRenderer_default,
    Button: Button_default,
    use,
    element: element2,
    className,
    override,
    accept,
    type,
    name,
    multiple,
    files,
    label,
    color,
    size: size3,
    disabled,
    id,
    icon,
    fileIcon,
    removeIcon,
    reset: reset2,
    resetLabel,
    resetColor,
    resetIcon,
    preview,
    fileUploadComponent,
    dispatch,
    forwardEvents,
    onFileSelected,
    remove,
    resetFiles,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(4, override = $$new_props.override);
    if ("accept" in $$props)
      $$invalidate(5, accept = $$new_props.accept);
    if ("type" in $$props)
      $$invalidate(6, type = $$new_props.type);
    if ("name" in $$props)
      $$invalidate(7, name = $$new_props.name);
    if ("multiple" in $$props)
      $$invalidate(8, multiple = $$new_props.multiple);
    if ("files" in $$props)
      $$invalidate(1, files = $$new_props.files);
    if ("label" in $$props)
      $$invalidate(9, label = $$new_props.label);
    if ("color" in $$props)
      $$invalidate(10, color = $$new_props.color);
    if ("size" in $$props)
      $$invalidate(11, size3 = $$new_props.size);
    if ("disabled" in $$props)
      $$invalidate(12, disabled = $$new_props.disabled);
    if ("id" in $$props)
      $$invalidate(13, id = $$new_props.id);
    if ("icon" in $$props)
      $$invalidate(14, icon = $$new_props.icon);
    if ("fileIcon" in $$props)
      $$invalidate(15, fileIcon = $$new_props.fileIcon);
    if ("removeIcon" in $$props)
      $$invalidate(16, removeIcon = $$new_props.removeIcon);
    if ("reset" in $$props)
      $$invalidate(17, reset2 = $$new_props.reset);
    if ("resetLabel" in $$props)
      $$invalidate(18, resetLabel = $$new_props.resetLabel);
    if ("resetColor" in $$props)
      $$invalidate(19, resetColor = $$new_props.resetColor);
    if ("resetIcon" in $$props)
      $$invalidate(20, resetIcon = $$new_props.resetIcon);
    if ("preview" in $$props)
      $$invalidate(21, preview = $$new_props.preview);
    if ("fileUploadComponent" in $$props)
      $$invalidate(22, fileUploadComponent = $$new_props.fileUploadComponent);
    if ("getStyles" in $$props)
      $$invalidate(23, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(24, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(25, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*color, size*/
    3072) {
      $:
        $$invalidate(25, { cx: cx2, classes, getStyles } = FileUpload_styles_default({ color, size: size3 }, { name: "FileUpload" }), cx2, ($$invalidate(24, classes), $$invalidate(10, color), $$invalidate(11, size3)), ($$invalidate(23, getStyles), $$invalidate(10, color), $$invalidate(11, size3)));
    }
  };
  return [
    element2,
    files,
    use,
    className,
    override,
    accept,
    type,
    name,
    multiple,
    label,
    color,
    size3,
    disabled,
    id,
    icon,
    fileIcon,
    removeIcon,
    reset2,
    resetLabel,
    resetColor,
    resetIcon,
    preview,
    fileUploadComponent,
    getStyles,
    classes,
    cx2,
    forwardEvents,
    onFileSelected,
    remove,
    resetFiles,
    $$restProps,
    slots,
    dragleave_handler,
    input_binding,
    change_handler,
    drop_handler,
    click_handler,
    box_element_binding,
    click_handler_1,
    $$scope
  ];
}
var FileUpload = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance58,
      create_fragment58,
      safe_not_equal,
      {
        use: 2,
        element: 0,
        class: 3,
        override: 4,
        accept: 5,
        type: 6,
        name: 7,
        multiple: 8,
        files: 1,
        label: 9,
        color: 10,
        size: 11,
        disabled: 12,
        id: 13,
        icon: 14,
        fileIcon: 15,
        removeIcon: 16,
        reset: 17,
        resetLabel: 18,
        resetColor: 19,
        resetIcon: 20,
        preview: 21
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FileUpload",
      options,
      id: create_fragment58.name
    });
  }
  get use() {
    throw new Error("<FileUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<FileUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<FileUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<FileUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<FileUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FileUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<FileUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<FileUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accept() {
    throw new Error("<FileUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accept(value) {
    throw new Error("<FileUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<FileUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<FileUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<FileUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<FileUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiple() {
    throw new Error("<FileUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<FileUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get files() {
    throw new Error("<FileUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set files(value) {
    throw new Error("<FileUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<FileUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<FileUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<FileUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<FileUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<FileUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<FileUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<FileUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<FileUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<FileUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<FileUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<FileUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<FileUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fileIcon() {
    throw new Error("<FileUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fileIcon(value) {
    throw new Error("<FileUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get removeIcon() {
    throw new Error("<FileUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set removeIcon(value) {
    throw new Error("<FileUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get reset() {
    throw new Error("<FileUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set reset(value) {
    throw new Error("<FileUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resetLabel() {
    throw new Error("<FileUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resetLabel(value) {
    throw new Error("<FileUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resetColor() {
    throw new Error("<FileUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resetColor(value) {
    throw new Error("<FileUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resetIcon() {
    throw new Error("<FileUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resetIcon(value) {
    throw new Error("<FileUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get preview() {
    throw new Error("<FileUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set preview(value) {
    throw new Error("<FileUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FileUpload_default = FileUpload;

// node_modules/@svelteuidev/core/dist/components/Flex/Flex.styles.js
var Flex_styles_default = createStyles((theme4, { gap, rowGap, columnGap, align, justify, wrap, direction }) => {
  return {
    root: {
      boxSizing: "border-box",
      display: "flex",
      flexDirection: direction,
      alignItems: align,
      flexWrap: wrap,
      justifyContent: justify,
      gap: gap ? theme4.fn.size({ size: gap, sizes: theme4.space }) : void 0,
      rowGap: rowGap ? theme4.fn.size({ size: rowGap, sizes: theme4.space }) : void 0,
      columnGap: columnGap ? theme4.fn.size({ size: columnGap, sizes: theme4.space }) : void 0
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Flex/Flex.svelte
function create_default_slot43(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[17],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[17],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot43.name,
    type: "slot",
    source: "(32:0) <Box  bind:element  {use}  class={cx(className, classes.root, getStyles({ css: override }))}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment59(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { use: (
      /*use*/
      ctx8[1]
    ) },
    {
      class: (
        /*cx*/
        ctx8[6](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[5].root,
          /*getStyles*/
          ctx8[4]({ css: (
            /*override*/
            ctx8[3]
          ) })
        )
      )
    },
    /*$$restProps*/
    ctx8[7]
  ];
  function box_element_binding(value) {
    ctx8[16](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot43] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*use, cx, className, classes, getStyles, override, $$restProps*/
      254 ? get_spread_update(box_spread_levels, [
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*cx, className, classes, getStyles, override*/
        124 && {
          class: (
            /*cx*/
            ctx9[6](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[5].root,
              /*getStyles*/
              ctx9[4]({ css: (
                /*override*/
                ctx9[3]
              ) })
            )
          )
        },
        dirty & /*$$restProps*/
        128 && get_spread_object(
          /*$$restProps*/
          ctx9[7]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      131072) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment59.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance59($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "gap",
    "rowGap",
    "columnGap",
    "align",
    "justify",
    "wrap",
    "direction"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Flex", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, gap = void 0, rowGap = void 0, columnGap = void 0, align = void 0, justify = void 0, wrap = void 0, direction = void 0 } = $$props;
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("gap" in $$new_props)
      $$invalidate(8, gap = $$new_props.gap);
    if ("rowGap" in $$new_props)
      $$invalidate(9, rowGap = $$new_props.rowGap);
    if ("columnGap" in $$new_props)
      $$invalidate(10, columnGap = $$new_props.columnGap);
    if ("align" in $$new_props)
      $$invalidate(11, align = $$new_props.align);
    if ("justify" in $$new_props)
      $$invalidate(12, justify = $$new_props.justify);
    if ("wrap" in $$new_props)
      $$invalidate(13, wrap = $$new_props.wrap);
    if ("direction" in $$new_props)
      $$invalidate(14, direction = $$new_props.direction);
    if ("$$scope" in $$new_props)
      $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: Flex_styles_default,
    Box: Box_default,
    use,
    element: element2,
    className,
    override,
    gap,
    rowGap,
    columnGap,
    align,
    justify,
    wrap,
    direction,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("gap" in $$props)
      $$invalidate(8, gap = $$new_props.gap);
    if ("rowGap" in $$props)
      $$invalidate(9, rowGap = $$new_props.rowGap);
    if ("columnGap" in $$props)
      $$invalidate(10, columnGap = $$new_props.columnGap);
    if ("align" in $$props)
      $$invalidate(11, align = $$new_props.align);
    if ("justify" in $$props)
      $$invalidate(12, justify = $$new_props.justify);
    if ("wrap" in $$props)
      $$invalidate(13, wrap = $$new_props.wrap);
    if ("direction" in $$props)
      $$invalidate(14, direction = $$new_props.direction);
    if ("getStyles" in $$props)
      $$invalidate(4, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(5, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(6, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*gap, rowGap, columnGap, align, justify, wrap, direction*/
    32512) {
      $:
        $$invalidate(
          6,
          { cx: cx2, classes, getStyles } = Flex_styles_default(
            {
              gap,
              rowGap,
              columnGap,
              align,
              justify,
              wrap,
              direction
            },
            { name: "Flex" }
          ),
          cx2,
          ($$invalidate(5, classes), $$invalidate(8, gap), $$invalidate(9, rowGap), $$invalidate(10, columnGap), $$invalidate(11, align), $$invalidate(12, justify), $$invalidate(13, wrap), $$invalidate(14, direction)),
          ($$invalidate(4, getStyles), $$invalidate(8, gap), $$invalidate(9, rowGap), $$invalidate(10, columnGap), $$invalidate(11, align), $$invalidate(12, justify), $$invalidate(13, wrap), $$invalidate(14, direction))
        );
    }
  };
  return [
    element2,
    use,
    className,
    override,
    getStyles,
    classes,
    cx2,
    $$restProps,
    gap,
    rowGap,
    columnGap,
    align,
    justify,
    wrap,
    direction,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Flex = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance59, create_fragment59, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      gap: 8,
      rowGap: 9,
      columnGap: 10,
      align: 11,
      justify: 12,
      wrap: 13,
      direction: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Flex",
      options,
      id: create_fragment59.name
    });
  }
  get use() {
    throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gap() {
    throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gap(value) {
    throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rowGap() {
    throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rowGap(value) {
    throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get columnGap() {
    throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set columnGap(value) {
    throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get justify() {
    throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set justify(value) {
    throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrap() {
    throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrap(value) {
    throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<Flex>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<Flex>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Flex_default = Flex;

// node_modules/@svelteuidev/core/dist/components/Grid/Grid.styles.js
var Grid_styles_default = createStyles((theme4, { align, spacing, justify }) => {
  return {
    root: {
      display: "flex",
      flexWrap: "wrap",
      justifyContent: justify,
      alignItems: align,
      margin: -1 * theme4.fn.size({ size: spacing, sizes: theme4.space }) / 2
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Grid/Grid.svelte
function create_default_slot44(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[15],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[15],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot44.name,
    type: "slot",
    source: "(34:0) <Box bind:element {use} class={cx(className, classes.root)} {...$$restProps}>",
    ctx: ctx8
  });
  return block;
}
function create_fragment60(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { use: (
      /*use*/
      ctx8[1]
    ) },
    {
      class: (
        /*cx*/
        ctx8[4](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[3].root
        )
      )
    },
    /*$$restProps*/
    ctx8[6]
  ];
  function box_element_binding(value) {
    ctx8[14](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot44] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*use, cx, className, classes, $$restProps*/
      94 ? get_spread_update(box_spread_levels, [
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*cx, className, classes*/
        28 && {
          class: (
            /*cx*/
            ctx9[4](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[3].root
            )
          )
        },
        dirty & /*$$restProps*/
        64 && get_spread_object(
          /*$$restProps*/
          ctx9[6]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      32768) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment60.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
var ctx3 = "Grid";
function instance60($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  const omit_props_names = ["use", "element", "class", "override", "align", "cols", "grow", "spacing", "justify"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $contextStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Grid", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, align = "stretch", cols = 12, grow = false, spacing = "md", justify = "flex-start" } = $$props;
  const contextStore = writable({ cols, grow, spacing });
  validate_store(contextStore, "contextStore");
  component_subscribe($$self, contextStore, (value) => $$invalidate(16, $contextStore = value));
  setContext(ctx3, contextStore);
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(7, override = $$new_props.override);
    if ("align" in $$new_props)
      $$invalidate(8, align = $$new_props.align);
    if ("cols" in $$new_props)
      $$invalidate(9, cols = $$new_props.cols);
    if ("grow" in $$new_props)
      $$invalidate(10, grow = $$new_props.grow);
    if ("spacing" in $$new_props)
      $$invalidate(11, spacing = $$new_props.spacing);
    if ("justify" in $$new_props)
      $$invalidate(12, justify = $$new_props.justify);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    ctx: ctx3,
    setContext,
    writable,
    useStyles: Grid_styles_default,
    Box: Box_default,
    use,
    element: element2,
    className,
    override,
    align,
    cols,
    grow,
    spacing,
    justify,
    contextStore,
    classes,
    cx: cx2,
    $contextStore
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(7, override = $$new_props.override);
    if ("align" in $$props)
      $$invalidate(8, align = $$new_props.align);
    if ("cols" in $$props)
      $$invalidate(9, cols = $$new_props.cols);
    if ("grow" in $$props)
      $$invalidate(10, grow = $$new_props.grow);
    if ("spacing" in $$props)
      $$invalidate(11, spacing = $$new_props.spacing);
    if ("justify" in $$props)
      $$invalidate(12, justify = $$new_props.justify);
    if ("classes" in $$props)
      $$invalidate(3, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(4, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*cols, grow, spacing*/
    3584) {
      $:
        set_store_value(contextStore, $contextStore = { cols, grow, spacing }, $contextStore);
    }
    if ($$self.$$.dirty & /*align, spacing, justify, override*/
    6528) {
      $:
        $$invalidate(4, { cx: cx2, classes } = Grid_styles_default({ align, spacing, justify }, { override, name: "Grid" }), cx2, ($$invalidate(3, classes), $$invalidate(8, align), $$invalidate(11, spacing), $$invalidate(12, justify), $$invalidate(7, override)));
    }
  };
  return [
    element2,
    use,
    className,
    classes,
    cx2,
    contextStore,
    $$restProps,
    override,
    align,
    cols,
    grow,
    spacing,
    justify,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Grid = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance60, create_fragment60, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 7,
      align: 8,
      cols: 9,
      grow: 10,
      spacing: 11,
      justify: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Grid",
      options,
      id: create_fragment60.name
    });
  }
  get use() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cols() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cols(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get grow() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set grow(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get justify() {
    throw new Error("<Grid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set justify(value) {
    throw new Error("<Grid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Grid_default = Grid;

// node_modules/@svelteuidev/core/dist/components/Grid/Col/Col.styles.js
var SIZES = ["xs", "sm", "md", "lg", "xl"];
var columnWidth = (span, columns) => `${100 / (columns / span)}%`;
var columnOffset = (offset2, columns) => offset2 ? `${100 / (columns / offset2)}%` : void 0;
var breakpointsStyles = (sizes15, offsets, theme4, columns, grow) => {
  return SIZES.reduce((acc, size3) => {
    if (typeof sizes15[size3] === "number") {
      acc[`@media (min-width: ${parseInt(theme4.breakpoints[size3].value) + 1}px)`] = {
        flexBasis: columnWidth(sizes15[size3], columns),
        flexShrink: 0,
        maxWidth: grow ? "unset" : columnWidth(sizes15[size3], columns),
        marginLeft: columnOffset(offsets[size3], columns),
        padding: theme4.fn.size({ size: size3, sizes: theme4.space }) / 2
      };
    }
    return acc;
  }, {});
};
var Col_styles_default = createStyles((theme4, { cols, grow, spacing, span, offset: offset2, offsetXs, offsetSm, offsetMd, offsetLg, offsetXl, xs, sm, md, lg, xl }) => {
  return {
    root: {
      boxSizing: "border-box",
      flexGrow: grow ? 1 : 0,
      padding: theme4.fn.size({ size: spacing, sizes: theme4.space }) / 2,
      marginLeft: columnWidth(offset2, cols),
      flexBasis: columnWidth(span, cols),
      flexShrink: 0,
      maxWidth: grow ? "unset" : columnWidth(span, cols),
      ...breakpointsStyles({ xs, sm, md, lg, xl }, {
        xs: offsetXs,
        sm: offsetSm,
        md: offsetMd,
        lg: offsetLg,
        xl: offsetXl
      }, theme4, cols, grow)
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Grid/Col/Col.svelte
function create_if_block22(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { use: (
      /*use*/
      ctx8[1]
    ) },
    {
      class: (
        /*cx*/
        ctx8[6](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[5].root,
          /*getStyles*/
          ctx8[4]({ css: (
            /*override*/
            ctx8[3]
          ) })
        )
      )
    },
    /*$$restProps*/
    ctx8[9]
  ];
  function box_element_binding(value) {
    ctx8[28](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot45] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const box_changes = dirty & /*use, cx, className, classes, getStyles, override, $$restProps*/
      638 ? get_spread_update(box_spread_levels, [
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*cx, className, classes, getStyles, override*/
        124 && {
          class: (
            /*cx*/
            ctx9[6](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[5].root,
              /*getStyles*/
              ctx9[4]({ css: (
                /*override*/
                ctx9[3]
              ) })
            )
          )
        },
        dirty & /*$$restProps*/
        512 && get_spread_object(
          /*$$restProps*/
          ctx9[9]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      536870912) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block22.name,
    type: "if",
    source: "(34:0) {#if valid}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot45(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[27].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[29],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        536870912)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[29],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[29]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[29],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot45.name,
    type: "slot",
    source: "(35:1) <Box   bind:element   {use}   class={cx(className, classes.root, getStyles({ css: override }))}   {...$$restProps}  >",
    ctx: ctx8
  });
  return block;
}
function create_fragment61(ctx8) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*valid*/
    ctx8[7] && create_if_block22(ctx8)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      if (
        /*valid*/
        ctx9[7]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
          if (dirty & /*valid*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block22(ctx9);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment61.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function isSpanValid(span) {
  return typeof span === "number" && span > 0 && span % 1 === 0;
}
function instance61($$self, $$props, $$invalidate) {
  let cols;
  let grow;
  let spacing;
  let _span;
  let valid;
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "span",
    "offset",
    "offsetXs",
    "offsetSm",
    "offsetMd",
    "offsetLg",
    "offsetXl",
    "xs",
    "sm",
    "md",
    "lg",
    "xl"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $state;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Col", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, span = void 0, offset: offset2 = 0, offsetXs = 0, offsetSm = 0, offsetMd = 0, offsetLg = 0, offsetXl = 0, xs = void 0, sm = void 0, md = void 0, lg = void 0, xl = void 0 } = $$props;
  const state = getContext("Grid");
  validate_store(state, "state");
  component_subscribe($$self, state, (value) => $$invalidate(26, $state = value));
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("span" in $$new_props)
      $$invalidate(10, span = $$new_props.span);
    if ("offset" in $$new_props)
      $$invalidate(11, offset2 = $$new_props.offset);
    if ("offsetXs" in $$new_props)
      $$invalidate(12, offsetXs = $$new_props.offsetXs);
    if ("offsetSm" in $$new_props)
      $$invalidate(13, offsetSm = $$new_props.offsetSm);
    if ("offsetMd" in $$new_props)
      $$invalidate(14, offsetMd = $$new_props.offsetMd);
    if ("offsetLg" in $$new_props)
      $$invalidate(15, offsetLg = $$new_props.offsetLg);
    if ("offsetXl" in $$new_props)
      $$invalidate(16, offsetXl = $$new_props.offsetXl);
    if ("xs" in $$new_props)
      $$invalidate(17, xs = $$new_props.xs);
    if ("sm" in $$new_props)
      $$invalidate(18, sm = $$new_props.sm);
    if ("md" in $$new_props)
      $$invalidate(19, md = $$new_props.md);
    if ("lg" in $$new_props)
      $$invalidate(20, lg = $$new_props.lg);
    if ("xl" in $$new_props)
      $$invalidate(21, xl = $$new_props.xl);
    if ("$$scope" in $$new_props)
      $$invalidate(29, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    Box: Box_default,
    useStyles: Col_styles_default,
    use,
    element: element2,
    className,
    override,
    span,
    offset: offset2,
    offsetXs,
    offsetSm,
    offsetMd,
    offsetLg,
    offsetXl,
    xs,
    sm,
    md,
    lg,
    xl,
    state,
    isSpanValid,
    spacing,
    grow,
    cols,
    _span,
    getStyles,
    classes,
    cx: cx2,
    valid,
    $state
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("span" in $$props)
      $$invalidate(10, span = $$new_props.span);
    if ("offset" in $$props)
      $$invalidate(11, offset2 = $$new_props.offset);
    if ("offsetXs" in $$props)
      $$invalidate(12, offsetXs = $$new_props.offsetXs);
    if ("offsetSm" in $$props)
      $$invalidate(13, offsetSm = $$new_props.offsetSm);
    if ("offsetMd" in $$props)
      $$invalidate(14, offsetMd = $$new_props.offsetMd);
    if ("offsetLg" in $$props)
      $$invalidate(15, offsetLg = $$new_props.offsetLg);
    if ("offsetXl" in $$props)
      $$invalidate(16, offsetXl = $$new_props.offsetXl);
    if ("xs" in $$props)
      $$invalidate(17, xs = $$new_props.xs);
    if ("sm" in $$props)
      $$invalidate(18, sm = $$new_props.sm);
    if ("md" in $$props)
      $$invalidate(19, md = $$new_props.md);
    if ("lg" in $$props)
      $$invalidate(20, lg = $$new_props.lg);
    if ("xl" in $$props)
      $$invalidate(21, xl = $$new_props.xl);
    if ("spacing" in $$props)
      $$invalidate(22, spacing = $$new_props.spacing);
    if ("grow" in $$props)
      $$invalidate(23, grow = $$new_props.grow);
    if ("cols" in $$props)
      $$invalidate(24, cols = $$new_props.cols);
    if ("_span" in $$props)
      $$invalidate(25, _span = $$new_props._span);
    if ("getStyles" in $$props)
      $$invalidate(4, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(5, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(6, cx2 = $$new_props.cx);
    if ("valid" in $$props)
      $$invalidate(7, valid = $$new_props.valid);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$state*/
    67108864) {
      $:
        $$invalidate(24, { cols, grow, spacing } = $state, cols, ($$invalidate(23, grow), $$invalidate(26, $state)), ($$invalidate(22, spacing), $$invalidate(26, $state)));
    }
    if ($$self.$$.dirty & /*span, cols*/
    16778240) {
      $:
        $$invalidate(25, _span = span || cols || 0);
    }
    if ($$self.$$.dirty & /*_span, cols*/
    50331648) {
      $:
        $$invalidate(7, valid = isSpanValid(_span) && _span <= cols);
    }
    if ($$self.$$.dirty & /*_span, cols, grow, spacing, offset, offsetXs, offsetSm, offsetMd, offsetLg, offsetXl, xs, sm, md, lg, xl*/
    67106816) {
      $:
        $$invalidate(
          6,
          { cx: cx2, classes, getStyles } = Col_styles_default(
            {
              span: _span,
              cols,
              grow,
              spacing,
              offset: offset2,
              offsetXs,
              offsetSm,
              offsetMd,
              offsetLg,
              offsetXl,
              xs,
              sm,
              md,
              lg,
              xl
            },
            { name: "Col" }
          ),
          cx2,
          ($$invalidate(5, classes), $$invalidate(25, _span), $$invalidate(24, cols), $$invalidate(23, grow), $$invalidate(22, spacing), $$invalidate(11, offset2), $$invalidate(12, offsetXs), $$invalidate(13, offsetSm), $$invalidate(14, offsetMd), $$invalidate(15, offsetLg), $$invalidate(16, offsetXl), $$invalidate(17, xs), $$invalidate(18, sm), $$invalidate(19, md), $$invalidate(20, lg), $$invalidate(21, xl), $$invalidate(10, span), $$invalidate(26, $state)),
          ($$invalidate(4, getStyles), $$invalidate(25, _span), $$invalidate(24, cols), $$invalidate(23, grow), $$invalidate(22, spacing), $$invalidate(11, offset2), $$invalidate(12, offsetXs), $$invalidate(13, offsetSm), $$invalidate(14, offsetMd), $$invalidate(15, offsetLg), $$invalidate(16, offsetXl), $$invalidate(17, xs), $$invalidate(18, sm), $$invalidate(19, md), $$invalidate(20, lg), $$invalidate(21, xl), $$invalidate(10, span), $$invalidate(26, $state))
        );
    }
  };
  return [
    element2,
    use,
    className,
    override,
    getStyles,
    classes,
    cx2,
    valid,
    state,
    $$restProps,
    span,
    offset2,
    offsetXs,
    offsetSm,
    offsetMd,
    offsetLg,
    offsetXl,
    xs,
    sm,
    md,
    lg,
    xl,
    spacing,
    grow,
    cols,
    _span,
    $state,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Col = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance61, create_fragment61, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      span: 10,
      offset: 11,
      offsetXs: 12,
      offsetSm: 13,
      offsetMd: 14,
      offsetLg: 15,
      offsetXl: 16,
      xs: 17,
      sm: 18,
      md: 19,
      lg: 20,
      xl: 21
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Col",
      options,
      id: create_fragment61.name
    });
  }
  get use() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get span() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set span(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get offset() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set offset(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get offsetXs() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set offsetXs(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get offsetSm() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set offsetSm(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get offsetMd() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set offsetMd(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get offsetLg() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set offsetLg(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get offsetXl() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set offsetXl(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xs() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xs(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sm() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sm(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get md() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set md(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lg() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lg(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get xl() {
    throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set xl(value) {
    throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Col_default = Col;

// node_modules/@svelteuidev/core/dist/components/Grid/combinator.js
Grid_default.Col = Col_default;
var Grid2 = Grid_default;

// node_modules/@svelteuidev/core/dist/components/Skeleton/Skeleton.styles.js
var fade2 = keyframes({
  "from, to": { opacity: 0.4 },
  "50%": { opacity: 1 }
});
var Skeleton_styles_default = createStyles((theme4, { animate, circle, height, radius: radius2, width }) => {
  return {
    root: {
      [`${theme4.dark} &`]: {
        "&.visible": {
          "&::before": {
            background: theme4.fn.themeColor("dark", 7)
          },
          "&::after": {
            background: theme4.fn.themeColor("dark", 4)
          }
        }
      },
      height,
      width: circle ? height : `${width}%`,
      borderRadius: circle ? height : `$${radius2}`,
      position: "relative",
      overflow: "hidden",
      "&.visible": {
        "&::before": {
          content: '""',
          position: "absolute",
          background: "white",
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
          zIndex: 10
        },
        "&::after": {
          content: '""',
          position: "absolute",
          background: theme4.fn.themeColor("gray", 3),
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
          animation: animate ? `${fade2} 1500ms linear infinite` : "none",
          zIndex: 11
        }
      }
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Skeleton/Skeleton.svelte
function create_default_slot46(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[14].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[16],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[16],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot46.name,
    type: "slot",
    source: "(8:0) <Box  bind:element  class={cx(className, classes.root, { visible }, getStyles({ css: override }))}  {use}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment62(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    {
      class: (
        /*cx*/
        ctx8[7](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[6].root,
          { visible: (
            /*visible*/
            ctx8[4]
          ) },
          /*getStyles*/
          ctx8[5]({ css: (
            /*override*/
            ctx8[3]
          ) })
        )
      )
    },
    { use: (
      /*use*/
      ctx8[1]
    ) },
    /*$$restProps*/
    ctx8[8]
  ];
  function box_element_binding(value) {
    ctx8[15](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot46] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*cx, className, classes, visible, getStyles, override, use, $$restProps*/
      510 ? get_spread_update(box_spread_levels, [
        dirty & /*cx, className, classes, visible, getStyles, override*/
        252 && {
          class: (
            /*cx*/
            ctx9[7](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[6].root,
              { visible: (
                /*visible*/
                ctx9[4]
              ) },
              /*getStyles*/
              ctx9[5]({ css: (
                /*override*/
                ctx9[3]
              ) })
            )
          )
        },
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*$$restProps*/
        256 && get_spread_object(
          /*$$restProps*/
          ctx9[8]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      65536) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment62.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance62($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "visible",
    "height",
    "width",
    "circle",
    "radius",
    "animate"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Skeleton", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, visible: visible2 = true, height = "auto", width = 100, circle = null, radius: radius2 = null, animate = true } = $$props;
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("visible" in $$new_props)
      $$invalidate(4, visible2 = $$new_props.visible);
    if ("height" in $$new_props)
      $$invalidate(9, height = $$new_props.height);
    if ("width" in $$new_props)
      $$invalidate(10, width = $$new_props.width);
    if ("circle" in $$new_props)
      $$invalidate(11, circle = $$new_props.circle);
    if ("radius" in $$new_props)
      $$invalidate(12, radius2 = $$new_props.radius);
    if ("animate" in $$new_props)
      $$invalidate(13, animate = $$new_props.animate);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Box: Box_default,
    useStyles: Skeleton_styles_default,
    use,
    element: element2,
    className,
    override,
    visible: visible2,
    height,
    width,
    circle,
    radius: radius2,
    animate,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("visible" in $$props)
      $$invalidate(4, visible2 = $$new_props.visible);
    if ("height" in $$props)
      $$invalidate(9, height = $$new_props.height);
    if ("width" in $$props)
      $$invalidate(10, width = $$new_props.width);
    if ("circle" in $$props)
      $$invalidate(11, circle = $$new_props.circle);
    if ("radius" in $$props)
      $$invalidate(12, radius2 = $$new_props.radius);
    if ("animate" in $$props)
      $$invalidate(13, animate = $$new_props.animate);
    if ("getStyles" in $$props)
      $$invalidate(5, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(6, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(7, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*animate, circle, height, radius, width*/
    15872) {
      $:
        $$invalidate(7, { cx: cx2, classes, getStyles } = Skeleton_styles_default({ animate, circle, height, radius: radius2, width }, { name: "Skeleton" }), cx2, ($$invalidate(6, classes), $$invalidate(13, animate), $$invalidate(11, circle), $$invalidate(9, height), $$invalidate(12, radius2), $$invalidate(10, width)), ($$invalidate(5, getStyles), $$invalidate(13, animate), $$invalidate(11, circle), $$invalidate(9, height), $$invalidate(12, radius2), $$invalidate(10, width)));
    }
  };
  return [
    element2,
    use,
    className,
    override,
    visible2,
    getStyles,
    classes,
    cx2,
    $$restProps,
    height,
    width,
    circle,
    radius2,
    animate,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Skeleton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance62, create_fragment62, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      visible: 4,
      height: 9,
      width: 10,
      circle: 11,
      radius: 12,
      animate: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Skeleton",
      options,
      id: create_fragment62.name
    });
  }
  get use() {
    throw new Error("<Skeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Skeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Skeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Skeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Skeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Skeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Skeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Skeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<Skeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<Skeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Skeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Skeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Skeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Skeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get circle() {
    throw new Error("<Skeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set circle(value) {
    throw new Error("<Skeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<Skeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<Skeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animate() {
    throw new Error("<Skeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animate(value) {
    throw new Error("<Skeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Skeleton_default = Skeleton;

// node_modules/@svelteuidev/core/dist/components/Image/Image.styles.js
var Image_styles_default = createStyles((theme4, { radius: radius2, height, width, fit }) => {
  return {
    root: {
      fontFamily: theme4.fonts.standard.value ?? "sans-serif"
    },
    imageWrapper: {
      position: "relative"
    },
    figure: {
      margin: 0
    },
    image: {
      width,
      height,
      display: "block",
      border: 0,
      borderRadius: theme4.fn.radius(radius2),
      objectFit: fit
    },
    caption: {
      [`${theme4.dark} &`]: {
        color: theme4.fn.themeColor("dark", 2)
      },
      color: theme4.fn.themeColor("gray", 7),
      marginTop: theme4.space.xsPX.value
    },
    placeholder: {
      [`${theme4.dark} &`]: {
        color: theme4.fn.themeColor("dark", 2),
        backgroundColor: theme4.fn.themeColor("dark", 8)
      },
      width,
      height,
      position: "absolute",
      top: 0,
      right: 0,
      left: 0,
      bottom: 0,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      color: theme4.fn.themeColor("gray", 6),
      backgroundColor: theme4.fn.themeColor("gray", 0),
      borderRadius: theme4.fn.radius(radius2)
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Image/ImageIcon.svelte
var file27 = "node_modules/@svelteuidev/core/dist/components/Image/ImageIcon.svelte";
function create_fragment63(ctx8) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        fill: true,
        xmlns: true,
        style: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", {
        d: true,
        fill: true,
        "fill-rule": true,
        "clip-rule": true
      });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M2.5 1H12.5C13.3284 1 14 1.67157 14 2.5V12.5C14 13.3284 13.3284 14 12.5 14H2.5C1.67157 14 1 13.3284 1 12.5V2.5C1 1.67157 1.67157 1 2.5 1ZM2.5 2C2.22386 2 2 2.22386 2 2.5V8.3636L3.6818 6.6818C3.76809 6.59551 3.88572 6.54797 4.00774 6.55007C4.12975 6.55216 4.24568 6.60372 4.32895 6.69293L7.87355 10.4901L10.6818 7.6818C10.8575 7.50607 11.1425 7.50607 11.3182 7.6818L13 9.3636V2.5C13 2.22386 12.7761 2 12.5 2H2.5ZM2 12.5V9.6364L3.98887 7.64753L7.5311 11.4421L8.94113 13H2.5C2.22386 13 2 12.7761 2 12.5ZM12.5 13H10.155L8.48336 11.153L11 8.6364L13 10.6364V12.5C13 12.7761 12.7761 13 12.5 13ZM6.64922 5.5C6.64922 5.03013 7.03013 4.64922 7.5 4.64922C7.96987 4.64922 8.35078 5.03013 8.35078 5.5C8.35078 5.96987 7.96987 6.35078 7.5 6.35078C7.03013 6.35078 6.64922 5.96987 6.64922 5.5ZM7.5 3.74922C6.53307 3.74922 5.74922 4.53307 5.74922 5.5C5.74922 6.46693 6.53307 7.25078 7.5 7.25078C8.46693 7.25078 9.25078 6.46693 9.25078 5.5C9.25078 4.53307 8.46693 3.74922 7.5 3.74922Z");
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "clip-rule", "evenodd");
      add_location(path, file27, 11, 1, 200);
      attr_dev(svg, "width", "15");
      attr_dev(svg, "height", "15");
      attr_dev(svg, "viewBox", "0 0 15 15");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      set_style(
        svg,
        "width",
        /*style*/
        ctx8[0].width
      );
      set_style(
        svg,
        "height",
        /*style*/
        ctx8[0].height
      );
      add_location(svg, file27, 3, 0, 42);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx9, [dirty]) {
      if (dirty & /*style*/
      1) {
        set_style(
          svg,
          "width",
          /*style*/
          ctx9[0].width
        );
      }
      if (dirty & /*style*/
      1) {
        set_style(
          svg,
          "height",
          /*style*/
          ctx9[0].height
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment63.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance63($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ImageIcon", slots, []);
  let { style: style2 = {} } = $$props;
  const writable_props = ["style"];
  Object.keys($$props).forEach((key3) => {
    if (!~writable_props.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<ImageIcon> was created with unknown prop '${key3}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("style" in $$props2)
      $$invalidate(0, style2 = $$props2.style);
  };
  $$self.$capture_state = () => ({ style: style2 });
  $$self.$inject_state = ($$props2) => {
    if ("style" in $$props2)
      $$invalidate(0, style2 = $$props2.style);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [style2];
}
var ImageIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance63, create_fragment63, safe_not_equal, { style: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ImageIcon",
      options,
      id: create_fragment63.name
    });
  }
  get style() {
    throw new Error("<ImageIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<ImageIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ImageIcon_default = ImageIcon;

// node_modules/@svelteuidev/core/dist/components/Image/Image.svelte
var file28 = "node_modules/@svelteuidev/core/dist/components/Image/Image.svelte";
var get_placeholder_slot_changes = (dirty) => ({});
var get_placeholder_slot_context = (ctx8) => ({});
function create_default_slot_24(ctx8) {
  let img;
  let img_class_value;
  let img_src_value;
  let useActions_action;
  let forwardEvents_action;
  let mounted;
  let dispose;
  let img_levels = [
    {
      class: img_class_value = /*classes*/
      ctx8[11].image
    },
    { src: img_src_value = /*src*/
    ctx8[4] },
    { alt: (
      /*alt*/
      ctx8[5]
    ) },
    /*$$restProps*/
    ctx8[16]
  ];
  let img_data = {};
  for (let i2 = 0; i2 < img_levels.length; i2 += 1) {
    img_data = assign(img_data, img_levels[i2]);
  }
  const block = {
    c: function create() {
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      img = claim_element(nodes, "IMG", { class: true, src: true, alt: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(img, img_data);
      add_location(img, file28, 37, 4, 1684);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, img, anchor);
      ctx8[24](img);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            img,
            /*use*/
            ctx8[1]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx8[13].call(null, img)),
          listen_dev(
            img,
            "load",
            /*onLoad*/
            ctx8[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            img,
            "error",
            /*onError*/
            ctx8[15],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx9, dirty) {
      set_attributes(img, img_data = get_spread_update(img_levels, [
        dirty & /*classes*/
        2048 && img_class_value !== (img_class_value = /*classes*/
        ctx9[11].image) && { class: img_class_value },
        dirty & /*src*/
        16 && !src_url_equal(img.src, img_src_value = /*src*/
        ctx9[4]) && { src: img_src_value },
        dirty & /*alt*/
        32 && { alt: (
          /*alt*/
          ctx9[5]
        ) },
        dirty & /*$$restProps*/
        65536 && /*$$restProps*/
        ctx9[16]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      2)
        useActions_action.update.call(
          null,
          /*use*/
          ctx9[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(img);
      }
      ctx8[24](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_24.name,
    type: "slot",
    source: "(37:3) <Skeleton visible={loader ? loaded : false}>",
    ctx: ctx8
  });
  return block;
}
function create_if_block_113(ctx8) {
  let div;
  let div_class_value;
  let current;
  const placeholder_slot_template = (
    /*#slots*/
    ctx8[23].placeholder
  );
  const placeholder_slot = create_slot(
    placeholder_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[25],
    get_placeholder_slot_context
  );
  const placeholder_slot_or_fallback = placeholder_slot || fallback_block12(ctx8);
  const block = {
    c: function create() {
      div = element("div");
      if (placeholder_slot_or_fallback)
        placeholder_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, title: true });
      var div_nodes = children(div);
      if (placeholder_slot_or_fallback)
        placeholder_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*classes*/
      ctx8[11].placeholder);
      attr_dev(
        div,
        "title",
        /*alt*/
        ctx8[5]
      );
      add_location(div, file28, 50, 4, 1931);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (placeholder_slot_or_fallback) {
        placeholder_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (placeholder_slot) {
        if (placeholder_slot.p && (!current || dirty & /*$$scope*/
        33554432)) {
          update_slot_base(
            placeholder_slot,
            placeholder_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[25]
            ) : get_slot_changes(
              placeholder_slot_template,
              /*$$scope*/
              ctx9[25],
              dirty,
              get_placeholder_slot_changes
            ),
            get_placeholder_slot_context
          );
        }
      }
      if (!current || dirty & /*classes*/
      2048 && div_class_value !== (div_class_value = /*classes*/
      ctx9[11].placeholder)) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & /*alt*/
      32) {
        attr_dev(
          div,
          "title",
          /*alt*/
          ctx9[5]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(placeholder_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(placeholder_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (placeholder_slot_or_fallback)
        placeholder_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_113.name,
    type: "if",
    source: "(50:3) {#if showPlaceholder}",
    ctx: ctx8
  });
  return block;
}
function fallback_block12(ctx8) {
  let imageicon;
  let current;
  imageicon = new ImageIcon_default({
    props: { style: { width: 40, height: 40 } },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(imageicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(imageicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(imageicon, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(imageicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(imageicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(imageicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block12.name,
    type: "fallback",
    source: "(52:30)        ",
    ctx: ctx8
  });
  return block;
}
function create_if_block23(ctx8) {
  let text_1;
  let current;
  text_1 = new Text_default({
    props: {
      class: (
        /*classes*/
        ctx8[11].caption
      ),
      root: "figcaption",
      size: "sm",
      align: "center",
      $$slots: { default: [create_default_slot_110] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(text_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(text_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(text_1, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const text_1_changes = {};
      if (dirty & /*classes*/
      2048)
        text_1_changes.class = /*classes*/
        ctx9[11].caption;
      if (dirty & /*$$scope, caption*/
      33554496) {
        text_1_changes.$$scope = { dirty, ctx: ctx9 };
      }
      text_1.$set(text_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(text_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block23.name,
    type: "if",
    source: "(58:2) {#if caption}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_110(ctx8) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*caption*/
        ctx8[6]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*caption*/
        ctx8[6]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*caption*/
      64)
        set_data_dev(
          t,
          /*caption*/
          ctx9[6]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_110.name,
    type: "slot",
    source: '(59:3) <Text class={classes.caption} root=\\"figcaption\\" size=\\"sm\\" align=\\"center\\">',
    ctx: ctx8
  });
  return block;
}
function create_default_slot47(ctx8) {
  let figure;
  let div;
  let skeleton;
  let t0;
  let div_class_value;
  let t1;
  let figure_class_value;
  let current;
  skeleton = new Skeleton_default({
    props: {
      visible: (
        /*loader*/
        ctx8[7] ? (
          /*loaded*/
          ctx8[8]
        ) : false
      ),
      $$slots: { default: [create_default_slot_24] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  let if_block0 = (
    /*showPlaceholder*/
    ctx8[9] && create_if_block_113(ctx8)
  );
  let if_block1 = (
    /*caption*/
    ctx8[6] && create_if_block23(ctx8)
  );
  const block = {
    c: function create() {
      figure = element("figure");
      div = element("div");
      create_component(skeleton.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      figure = claim_element(nodes, "FIGURE", { class: true });
      var figure_nodes = children(figure);
      div = claim_element(figure_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(skeleton.$$.fragment, div_nodes);
      t0 = claim_space(div_nodes);
      if (if_block0)
        if_block0.l(div_nodes);
      div_nodes.forEach(detach_dev);
      t1 = claim_space(figure_nodes);
      if (if_block1)
        if_block1.l(figure_nodes);
      figure_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*classes*/
      ctx8[11].imageWrapper);
      add_location(div, file28, 35, 2, 1597);
      attr_dev(figure, "class", figure_class_value = /*classes*/
      ctx8[11].figure);
      add_location(figure, file28, 34, 1, 1563);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, figure, anchor);
      append_hydration_dev(figure, div);
      mount_component(skeleton, div, null);
      append_hydration_dev(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration_dev(figure, t1);
      if (if_block1)
        if_block1.m(figure, null);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const skeleton_changes = {};
      if (dirty & /*loader, loaded*/
      384)
        skeleton_changes.visible = /*loader*/
        ctx9[7] ? (
          /*loaded*/
          ctx9[8]
        ) : false;
      if (dirty & /*$$scope, classes, src, alt, $$restProps, element, use*/
      33622067) {
        skeleton_changes.$$scope = { dirty, ctx: ctx9 };
      }
      skeleton.$set(skeleton_changes);
      if (
        /*showPlaceholder*/
        ctx9[9]
      ) {
        if (if_block0) {
          if_block0.p(ctx9, dirty);
          if (dirty & /*showPlaceholder*/
          512) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_113(ctx9);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*classes*/
      2048 && div_class_value !== (div_class_value = /*classes*/
      ctx9[11].imageWrapper)) {
        attr_dev(div, "class", div_class_value);
      }
      if (
        /*caption*/
        ctx9[6]
      ) {
        if (if_block1) {
          if_block1.p(ctx9, dirty);
          if (dirty & /*caption*/
          64) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block23(ctx9);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(figure, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*classes*/
      2048 && figure_class_value !== (figure_class_value = /*classes*/
      ctx9[11].figure)) {
        attr_dev(figure, "class", figure_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(skeleton.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(skeleton.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(figure);
      }
      destroy_component(skeleton);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot47.name,
    type: "slot",
    source: "(34:0) <Box class={cx(className, classes.root, getStyles({ css: override }))}>",
    ctx: ctx8
  });
  return block;
}
function create_fragment64(ctx8) {
  let box;
  let current;
  box = new Box_default({
    props: {
      class: (
        /*cx*/
        ctx8[12](
          /*className*/
          ctx8[3],
          /*classes*/
          ctx8[11].root,
          /*getStyles*/
          ctx8[10]({ css: (
            /*override*/
            ctx8[2]
          ) })
        )
      ),
      $$slots: { default: [create_default_slot47] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = {};
      if (dirty & /*cx, className, classes, getStyles, override*/
      7180)
        box_changes.class = /*cx*/
        ctx9[12](
          /*className*/
          ctx9[3],
          /*classes*/
          ctx9[11].root,
          /*getStyles*/
          ctx9[10]({ css: (
            /*override*/
            ctx9[2]
          ) })
        );
      if (dirty & /*$$scope, classes, caption, alt, showPlaceholder, loader, loaded, src, $$restProps, element, use*/
      33623027) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment64.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance64($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = [
    "use",
    "element",
    "override",
    "radius",
    "class",
    "src",
    "alt",
    "fit",
    "width",
    "height",
    "caption",
    "usePlaceholder",
    "loader"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Image", slots, ["placeholder"]);
  let { use = [], element: element2 = void 0, override = {}, radius: radius2 = 0, class: className = "", src = void 0, alt = "", fit = "cover", width = "100%", height = "auto", caption = void 0, usePlaceholder = false, loader = false } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  let loaded = false;
  let error = false;
  let showPlaceholder = false;
  const onLoad = () => $$invalidate(8, loaded = true);
  const onError = () => $$invalidate(22, error = true);
  function img_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("override" in $$new_props)
      $$invalidate(2, override = $$new_props.override);
    if ("radius" in $$new_props)
      $$invalidate(17, radius2 = $$new_props.radius);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("src" in $$new_props)
      $$invalidate(4, src = $$new_props.src);
    if ("alt" in $$new_props)
      $$invalidate(5, alt = $$new_props.alt);
    if ("fit" in $$new_props)
      $$invalidate(18, fit = $$new_props.fit);
    if ("width" in $$new_props)
      $$invalidate(19, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(20, height = $$new_props.height);
    if ("caption" in $$new_props)
      $$invalidate(6, caption = $$new_props.caption);
    if ("usePlaceholder" in $$new_props)
      $$invalidate(21, usePlaceholder = $$new_props.usePlaceholder);
    if ("loader" in $$new_props)
      $$invalidate(7, loader = $$new_props.loader);
    if ("$$scope" in $$new_props)
      $$invalidate(25, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    get_current_component,
    createEventForwarder,
    useActions,
    Box: Box_default,
    Skeleton: Skeleton_default,
    Text: Text_default,
    useStyles: Image_styles_default,
    ImageIcon: ImageIcon_default,
    use,
    element: element2,
    override,
    radius: radius2,
    className,
    src,
    alt,
    fit,
    width,
    height,
    caption,
    usePlaceholder,
    loader,
    forwardEvents,
    loaded,
    error,
    showPlaceholder,
    onLoad,
    onError,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("override" in $$props)
      $$invalidate(2, override = $$new_props.override);
    if ("radius" in $$props)
      $$invalidate(17, radius2 = $$new_props.radius);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("src" in $$props)
      $$invalidate(4, src = $$new_props.src);
    if ("alt" in $$props)
      $$invalidate(5, alt = $$new_props.alt);
    if ("fit" in $$props)
      $$invalidate(18, fit = $$new_props.fit);
    if ("width" in $$props)
      $$invalidate(19, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(20, height = $$new_props.height);
    if ("caption" in $$props)
      $$invalidate(6, caption = $$new_props.caption);
    if ("usePlaceholder" in $$props)
      $$invalidate(21, usePlaceholder = $$new_props.usePlaceholder);
    if ("loader" in $$props)
      $$invalidate(7, loader = $$new_props.loader);
    if ("loaded" in $$props)
      $$invalidate(8, loaded = $$new_props.loaded);
    if ("error" in $$props)
      $$invalidate(22, error = $$new_props.error);
    if ("showPlaceholder" in $$props)
      $$invalidate(9, showPlaceholder = $$new_props.showPlaceholder);
    if ("getStyles" in $$props)
      $$invalidate(10, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(11, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(12, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*usePlaceholder, loaded, error*/
    6291712) {
      $:
        $$invalidate(9, showPlaceholder = usePlaceholder && (!loaded || error));
    }
    if ($$self.$$.dirty & /*radius, fit, height, width*/
    1966080) {
      $:
        $$invalidate(12, { cx: cx2, classes, getStyles } = Image_styles_default({ radius: radius2, fit, height, width }, { name: "Image" }), cx2, ($$invalidate(11, classes), $$invalidate(17, radius2), $$invalidate(18, fit), $$invalidate(20, height), $$invalidate(19, width)), ($$invalidate(10, getStyles), $$invalidate(17, radius2), $$invalidate(18, fit), $$invalidate(20, height), $$invalidate(19, width)));
    }
  };
  return [
    element2,
    use,
    override,
    className,
    src,
    alt,
    caption,
    loader,
    loaded,
    showPlaceholder,
    getStyles,
    classes,
    cx2,
    forwardEvents,
    onLoad,
    onError,
    $$restProps,
    radius2,
    fit,
    width,
    height,
    usePlaceholder,
    error,
    slots,
    img_binding,
    $$scope
  ];
}
var Image = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance64, create_fragment64, safe_not_equal, {
      use: 1,
      element: 0,
      override: 2,
      radius: 17,
      class: 3,
      src: 4,
      alt: 5,
      fit: 18,
      width: 19,
      height: 20,
      caption: 6,
      usePlaceholder: 21,
      loader: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Image",
      options,
      id: create_fragment64.name
    });
  }
  get use() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get src() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alt() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fit() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fit(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caption() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caption(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get usePlaceholder() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set usePlaceholder(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loader() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loader(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Image_default = Image;

// node_modules/@svelteuidev/core/dist/components/Image/BackgroundImage/BackgroundImage.styles.js
var BackgroundImage_styles_default = createStyles((_, { height, width, radius: radius2, src }) => {
  return {
    root: {
      focusRing: "auto",
      backgroundSize: "cover",
      backgroundPosition: "center",
      display: "block",
      width: width !== void 0 ? `${width}%` : "auto",
      height: height !== void 0 ? `${height}%` : "auto",
      border: 0,
      textDecoration: "none",
      color: "White",
      backgroundImage: `url(${src})`,
      borderRadius: typeof radius2 === "string" ? `$${radius2}` : radius2,
      padding: "16px"
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Image/BackgroundImage/BackgroundImage.svelte
var file29 = "node_modules/@svelteuidev/core/dist/components/Image/BackgroundImage/BackgroundImage.svelte";
function fallback_block13(ctx8) {
  let t;
  const block = {
    c: function create() {
      t = text("Text");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Text");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block13.name,
    type: "fallback",
    source: "(37:7) Text",
    ctx: ctx8
  });
  return block;
}
function create_fragment65(ctx8) {
  let div;
  let div_class_value;
  let forwardEvents_action;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx8[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[12],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block13(ctx8);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*cx*/
      ctx8[6](
        /*className*/
        ctx8[2],
        /*classes*/
        ctx8[5].root,
        /*getStyles*/
        ctx8[4]({ css: (
          /*override*/
          ctx8[3]
        ) })
      ));
      add_location(div, file29, 30, 0, 1193);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(div, null);
      }
      ctx8[14](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx8[7].call(null, div)),
          action_destroyer(useActions_action = useActions.call(
            null,
            div,
            /*use*/
            ctx8[1]
          ))
        ];
        mounted = true;
      }
    },
    p: function update(ctx9, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[12],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*cx, className, classes, getStyles, override*/
      124 && div_class_value !== (div_class_value = /*cx*/
      ctx9[6](
        /*className*/
        ctx9[2],
        /*classes*/
        ctx9[5].root,
        /*getStyles*/
        ctx9[4]({ css: (
          /*override*/
          ctx9[3]
        ) })
      ))) {
        attr_dev(div, "class", div_class_value);
      }
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      2)
        useActions_action.update.call(
          null,
          /*use*/
          ctx9[1]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      ctx8[14](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment65.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance65($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BackgroundImage", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, radius: radius2 = 0, src = "", width = void 0, height = void 0 } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  const writable_props = ["use", "element", "class", "override", "radius", "src", "width", "height"];
  Object.keys($$props).forEach((key3) => {
    if (!~writable_props.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<BackgroundImage> was created with unknown prop '${key3}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("use" in $$props2)
      $$invalidate(1, use = $$props2.use);
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("class" in $$props2)
      $$invalidate(2, className = $$props2.class);
    if ("override" in $$props2)
      $$invalidate(3, override = $$props2.override);
    if ("radius" in $$props2)
      $$invalidate(8, radius2 = $$props2.radius);
    if ("src" in $$props2)
      $$invalidate(9, src = $$props2.src);
    if ("width" in $$props2)
      $$invalidate(10, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(11, height = $$props2.height);
    if ("$$scope" in $$props2)
      $$invalidate(12, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: BackgroundImage_styles_default,
    createEventForwarder,
    useActions,
    get_current_component,
    use,
    element: element2,
    className,
    override,
    radius: radius2,
    src,
    width,
    height,
    forwardEvents,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$props2) => {
    if ("use" in $$props2)
      $$invalidate(1, use = $$props2.use);
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("className" in $$props2)
      $$invalidate(2, className = $$props2.className);
    if ("override" in $$props2)
      $$invalidate(3, override = $$props2.override);
    if ("radius" in $$props2)
      $$invalidate(8, radius2 = $$props2.radius);
    if ("src" in $$props2)
      $$invalidate(9, src = $$props2.src);
    if ("width" in $$props2)
      $$invalidate(10, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(11, height = $$props2.height);
    if ("getStyles" in $$props2)
      $$invalidate(4, getStyles = $$props2.getStyles);
    if ("classes" in $$props2)
      $$invalidate(5, classes = $$props2.classes);
    if ("cx" in $$props2)
      $$invalidate(6, cx2 = $$props2.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*height, radius, src, width*/
    3840) {
      $:
        $$invalidate(6, { cx: cx2, classes, getStyles } = BackgroundImage_styles_default({ height, radius: radius2, src, width }, { name: "BackgroundImage" }), cx2, ($$invalidate(5, classes), $$invalidate(11, height), $$invalidate(8, radius2), $$invalidate(9, src), $$invalidate(10, width)), ($$invalidate(4, getStyles), $$invalidate(11, height), $$invalidate(8, radius2), $$invalidate(9, src), $$invalidate(10, width)));
    }
  };
  return [
    element2,
    use,
    className,
    override,
    getStyles,
    classes,
    cx2,
    forwardEvents,
    radius2,
    src,
    width,
    height,
    $$scope,
    slots,
    div_binding
  ];
}
var BackgroundImage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance65, create_fragment65, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      radius: 8,
      src: 9,
      width: 10,
      height: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BackgroundImage",
      options,
      id: create_fragment65.name
    });
  }
  get use() {
    throw new Error("<BackgroundImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<BackgroundImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<BackgroundImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<BackgroundImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<BackgroundImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<BackgroundImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<BackgroundImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<BackgroundImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<BackgroundImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<BackgroundImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get src() {
    throw new Error("<BackgroundImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error("<BackgroundImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<BackgroundImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<BackgroundImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<BackgroundImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<BackgroundImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BackgroundImage_default = BackgroundImage;

// node_modules/@svelteuidev/core/dist/components/Input/Input.styles.js
var sizes9 = {
  xs: 30,
  sm: 36,
  md: 42,
  lg: 50,
  xl: 60
};
var Input_styles_default = createStyles((theme4, { icon, iconWidth, invalid, multiline, radius: radius2, rightSectionWidth, size: size3, resize, variant: variant2, showRightSection }) => {
  return {
    root: {
      darkMode: {
        "&:disabled": {
          backgroundColor: theme4.fn.themeColor("dark", 6)
        },
        "&::placeholder": {
          color: theme4.fn.themeColor("dark", 3)
        }
      },
      position: "relative"
    },
    input: variant2 !== "headless" ? {
      height: multiline ? "auto" : typeof size3 === "number" ? `${size3}px` : sizes9[size3] ?? sizes9.md,
      WebkitTapHighlightColor: "transparent",
      lineHeight: multiline ? "$md" : `${sizes9[size3] - 2}px`,
      appearance: "none",
      resize,
      boxSizing: "border-box",
      fontFamily: theme4.fonts.standard.value ?? "sans-serif",
      fontSize: typeof size3 === "number" ? `${size3}px` : `${size3}`,
      width: "100%",
      color: "Black",
      display: "block",
      textAlign: "left",
      minHeight: variant2 === "default" || variant2 === "filled" ? sizes9[size3] ?? sizes9.md : null,
      paddingLeft: variant2 === "default" && icon || variant2 === "filled" && icon ? sizes9[size3] ?? sizes9.md / 3 : 12,
      paddingRight: variant2 === "default" || variant2 === "filled" ? showRightSection ? rightSectionWidth : null : null,
      borderRadius: variant2 === "default" || variant2 === "filled" ? `$${radius2}` : null,
      "&:disabled": {
        backgroundColor: theme4.fn.themeColor("gray", 1),
        color: theme4.fn.themeColor("dark", 2),
        opacity: 0.6,
        cursor: "not-allowed",
        "&::placeholder": {
          color: theme4.fn.themeColor("dark", 2)
        }
      },
      "&::placeholder": {
        opacity: 1,
        userSelect: "none",
        color: theme4.fn.themeColor("gray", 5)
      },
      "&::-webkit-inner-spin-button, &::-webkit-outer-spin-button, &::-webkit-search-decoration, &::-webkit-search-cancel-button, &::-webkit-search-results-button, &::-webkit-search-results-decoration": {
        appearance: "none"
      },
      "&[type=number]": {
        MozAppearance: "textfield"
      },
      darkMode: {
        color: theme4.fn.themeColor("dark", 0)
      }
    } : {},
    defaultVariant: {
      border: `1px solid ${theme4.fn.themeColor("gray", 4)}`,
      backgroundColor: "White",
      transition: "border-color 100ms ease",
      minHeight: sizes9[size3] ?? sizes9.md,
      "&:focus, &:focus-within": {
        outline: "none",
        borderColor: theme4.fn.themeColor("blue", 5)
      },
      darkMode: {
        border: `1px solid ${theme4.fn.themeColor("dark", 5)}`,
        backgroundColor: theme4.fn.themeColor("dark", 8),
        "&:focus, &:focus-within": {
          borderColor: theme4.fn.themeColor("blue", 8)
        }
      }
    },
    filledVariant: {
      border: "1px solid transparent",
      backgroundColor: theme4.fn.themeColor("gray", 1),
      minHeight: sizes9[size3] ?? sizes9.md,
      "&:focus, &:focus-within": {
        outline: "none",
        borderColor: `${theme4.fn.themeColor("blue", 5)} !important`
      },
      darkMode: {
        backgroundColor: theme4.fn.themeColor("dark", 5),
        "&:focus, &:focus-within": {
          borderColor: `${theme4.fn.themeColor("blue", 8)} !important`
        }
      }
    },
    unstyledVariant: {
      height: multiline ? void 0 : "auto",
      borderWidth: 0,
      color: "Black",
      backgroundColor: "transparent",
      minHeight: 28,
      outline: 0,
      "&:focus, &:focus-within": {
        outline: "none",
        borderColor: "transparent"
      },
      "&:disabled": {
        backgroundColor: "transparent",
        "&:focus, &:focus-within": {
          outline: "none",
          borderColor: "transparent"
        }
      }
    },
    withIcon: {
      paddingLeft: typeof iconWidth === "number" ? `${iconWidth}px` : sizes9[size3] ?? sizes9.md
    },
    iconWrapper: {
      pointerEvents: "none",
      position: "absolute",
      zIndex: 1,
      left: 0,
      top: 0,
      bottom: 0,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: iconWidth ? `${iconWidth}px` : sizes9[size3] ?? sizes9.md
    },
    disabled: {
      backgroundColor: theme4.fn.themeColor("gray", 1),
      color: theme4.fn.themeColor("dark", 2),
      opacity: 0.6,
      cursor: "not-allowed",
      "&::placeholder": {
        color: theme4.fn.themeColor("dark", 2)
      },
      darkMode: {
        backgroundColor: theme4.fn.themeColor("dark", 6),
        borderColor: theme4.fn.themeColor("dark", 4)
      }
    },
    invalid: {
      color: theme4.fn.themeColor("red", 7),
      borderColor: theme4.fn.themeColor("red", 7),
      "&::placeholder": {
        opacity: 1,
        color: theme4.fn.themeColor("red", 7)
      },
      darkMode: {
        color: theme4.fn.themeColor("red", 6),
        borderColor: theme4.fn.themeColor("red", 6),
        "&::placeholder": {
          color: theme4.fn.themeColor("red", 6)
        }
      }
    },
    icon: {
      color: invalid ? theme4.fn.themeColor("red", 7) : theme4.fn.themeColor("gray", 5),
      pointerEvents: "none",
      darkMode: {
        color: invalid ? theme4.fn.themeColor("red", 6) : theme4.fn.themeColor("dark", 2)
      }
    },
    rightSection: {
      position: "absolute",
      top: 0,
      bottom: 0,
      right: 0,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: rightSectionWidth
    },
    noPointerEvents: {
      pointerEvents: "none"
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Input/Input.svelte
var file30 = "node_modules/@svelteuidev/core/dist/components/Input/Input.svelte";
var get_rightSection_slot_changes2 = (dirty) => ({});
var get_rightSection_slot_context2 = (ctx8) => ({});
var get_icon_slot_changes4 = (dirty) => ({});
var get_icon_slot_context4 = (ctx8) => ({});
function create_if_block_52(ctx8) {
  let switch_instance;
  let updating_element;
  let updating_value;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    {
      use: [
        /*forwardEvents*/
        ctx8[28],
        [
          useActions,
          /*use*/
          ctx8[2]
        ]
      ]
    },
    { "aria-invalid": (
      /*invalid*/
      ctx8[15]
    ) },
    {
      class: (
        /*cx*/
        ctx8[26](
          /*className*/
          ctx8[3],
          {
            [
              /*classes*/
              ctx8[25].disabled
            ]: (
              /*disabled*/
              ctx8[14]
            ),
            [
              /*classes*/
              ctx8[25].invalid
            ]: (
              /*invalid*/
              ctx8[15]
            ),
            [
              /*classes*/
              ctx8[25].withIcon
            ]: (
              /*icon*/
              ctx8[6] || /*isIconSlotUsed*/
              ctx8[27]
            )
          },
          /*classes*/
          ctx8[25][`${/*variant*/
          ctx8[13]}Variant`] ?? {}
        )
      )
    },
    { disabled: (
      /*disabled*/
      ctx8[14]
    ) },
    { required: (
      /*required*/
      ctx8[12]
    ) },
    { id: (
      /*id*/
      ctx8[11]
    ) },
    { type: (
      /*type*/
      ctx8[17]
    ) },
    { autofocus: (
      /*autofocus*/
      ctx8[19]
    ) },
    /*$$restProps*/
    ctx8[33]
  ];
  function switch_instance_element_binding(value) {
    ctx8[43](value);
  }
  function switch_instance_value_binding(value) {
    ctx8[44](value);
  }
  var switch_value = (
    /*root*/
    ctx8[5]
  );
  function switch_props(ctx9, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot_111] },
      $$scope: { ctx: ctx9 }
    };
    for (let i2 = 0; i2 < switch_instance_spread_levels.length; i2 += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i2]);
    }
    if (dirty !== void 0 && dirty[0] & /*forwardEvents, use, invalid, cx, className, classes, disabled, icon, isIconSlotUsed, variant, required, id, type, autofocus*/
    504035404 | dirty[1] & /*$$restProps*/
    4) {
      switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [
        dirty[0] & /*forwardEvents, use*/
        268435460 && {
          use: [
            /*forwardEvents*/
            ctx9[28],
            [
              useActions,
              /*use*/
              ctx9[2]
            ]
          ]
        },
        dirty[0] & /*invalid*/
        32768 && { "aria-invalid": (
          /*invalid*/
          ctx9[15]
        ) },
        dirty[0] & /*cx, className, classes, disabled, invalid, icon, isIconSlotUsed, variant*/
        234938440 && {
          class: (
            /*cx*/
            ctx9[26](
              /*className*/
              ctx9[3],
              {
                [
                  /*classes*/
                  ctx9[25].disabled
                ]: (
                  /*disabled*/
                  ctx9[14]
                ),
                [
                  /*classes*/
                  ctx9[25].invalid
                ]: (
                  /*invalid*/
                  ctx9[15]
                ),
                [
                  /*classes*/
                  ctx9[25].withIcon
                ]: (
                  /*icon*/
                  ctx9[6] || /*isIconSlotUsed*/
                  ctx9[27]
                )
              },
              /*classes*/
              ctx9[25][`${/*variant*/
              ctx9[13]}Variant`] ?? {}
            )
          )
        },
        dirty[0] & /*disabled*/
        16384 && { disabled: (
          /*disabled*/
          ctx9[14]
        ) },
        dirty[0] & /*required*/
        4096 && { required: (
          /*required*/
          ctx9[12]
        ) },
        dirty[0] & /*id*/
        2048 && { id: (
          /*id*/
          ctx9[11]
        ) },
        dirty[0] & /*type*/
        131072 && { type: (
          /*type*/
          ctx9[17]
        ) },
        dirty[0] & /*autofocus*/
        524288 && { autofocus: (
          /*autofocus*/
          ctx9[19]
        ) },
        dirty[1] & /*$$restProps*/
        4 && get_spread_object(
          /*$$restProps*/
          ctx9[33]
        )
      ]));
    }
    if (
      /*element*/
      ctx9[0] !== void 0
    ) {
      switch_instance_props.element = /*element*/
      ctx9[0];
    }
    if (
      /*value*/
      ctx9[1] !== void 0
    ) {
      switch_instance_props.value = /*value*/
      ctx9[1];
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx8));
    binding_callbacks.push(() => bind(switch_instance, "element", switch_instance_element_binding));
    binding_callbacks.push(() => bind(switch_instance, "value", switch_instance_value_binding));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*root*/
      32 && switch_value !== (switch_value = /*root*/
      ctx9[5])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx9, dirty));
          binding_callbacks.push(() => bind(switch_instance, "element", switch_instance_element_binding));
          binding_callbacks.push(() => bind(switch_instance, "value", switch_instance_value_binding));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty[0] & /*forwardEvents, use, invalid, cx, className, classes, disabled, icon, isIconSlotUsed, variant, required, id, type, autofocus*/
        504035404 | dirty[1] & /*$$restProps*/
        4 ? get_spread_update(switch_instance_spread_levels, [
          dirty[0] & /*forwardEvents, use*/
          268435460 && {
            use: [
              /*forwardEvents*/
              ctx9[28],
              [
                useActions,
                /*use*/
                ctx9[2]
              ]
            ]
          },
          dirty[0] & /*invalid*/
          32768 && { "aria-invalid": (
            /*invalid*/
            ctx9[15]
          ) },
          dirty[0] & /*cx, className, classes, disabled, invalid, icon, isIconSlotUsed, variant*/
          234938440 && {
            class: (
              /*cx*/
              ctx9[26](
                /*className*/
                ctx9[3],
                {
                  [
                    /*classes*/
                    ctx9[25].disabled
                  ]: (
                    /*disabled*/
                    ctx9[14]
                  ),
                  [
                    /*classes*/
                    ctx9[25].invalid
                  ]: (
                    /*invalid*/
                    ctx9[15]
                  ),
                  [
                    /*classes*/
                    ctx9[25].withIcon
                  ]: (
                    /*icon*/
                    ctx9[6] || /*isIconSlotUsed*/
                    ctx9[27]
                  )
                },
                /*classes*/
                ctx9[25][`${/*variant*/
                ctx9[13]}Variant`] ?? {}
              )
            )
          },
          dirty[0] & /*disabled*/
          16384 && { disabled: (
            /*disabled*/
            ctx9[14]
          ) },
          dirty[0] & /*required*/
          4096 && { required: (
            /*required*/
            ctx9[12]
          ) },
          dirty[0] & /*id*/
          2048 && { id: (
            /*id*/
            ctx9[11]
          ) },
          dirty[0] & /*type*/
          131072 && { type: (
            /*type*/
            ctx9[17]
          ) },
          dirty[0] & /*autofocus*/
          524288 && { autofocus: (
            /*autofocus*/
            ctx9[19]
          ) },
          dirty[1] & /*$$restProps*/
          4 && get_spread_object(
            /*$$restProps*/
            ctx9[33]
          )
        ]) : {};
        if (dirty[1] & /*$$scope*/
        32768) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx9 };
        }
        if (!updating_element && dirty[0] & /*element*/
        1) {
          updating_element = true;
          switch_instance_changes.element = /*element*/
          ctx9[0];
          add_flush_callback(() => updating_element = false);
        }
        if (!updating_value && dirty[0] & /*value*/
        2) {
          updating_value = true;
          switch_instance_changes.value = /*value*/
          ctx9[1];
          add_flush_callback(() => updating_value = false);
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_52.name,
    type: "if",
    source: "(147:51) ",
    ctx: ctx8
  });
  return block;
}
function create_if_block_42(ctx8) {
  let current;
  validate_dynamic_element(
    /*castRoot*/
    ctx8[29]()
  );
  validate_void_dynamic_element(
    /*castRoot*/
    ctx8[29]()
  );
  let svelte_element = (
    /*castRoot*/
    ctx8[29]() && create_dynamic_element2(ctx8)
  );
  const block = {
    c: function create() {
      if (svelte_element)
        svelte_element.c();
    },
    l: function claim(nodes) {
      if (svelte_element)
        svelte_element.l(nodes);
    },
    m: function mount(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (
        /*castRoot*/
        ctx9[29]()
      ) {
        svelte_element.p(ctx9, dirty);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(svelte_element, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svelte_element, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_42.name,
    type: "if",
    source: "(111:50) ",
    ctx: ctx8
  });
  return block;
}
function create_if_block_33(ctx8) {
  let input;
  let input_class_value;
  let useActions_action;
  let forwardEvents_action;
  let mounted;
  let dispose;
  let input_levels = [
    { value: (
      /*value*/
      ctx8[1]
    ) },
    { type: (
      /*type*/
      ctx8[17]
    ) },
    { required: (
      /*required*/
      ctx8[12]
    ) },
    { disabled: (
      /*disabled*/
      ctx8[14]
    ) },
    { id: (
      /*id*/
      ctx8[11]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx8[18]
    ) },
    { autocomplete: (
      /*autocomplete*/
      ctx8[16]
    ) },
    { autofocus: (
      /*autofocus*/
      ctx8[19]
    ) },
    { "aria-invalid": (
      /*invalid*/
      ctx8[15]
    ) },
    {
      class: input_class_value = /*cx*/
      ctx8[26](
        /*className*/
        ctx8[3],
        /*classes*/
        ctx8[25].input,
        {
          [
            /*classes*/
            ctx8[25].disabled
          ]: (
            /*disabled*/
            ctx8[14]
          ),
          [
            /*classes*/
            ctx8[25].invalid
          ]: (
            /*invalid*/
            ctx8[15]
          ),
          [
            /*classes*/
            ctx8[25].withIcon
          ]: (
            /*icon*/
            ctx8[6] || /*isIconSlotUsed*/
            ctx8[27]
          )
        },
        /*classes*/
        ctx8[25][`${/*variant*/
        ctx8[13]}Variant`] ?? {}
      )
    },
    /*$$restProps*/
    ctx8[33]
  ];
  let input_data = {};
  for (let i2 = 0; i2 < input_levels.length; i2 += 1) {
    input_data = assign(input_data, input_levels[i2]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        type: true,
        id: true,
        placeholder: true,
        autocomplete: true,
        "aria-invalid": true,
        class: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file30, 84, 2, 3112);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if ("value" in input_data) {
        input.value = input_data.value;
      }
      if (input.autofocus)
        input.focus();
      ctx8[41](input);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            input,
            /*use*/
            ctx8[2]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx8[28].call(null, input)),
          listen_dev(
            input,
            "input",
            /*onInput*/
            ctx8[31],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx9, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty[0] & /*value*/
        2 && input.value !== /*value*/
        ctx9[1] && { value: (
          /*value*/
          ctx9[1]
        ) },
        dirty[0] & /*type*/
        131072 && { type: (
          /*type*/
          ctx9[17]
        ) },
        dirty[0] & /*required*/
        4096 && { required: (
          /*required*/
          ctx9[12]
        ) },
        dirty[0] & /*disabled*/
        16384 && { disabled: (
          /*disabled*/
          ctx9[14]
        ) },
        dirty[0] & /*id*/
        2048 && { id: (
          /*id*/
          ctx9[11]
        ) },
        dirty[0] & /*placeholder*/
        262144 && { placeholder: (
          /*placeholder*/
          ctx9[18]
        ) },
        dirty[0] & /*autocomplete*/
        65536 && { autocomplete: (
          /*autocomplete*/
          ctx9[16]
        ) },
        dirty[0] & /*autofocus*/
        524288 && { autofocus: (
          /*autofocus*/
          ctx9[19]
        ) },
        dirty[0] & /*invalid*/
        32768 && { "aria-invalid": (
          /*invalid*/
          ctx9[15]
        ) },
        dirty[0] & /*cx, className, classes, disabled, invalid, icon, isIconSlotUsed, variant*/
        234938440 && input_class_value !== (input_class_value = /*cx*/
        ctx9[26](
          /*className*/
          ctx9[3],
          /*classes*/
          ctx9[25].input,
          {
            [
              /*classes*/
              ctx9[25].disabled
            ]: (
              /*disabled*/
              ctx9[14]
            ),
            [
              /*classes*/
              ctx9[25].invalid
            ]: (
              /*invalid*/
              ctx9[15]
            ),
            [
              /*classes*/
              ctx9[25].withIcon
            ]: (
              /*icon*/
              ctx9[6] || /*isIconSlotUsed*/
              ctx9[27]
            )
          },
          /*classes*/
          ctx9[25][`${/*variant*/
          ctx9[13]}Variant`] ?? {}
        )) && { class: input_class_value },
        dirty[1] & /*$$restProps*/
        4 && /*$$restProps*/
        ctx9[33]
      ]));
      if ("value" in input_data) {
        input.value = input_data.value;
      }
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/
      4)
        useActions_action.update.call(
          null,
          /*use*/
          ctx9[2]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      ctx8[41](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_33.name,
    type: "if",
    source: "(84:1) {#if isHTMLElement && root === 'input'}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_111(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[40].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[46],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[46],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[46]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[46],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_111.name,
    type: "slot",
    source: "(148:2) <svelte:component    this={root}    bind:element    bind:value    use={[forwardEvents, [useActions, use]]}    aria-invalid={invalid}    class={cx(     className,     {      [classes.disabled]: disabled,      [classes.invalid]: invalid,      [classes.withIcon]: icon || isIconSlotUsed     },     classes[`${variant}Variant`] ?? {}    )}    {disabled}    {required}    {id}    {type}    {autofocus}    {...$$restProps}   >",
    ctx: ctx8
  });
  return block;
}
function create_dynamic_element2(ctx8) {
  let svelte_element;
  let svelte_element_class_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx8[40].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[46],
    null
  );
  let svelte_element_levels = [
    { value: (
      /*value*/
      ctx8[1]
    ) },
    { required: (
      /*required*/
      ctx8[12]
    ) },
    { disabled: (
      /*disabled*/
      ctx8[14]
    ) },
    { id: (
      /*id*/
      ctx8[11]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx8[18]
    ) },
    { autocomplete: (
      /*autocomplete*/
      ctx8[16]
    ) },
    { type: (
      /*type*/
      ctx8[17]
    ) },
    { autofocus: (
      /*autofocus*/
      ctx8[19]
    ) },
    { "aria-invalid": (
      /*invalid*/
      ctx8[15]
    ) },
    {
      class: svelte_element_class_value = /*cx*/
      ctx8[26](
        /*className*/
        ctx8[3],
        /*classes*/
        ctx8[25].input,
        {
          [
            /*classes*/
            ctx8[25].disabled
          ]: (
            /*disabled*/
            ctx8[14]
          ),
          [
            /*classes*/
            ctx8[25].invalid
          ]: (
            /*invalid*/
            ctx8[15]
          ),
          [
            /*classes*/
            ctx8[25].withIcon
          ]: (
            /*icon*/
            ctx8[6] || /*isIconSlotUsed*/
            ctx8[27]
          )
        },
        /*classes*/
        ctx8[25][`${/*variant*/
        ctx8[13]}Variant`] ?? {}
      )
    },
    /*$$restProps*/
    ctx8[33]
  ];
  let svelte_element_data = {};
  for (let i2 = 0; i2 < svelte_element_levels.length; i2 += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i2]);
  }
  const block = {
    c: function create() {
      svelte_element = element(
        /*castRoot*/
        ctx8[29]()
      );
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(
        nodes,
        /*castRoot*/
        (ctx8[29]() || "null").toUpperCase(),
        {
          value: true,
          required: true,
          disabled: true,
          id: true,
          placeholder: true,
          autocomplete: true,
          type: true,
          autofocus: true,
          "aria-invalid": true,
          class: true
        }
      );
      var svelte_element_nodes = children(svelte_element);
      if (default_slot)
        default_slot.l(svelte_element_nodes);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_dynamic_element_data(
        /*castRoot*/
        ctx8[29]()
      )(svelte_element, svelte_element_data);
      toggle_class(
        svelte_element,
        "disabled",
        /*disabled*/
        ctx8[14]
      );
      toggle_class(
        svelte_element,
        "invalid",
        /*invalid*/
        ctx8[15]
      );
      add_location(svelte_element, file30, 114, 2, 3826);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      if (default_slot) {
        default_slot.m(svelte_element, null);
      }
      ctx8[42](svelte_element);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            svelte_element,
            "change",
            /*onChange*/
            ctx8[30],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            svelte_element,
            "input",
            /*onInput*/
            ctx8[31],
            false,
            false,
            false,
            false
          ),
          action_destroyer(useActions_action = useActions.call(
            null,
            svelte_element,
            /*use*/
            ctx8[2]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx8[28].call(null, svelte_element))
        ];
        mounted = true;
      }
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[46],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[46]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[46],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_dynamic_element_data(
        /*castRoot*/
        ctx9[29]()
      )(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [
        (!current || dirty[0] & /*value*/
        2) && { value: (
          /*value*/
          ctx9[1]
        ) },
        (!current || dirty[0] & /*required*/
        4096) && { required: (
          /*required*/
          ctx9[12]
        ) },
        (!current || dirty[0] & /*disabled*/
        16384) && { disabled: (
          /*disabled*/
          ctx9[14]
        ) },
        (!current || dirty[0] & /*id*/
        2048) && { id: (
          /*id*/
          ctx9[11]
        ) },
        (!current || dirty[0] & /*placeholder*/
        262144) && { placeholder: (
          /*placeholder*/
          ctx9[18]
        ) },
        (!current || dirty[0] & /*autocomplete*/
        65536) && { autocomplete: (
          /*autocomplete*/
          ctx9[16]
        ) },
        (!current || dirty[0] & /*type*/
        131072) && { type: (
          /*type*/
          ctx9[17]
        ) },
        (!current || dirty[0] & /*autofocus*/
        524288) && { autofocus: (
          /*autofocus*/
          ctx9[19]
        ) },
        (!current || dirty[0] & /*invalid*/
        32768) && { "aria-invalid": (
          /*invalid*/
          ctx9[15]
        ) },
        (!current || dirty[0] & /*cx, className, classes, disabled, invalid, icon, isIconSlotUsed, variant*/
        234938440 && svelte_element_class_value !== (svelte_element_class_value = /*cx*/
        ctx9[26](
          /*className*/
          ctx9[3],
          /*classes*/
          ctx9[25].input,
          {
            [
              /*classes*/
              ctx9[25].disabled
            ]: (
              /*disabled*/
              ctx9[14]
            ),
            [
              /*classes*/
              ctx9[25].invalid
            ]: (
              /*invalid*/
              ctx9[15]
            ),
            [
              /*classes*/
              ctx9[25].withIcon
            ]: (
              /*icon*/
              ctx9[6] || /*isIconSlotUsed*/
              ctx9[27]
            )
          },
          /*classes*/
          ctx9[25][`${/*variant*/
          ctx9[13]}Variant`] ?? {}
        ))) && { class: svelte_element_class_value },
        dirty[1] & /*$$restProps*/
        4 && /*$$restProps*/
        ctx9[33]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/
      4)
        useActions_action.update.call(
          null,
          /*use*/
          ctx9[2]
        );
      toggle_class(
        svelte_element,
        "disabled",
        /*disabled*/
        ctx9[14]
      );
      toggle_class(
        svelte_element,
        "invalid",
        /*invalid*/
        ctx9[15]
      );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svelte_element);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx8[42](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element2.name,
    type: "child_dynamic_element",
    source: "(115:2) <svelte:element    this={castRoot()}    bind:this={element}    {value}    {required}    {disabled}    {id}    {placeholder}    {autocomplete}    {type}    {autofocus}    aria-invalid={invalid}    class:disabled    class:invalid    class={cx(     className,     classes.input,     {      [classes.disabled]: disabled,      [classes.invalid]: invalid,      [classes.withIcon]: icon || isIconSlotUsed     },     classes[`${variant}Variant`] ?? {}    )}    on:change={onChange}    on:input={onInput}    use:useActions={use}    use:forwardEvents    {...$$restProps}   >",
    ctx: ctx8
  });
  return block;
}
function create_if_block_29(ctx8) {
  let div;
  let iconrenderer;
  let div_class_value;
  let current;
  iconrenderer = new IconRenderer_default({
    props: {
      icon: (
        /*icon*/
        ctx8[6]
      ),
      iconProps: (
        /*iconProps*/
        ctx8[7]
      ),
      iconSize: 16
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(iconrenderer.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(iconrenderer.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*classes*/
      ctx8[25].icon);
      add_location(div, file30, 176, 4, 5174);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(iconrenderer, div, null);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const iconrenderer_changes = {};
      if (dirty[0] & /*icon*/
      64)
        iconrenderer_changes.icon = /*icon*/
        ctx9[6];
      if (dirty[0] & /*iconProps*/
      128)
        iconrenderer_changes.iconProps = /*iconProps*/
        ctx9[7];
      iconrenderer.$set(iconrenderer_changes);
      if (!current || dirty[0] & /*classes*/
      33554432 && div_class_value !== (div_class_value = /*classes*/
      ctx9[25].icon)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconrenderer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconrenderer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(iconrenderer);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_29.name,
    type: "if",
    source: "(176:3) {#if icon}",
    ctx: ctx8
  });
  return block;
}
function fallback_block14(ctx8) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*icon*/
    ctx8[6] && create_if_block_29(ctx8)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (
        /*icon*/
        ctx9[6]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
          if (dirty[0] & /*icon*/
          64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_29(ctx9);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block14.name,
    type: "fallback",
    source: "(175:20)     ",
    ctx: ctx8
  });
  return block;
}
function create_if_block_114(ctx8) {
  let div;
  let iconrenderer;
  let div_class_value;
  let current;
  iconrenderer = new IconRenderer_default({
    props: {
      icon: (
        /*icon*/
        ctx8[6]
      ),
      iconProps: (
        /*iconProps*/
        ctx8[7]
      ),
      iconSize: 16
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(iconrenderer.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(iconrenderer.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*cx*/
      ctx8[26](
        /*classes*/
        ctx8[25].icon,
        /*classes*/
        ctx8[25].iconWrapper
      ));
      add_location(div, file30, 184, 2, 5444);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(iconrenderer, div, null);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const iconrenderer_changes = {};
      if (dirty[0] & /*icon*/
      64)
        iconrenderer_changes.icon = /*icon*/
        ctx9[6];
      if (dirty[0] & /*iconProps*/
      128)
        iconrenderer_changes.iconProps = /*iconProps*/
        ctx9[7];
      iconrenderer.$set(iconrenderer_changes);
      if (!current || dirty[0] & /*cx, classes*/
      100663296 && div_class_value !== (div_class_value = /*cx*/
      ctx9[26](
        /*classes*/
        ctx9[25].icon,
        /*classes*/
        ctx9[25].iconWrapper
      ))) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconrenderer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconrenderer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(iconrenderer);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_114.name,
    type: "if",
    source: "(184:1) {#if icon && $$slots.icon && !isIconSlotUsed}",
    ctx: ctx8
  });
  return block;
}
function create_if_block24(ctx8) {
  let div;
  let div_class_value;
  let current;
  const rightSection_slot_template = (
    /*#slots*/
    ctx8[40].rightSection
  );
  const rightSection_slot = create_slot(
    rightSection_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[46],
    get_rightSection_slot_context2
  );
  let div_levels = [
    /*rightSectionProps*/
    ctx8[9],
    {
      class: div_class_value = /*cx*/
      ctx8[26](
        /*classes*/
        ctx8[25].rightSection,
        {
          [
            /*classes*/
            ctx8[25].noPointerEvents
          ]: (
            /*noPointerEventsRightSection*/
            ctx8[20]
          )
        }
      )
    }
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign(div_data, div_levels[i2]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (rightSection_slot)
        rightSection_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (rightSection_slot)
        rightSection_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file30, 189, 2, 5591);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (rightSection_slot) {
        rightSection_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (rightSection_slot) {
        if (rightSection_slot.p && (!current || dirty[1] & /*$$scope*/
        32768)) {
          update_slot_base(
            rightSection_slot,
            rightSection_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[46],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[46]
            ) : get_slot_changes(
              rightSection_slot_template,
              /*$$scope*/
              ctx9[46],
              dirty,
              get_rightSection_slot_changes2
            ),
            get_rightSection_slot_context2
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty[0] & /*rightSectionProps*/
        512 && /*rightSectionProps*/
        ctx9[9],
        (!current || dirty[0] & /*cx, classes, noPointerEventsRightSection*/
        101711872 && div_class_value !== (div_class_value = /*cx*/
        ctx9[26](
          /*classes*/
          ctx9[25].rightSection,
          {
            [
              /*classes*/
              ctx9[25].noPointerEvents
            ]: (
              /*noPointerEventsRightSection*/
              ctx9[20]
            )
          }
        ))) && { class: div_class_value }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rightSection_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rightSection_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (rightSection_slot)
        rightSection_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block24.name,
    type: "if",
    source: "(189:1) {#if showRightSection}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot48(ctx8) {
  let show_if;
  let current_block_type_index;
  let if_block0;
  let t0;
  let span;
  let span_class_value;
  let t1;
  let t2;
  let if_block2_anchor;
  let current;
  const if_block_creators = [create_if_block_33, create_if_block_42, create_if_block_52];
  const if_blocks = [];
  function select_block_type(ctx9, dirty) {
    if (dirty[0] & /*isHTMLElement, root*/
    4194336)
      show_if = null;
    if (
      /*isHTMLElement*/
      ctx9[22] && /*root*/
      ctx9[5] === "input"
    )
      return 0;
    if (show_if == null)
      show_if = !!/*isHTMLElement*/
      (ctx9[22] && isInput(String(
        /*root*/
        ctx9[5]
      )));
    if (show_if)
      return 1;
    if (
      /*isComponent*/
      ctx9[23] && typeof /*root*/
      ctx9[5] !== "string"
    )
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx8, [-1, -1]))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx8);
  }
  const icon_slot_template = (
    /*#slots*/
    ctx8[40].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[46],
    get_icon_slot_context4
  );
  const icon_slot_or_fallback = icon_slot || fallback_block14(ctx8);
  let if_block1 = (
    /*icon*/
    ctx8[6] && /*$$slots*/
    ctx8[32].icon && !/*isIconSlotUsed*/
    ctx8[27] && create_if_block_114(ctx8)
  );
  let if_block2 = (
    /*showRightSection*/
    ctx8[8] && create_if_block24(ctx8)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      span = element("span");
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.l(span_nodes);
      span_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t2 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      if_block2_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*cx*/
      ctx8[26]({
        [
          /*classes*/
          ctx8[25].iconWrapper
        ]: !!/*icon*/
        ctx8[6] || /*isIconSlotUsed*/
        ctx8[27]
      }));
      add_location(span, file30, 173, 1, 5040);
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, span, anchor);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(span, null);
      }
      ctx8[45](span);
      insert_hydration_dev(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx9, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx9, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx9);
            if_block0.c();
          } else {
            if_block0.p(ctx9, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        } else {
          if_block0 = null;
        }
      }
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty[1] & /*$$scope*/
        32768)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[46],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[46]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx9[46],
              dirty,
              get_icon_slot_changes4
            ),
            get_icon_slot_context4
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty[0] & /*classes, icon, iconProps*/
        33554624)) {
          icon_slot_or_fallback.p(ctx9, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*cx, classes, icon, isIconSlotUsed*/
      234881088 && span_class_value !== (span_class_value = /*cx*/
      ctx9[26]({
        [
          /*classes*/
          ctx9[25].iconWrapper
        ]: !!/*icon*/
        ctx9[6] || /*isIconSlotUsed*/
        ctx9[27]
      }))) {
        attr_dev(span, "class", span_class_value);
      }
      if (
        /*icon*/
        ctx9[6] && /*$$slots*/
        ctx9[32].icon && !/*isIconSlotUsed*/
        ctx9[27]
      ) {
        if (if_block1) {
          if_block1.p(ctx9, dirty);
          if (dirty[0] & /*icon, isIconSlotUsed*/
          134217792 | dirty[1] & /*$$slots*/
          2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_114(ctx9);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*showRightSection*/
        ctx9[8]
      ) {
        if (if_block2) {
          if_block2.p(ctx9, dirty);
          if (dirty[0] & /*showRightSection*/
          256) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block24(ctx9);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(icon_slot_or_fallback, local);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(icon_slot_or_fallback, local);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(span);
        detach_dev(t1);
        detach_dev(t2);
        detach_dev(if_block2_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.d(detaching);
      ctx8[45](null);
      if (if_block1)
        if_block1.d(detaching);
      if (if_block2)
        if_block2.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot48.name,
    type: "slot",
    source: "(83:0) <Box {...wrapperProps} class={cx(classes.root, getStyles({ css: override }))} {...$$restProps}>",
    ctx: ctx8
  });
  return block;
}
function create_fragment66(ctx8) {
  let box;
  let current;
  const box_spread_levels = [
    /*wrapperProps*/
    ctx8[10],
    {
      class: (
        /*cx*/
        ctx8[26](
          /*classes*/
          ctx8[25].root,
          /*getStyles*/
          ctx8[24]({ css: (
            /*override*/
            ctx8[4]
          ) })
        )
      )
    },
    /*$$restProps*/
    ctx8[33]
  ];
  let box_props = {
    $$slots: { default: [create_default_slot48] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  box = new Box_default({ props: box_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const box_changes = dirty[0] & /*wrapperProps, cx, classes, getStyles, override*/
      117441552 | dirty[1] & /*$$restProps*/
      4 ? get_spread_update(box_spread_levels, [
        dirty[0] & /*wrapperProps*/
        1024 && get_spread_object(
          /*wrapperProps*/
          ctx9[10]
        ),
        dirty[0] & /*cx, classes, getStyles, override*/
        117440528 && {
          class: (
            /*cx*/
            ctx9[26](
              /*classes*/
              ctx9[25].root,
              /*getStyles*/
              ctx9[24]({ css: (
                /*override*/
                ctx9[4]
              ) })
            )
          )
        },
        dirty[1] & /*$$restProps*/
        4 && get_spread_object(
          /*$$restProps*/
          ctx9[33]
        )
      ]) : {};
      if (dirty[0] & /*rightSectionProps, cx, classes, noPointerEventsRightSection, showRightSection, icon, iconProps, isIconSlotUsed, iconElement, value, type, required, disabled, id, placeholder, autocomplete, autofocus, invalid, className, variant, element, use, isHTMLElement, root, isComponent*/
      251657199 | dirty[1] & /*$$scope, $$slots, $$restProps*/
      32774) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment66.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function isInput(root) {
  return ["input", "select", "textarea", "datalist"].includes(root);
}
function instance66($$self, $$props, $$invalidate) {
  let isIconSlotUsed;
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "root",
    "icon",
    "iconWidth",
    "iconProps",
    "showRightSection",
    "rightSectionWidth",
    "rightSectionProps",
    "wrapperProps",
    "id",
    "required",
    "radius",
    "variant",
    "disabled",
    "size",
    "value",
    "invalid",
    "multiline",
    "autocomplete",
    "type",
    "placeholder",
    "autofocus",
    "resize",
    "noPointerEventsRightSection"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Input", slots, ["default", "icon", "rightSection"]);
  const $$slots = compute_slots(slots);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, root = "input", icon = null, iconWidth = 36, iconProps = { size: 20, color: "currentColor" }, showRightSection = $$slots.rightSection, rightSectionWidth = 36, rightSectionProps = {}, wrapperProps = {}, id = "input-id", required = false, radius: radius2 = "sm", variant: variant2 = "default", disabled = false, size: size3 = "sm", value = "", invalid = false, multiline = false, autocomplete = "on", type = "text", placeholder = void 0, autofocus = void 0, resize = "none", noPointerEventsRightSection = false } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  function castRoot() {
    return root;
  }
  let isHTMLElement = true;
  let isComponent = false;
  let iconElement;
  function onChange() {
    $$invalidate(1, value = this.value);
  }
  function onInput(event) {
    if (event.target.type === "checkbox") {
      $$invalidate(1, value = event.target.checked);
    } else if (event.target.type === "number" || event.target.type === "range") {
      $$invalidate(1, value = +event.target.value);
    } else {
      $$invalidate(1, value = event.target.value);
    }
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  function svelte_element_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  function switch_instance_element_binding(value2) {
    element2 = value2;
    $$invalidate(0, element2);
  }
  function switch_instance_value_binding(value$1) {
    value = value$1;
    $$invalidate(1, value);
  }
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      iconElement = $$value;
      $$invalidate(21, iconElement);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(33, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(4, override = $$new_props.override);
    if ("root" in $$new_props)
      $$invalidate(5, root = $$new_props.root);
    if ("icon" in $$new_props)
      $$invalidate(6, icon = $$new_props.icon);
    if ("iconWidth" in $$new_props)
      $$invalidate(34, iconWidth = $$new_props.iconWidth);
    if ("iconProps" in $$new_props)
      $$invalidate(7, iconProps = $$new_props.iconProps);
    if ("showRightSection" in $$new_props)
      $$invalidate(8, showRightSection = $$new_props.showRightSection);
    if ("rightSectionWidth" in $$new_props)
      $$invalidate(35, rightSectionWidth = $$new_props.rightSectionWidth);
    if ("rightSectionProps" in $$new_props)
      $$invalidate(9, rightSectionProps = $$new_props.rightSectionProps);
    if ("wrapperProps" in $$new_props)
      $$invalidate(10, wrapperProps = $$new_props.wrapperProps);
    if ("id" in $$new_props)
      $$invalidate(11, id = $$new_props.id);
    if ("required" in $$new_props)
      $$invalidate(12, required = $$new_props.required);
    if ("radius" in $$new_props)
      $$invalidate(36, radius2 = $$new_props.radius);
    if ("variant" in $$new_props)
      $$invalidate(13, variant2 = $$new_props.variant);
    if ("disabled" in $$new_props)
      $$invalidate(14, disabled = $$new_props.disabled);
    if ("size" in $$new_props)
      $$invalidate(37, size3 = $$new_props.size);
    if ("value" in $$new_props)
      $$invalidate(1, value = $$new_props.value);
    if ("invalid" in $$new_props)
      $$invalidate(15, invalid = $$new_props.invalid);
    if ("multiline" in $$new_props)
      $$invalidate(38, multiline = $$new_props.multiline);
    if ("autocomplete" in $$new_props)
      $$invalidate(16, autocomplete = $$new_props.autocomplete);
    if ("type" in $$new_props)
      $$invalidate(17, type = $$new_props.type);
    if ("placeholder" in $$new_props)
      $$invalidate(18, placeholder = $$new_props.placeholder);
    if ("autofocus" in $$new_props)
      $$invalidate(19, autofocus = $$new_props.autofocus);
    if ("resize" in $$new_props)
      $$invalidate(39, resize = $$new_props.resize);
    if ("noPointerEventsRightSection" in $$new_props)
      $$invalidate(20, noPointerEventsRightSection = $$new_props.noPointerEventsRightSection);
    if ("$$scope" in $$new_props)
      $$invalidate(46, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    get_current_component,
    createEventForwarder,
    useActions,
    Box: Box_default,
    IconRenderer: IconRenderer_default,
    useStyles: Input_styles_default,
    use,
    element: element2,
    className,
    override,
    root,
    icon,
    iconWidth,
    iconProps,
    showRightSection,
    rightSectionWidth,
    rightSectionProps,
    wrapperProps,
    id,
    required,
    radius: radius2,
    variant: variant2,
    disabled,
    size: size3,
    value,
    invalid,
    multiline,
    autocomplete,
    type,
    placeholder,
    autofocus,
    resize,
    noPointerEventsRightSection,
    forwardEvents,
    castRoot,
    isInput,
    isHTMLElement,
    isComponent,
    iconElement,
    onChange,
    onInput,
    getStyles,
    classes,
    cx: cx2,
    isIconSlotUsed
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(4, override = $$new_props.override);
    if ("root" in $$props)
      $$invalidate(5, root = $$new_props.root);
    if ("icon" in $$props)
      $$invalidate(6, icon = $$new_props.icon);
    if ("iconWidth" in $$props)
      $$invalidate(34, iconWidth = $$new_props.iconWidth);
    if ("iconProps" in $$props)
      $$invalidate(7, iconProps = $$new_props.iconProps);
    if ("showRightSection" in $$props)
      $$invalidate(8, showRightSection = $$new_props.showRightSection);
    if ("rightSectionWidth" in $$props)
      $$invalidate(35, rightSectionWidth = $$new_props.rightSectionWidth);
    if ("rightSectionProps" in $$props)
      $$invalidate(9, rightSectionProps = $$new_props.rightSectionProps);
    if ("wrapperProps" in $$props)
      $$invalidate(10, wrapperProps = $$new_props.wrapperProps);
    if ("id" in $$props)
      $$invalidate(11, id = $$new_props.id);
    if ("required" in $$props)
      $$invalidate(12, required = $$new_props.required);
    if ("radius" in $$props)
      $$invalidate(36, radius2 = $$new_props.radius);
    if ("variant" in $$props)
      $$invalidate(13, variant2 = $$new_props.variant);
    if ("disabled" in $$props)
      $$invalidate(14, disabled = $$new_props.disabled);
    if ("size" in $$props)
      $$invalidate(37, size3 = $$new_props.size);
    if ("value" in $$props)
      $$invalidate(1, value = $$new_props.value);
    if ("invalid" in $$props)
      $$invalidate(15, invalid = $$new_props.invalid);
    if ("multiline" in $$props)
      $$invalidate(38, multiline = $$new_props.multiline);
    if ("autocomplete" in $$props)
      $$invalidate(16, autocomplete = $$new_props.autocomplete);
    if ("type" in $$props)
      $$invalidate(17, type = $$new_props.type);
    if ("placeholder" in $$props)
      $$invalidate(18, placeholder = $$new_props.placeholder);
    if ("autofocus" in $$props)
      $$invalidate(19, autofocus = $$new_props.autofocus);
    if ("resize" in $$props)
      $$invalidate(39, resize = $$new_props.resize);
    if ("noPointerEventsRightSection" in $$props)
      $$invalidate(20, noPointerEventsRightSection = $$new_props.noPointerEventsRightSection);
    if ("isHTMLElement" in $$props)
      $$invalidate(22, isHTMLElement = $$new_props.isHTMLElement);
    if ("isComponent" in $$props)
      $$invalidate(23, isComponent = $$new_props.isComponent);
    if ("iconElement" in $$props)
      $$invalidate(21, iconElement = $$new_props.iconElement);
    if ("getStyles" in $$props)
      $$invalidate(24, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(25, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(26, cx2 = $$new_props.cx);
    if ("isIconSlotUsed" in $$props)
      $$invalidate(27, isIconSlotUsed = $$new_props.isIconSlotUsed);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*iconElement*/
    2097152) {
      $:
        $$invalidate(27, isIconSlotUsed = Boolean(iconElement == null ? void 0 : iconElement.innerHTML));
    }
    if ($$self.$$.dirty[0] & /*root*/
    32) {
      $: {
        $$invalidate(22, isHTMLElement = root && typeof root === "string");
        $$invalidate(23, isComponent = root && typeof root === "function");
      }
    }
    if ($$self.$$.dirty[0] & /*icon, invalid, showRightSection, variant*/
    41280 | $$self.$$.dirty[1] & /*iconWidth, multiline, radius, rightSectionWidth, size, resize*/
    504) {
      $:
        $$invalidate(
          26,
          { cx: cx2, classes, getStyles } = Input_styles_default(
            {
              icon,
              iconWidth,
              invalid,
              multiline,
              radius: radius2,
              rightSectionWidth,
              showRightSection,
              size: size3,
              resize,
              variant: variant2
            },
            { name: "Input" }
          ),
          cx2,
          ($$invalidate(25, classes), $$invalidate(6, icon), $$invalidate(34, iconWidth), $$invalidate(15, invalid), $$invalidate(38, multiline), $$invalidate(36, radius2), $$invalidate(35, rightSectionWidth), $$invalidate(8, showRightSection), $$invalidate(37, size3), $$invalidate(39, resize), $$invalidate(13, variant2)),
          ($$invalidate(24, getStyles), $$invalidate(6, icon), $$invalidate(34, iconWidth), $$invalidate(15, invalid), $$invalidate(38, multiline), $$invalidate(36, radius2), $$invalidate(35, rightSectionWidth), $$invalidate(8, showRightSection), $$invalidate(37, size3), $$invalidate(39, resize), $$invalidate(13, variant2))
        );
    }
  };
  return [
    element2,
    value,
    use,
    className,
    override,
    root,
    icon,
    iconProps,
    showRightSection,
    rightSectionProps,
    wrapperProps,
    id,
    required,
    variant2,
    disabled,
    invalid,
    autocomplete,
    type,
    placeholder,
    autofocus,
    noPointerEventsRightSection,
    iconElement,
    isHTMLElement,
    isComponent,
    getStyles,
    classes,
    cx2,
    isIconSlotUsed,
    forwardEvents,
    castRoot,
    onChange,
    onInput,
    $$slots,
    $$restProps,
    iconWidth,
    rightSectionWidth,
    radius2,
    size3,
    multiline,
    resize,
    slots,
    input_binding,
    svelte_element_binding,
    switch_instance_element_binding,
    switch_instance_value_binding,
    span_binding,
    $$scope
  ];
}
var Input = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance66,
      create_fragment66,
      safe_not_equal,
      {
        use: 2,
        element: 0,
        class: 3,
        override: 4,
        root: 5,
        icon: 6,
        iconWidth: 34,
        iconProps: 7,
        showRightSection: 8,
        rightSectionWidth: 35,
        rightSectionProps: 9,
        wrapperProps: 10,
        id: 11,
        required: 12,
        radius: 36,
        variant: 13,
        disabled: 14,
        size: 37,
        value: 1,
        invalid: 15,
        multiline: 38,
        autocomplete: 16,
        type: 17,
        placeholder: 18,
        autofocus: 19,
        resize: 39,
        noPointerEventsRightSection: 20
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Input",
      options,
      id: create_fragment66.name
    });
  }
  get use() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get root() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set root(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconWidth() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconWidth(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconProps() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconProps(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showRightSection() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showRightSection(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rightSectionWidth() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rightSectionWidth(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rightSectionProps() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rightSectionProps(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrapperProps() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrapperProps(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiline() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiline(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autocomplete() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autocomplete(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autofocus() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autofocus(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resize() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resize(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noPointerEventsRightSection() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noPointerEventsRightSection(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Input_default = Input;

// node_modules/@svelteuidev/core/dist/components/Input/Input.errors.js
var Input_errors_exports = {};
__export(Input_errors_exports, {
  TextErrors: () => TextErrors2
});
var TextErrors2 = Object.freeze([
  {
    error: true,
    message: "Message",
    solution: `
                If your component looks like this:

                &lt;Input placeholder='placeholder' /&gt;
						  ^^^ - Try adding prop variant='gradient'
                `
  }
]);

// node_modules/@svelteuidev/core/dist/components/Textarea/Textarea.svelte
var get_rightSection_slot_changes3 = (dirty) => ({});
var get_rightSection_slot_context3 = (ctx8) => ({ slot: "rightSection" });
function create_rightSection_slot(ctx8) {
  let current;
  const rightSection_slot_template = (
    /*#slots*/
    ctx8[21].rightSection
  );
  const rightSection_slot = create_slot(
    rightSection_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[24],
    get_rightSection_slot_context3
  );
  const block = {
    c: function create() {
      if (rightSection_slot)
        rightSection_slot.c();
    },
    l: function claim(nodes) {
      if (rightSection_slot)
        rightSection_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (rightSection_slot) {
        rightSection_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (rightSection_slot) {
        if (rightSection_slot.p && (!current || dirty & /*$$scope*/
        16777216)) {
          update_slot_base(
            rightSection_slot,
            rightSection_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[24],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[24]
            ) : get_slot_changes(
              rightSection_slot_template,
              /*$$scope*/
              ctx9[24],
              dirty,
              get_rightSection_slot_changes3
            ),
            get_rightSection_slot_context3
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rightSection_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rightSection_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (rightSection_slot)
        rightSection_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_rightSection_slot.name,
    type: "slot",
    source: "(59:2) ",
    ctx: ctx8
  });
  return block;
}
function create_default_slot49(ctx8) {
  let input;
  let updating_value;
  let current;
  const input_spread_levels = [
    { required: (
      /*required*/
      ctx8[8]
    ) },
    { id: (
      /*id*/
      ctx8[12]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx8[14]
    ) },
    /*$$restProps*/
    ctx8[18],
    {
      use: [
        /*forwardEvents*/
        ctx8[16],
        [
          useActions,
          /*use*/
          ctx8[2]
        ]
      ]
    },
    { invalid: (
      /*_invalid*/
      ctx8[15]
    ) },
    {
      showRightSection: (
        /*_showRightSection*/
        ctx8[17]
      )
    },
    { root: "textarea" },
    { multiline: true }
  ];
  function input_value_binding(value) {
    ctx8[22](value);
  }
  let input_props = {
    $$slots: { rightSection: [create_rightSection_slot] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < input_spread_levels.length; i2 += 1) {
    input_props = assign(input_props, input_spread_levels[i2]);
  }
  if (
    /*value*/
    ctx8[1] !== void 0
  ) {
    input_props.value = /*value*/
    ctx8[1];
  }
  input = new Input_default({ props: input_props, $$inline: true });
  binding_callbacks.push(() => bind(input, "value", input_value_binding));
  const block = {
    c: function create() {
      create_component(input.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(input.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(input, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const input_changes = dirty & /*required, id, placeholder, $$restProps, forwardEvents, use, _invalid, _showRightSection*/
      512260 ? get_spread_update(input_spread_levels, [
        dirty & /*required*/
        256 && { required: (
          /*required*/
          ctx9[8]
        ) },
        dirty & /*id*/
        4096 && { id: (
          /*id*/
          ctx9[12]
        ) },
        dirty & /*placeholder*/
        16384 && { placeholder: (
          /*placeholder*/
          ctx9[14]
        ) },
        dirty & /*$$restProps*/
        262144 && get_spread_object(
          /*$$restProps*/
          ctx9[18]
        ),
        dirty & /*forwardEvents, use*/
        65540 && {
          use: [
            /*forwardEvents*/
            ctx9[16],
            [
              useActions,
              /*use*/
              ctx9[2]
            ]
          ]
        },
        dirty & /*_invalid*/
        32768 && { invalid: (
          /*_invalid*/
          ctx9[15]
        ) },
        dirty & /*_showRightSection*/
        131072 && {
          showRightSection: (
            /*_showRightSection*/
            ctx9[17]
          )
        },
        input_spread_levels[7],
        input_spread_levels[8]
      ]) : {};
      if (dirty & /*$$scope*/
      16777216) {
        input_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_value && dirty & /*value*/
      2) {
        updating_value = true;
        input_changes.value = /*value*/
        ctx9[1];
        add_flush_callback(() => updating_value = false);
      }
      input.$set(input_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(input.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(input.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(input, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot49.name,
    type: "slot",
    source: "(33:0) <InputWrapper  bind:element  class={className}  {override}  {label}  {description}  {error}  {required}  {labelProps}  {descriptionProps}  {errorProps}  {id}  {labelElement} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment67(ctx8) {
  let inputwrapper;
  let updating_element;
  let current;
  function inputwrapper_element_binding(value) {
    ctx8[23](value);
  }
  let inputwrapper_props = {
    class: (
      /*className*/
      ctx8[3]
    ),
    override: (
      /*override*/
      ctx8[4]
    ),
    label: (
      /*label*/
      ctx8[5]
    ),
    description: (
      /*description*/
      ctx8[6]
    ),
    error: (
      /*error*/
      ctx8[7]
    ),
    required: (
      /*required*/
      ctx8[8]
    ),
    labelProps: (
      /*labelProps*/
      ctx8[9]
    ),
    descriptionProps: (
      /*descriptionProps*/
      ctx8[10]
    ),
    errorProps: (
      /*errorProps*/
      ctx8[11]
    ),
    id: (
      /*id*/
      ctx8[12]
    ),
    labelElement: (
      /*labelElement*/
      ctx8[13]
    ),
    $$slots: { default: [create_default_slot49] },
    $$scope: { ctx: ctx8 }
  };
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    inputwrapper_props.element = /*element*/
    ctx8[0];
  }
  inputwrapper = new InputWrapper_default({
    props: inputwrapper_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(inputwrapper, "element", inputwrapper_element_binding));
  const block = {
    c: function create() {
      create_component(inputwrapper.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(inputwrapper.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(inputwrapper, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const inputwrapper_changes = {};
      if (dirty & /*className*/
      8)
        inputwrapper_changes.class = /*className*/
        ctx9[3];
      if (dirty & /*override*/
      16)
        inputwrapper_changes.override = /*override*/
        ctx9[4];
      if (dirty & /*label*/
      32)
        inputwrapper_changes.label = /*label*/
        ctx9[5];
      if (dirty & /*description*/
      64)
        inputwrapper_changes.description = /*description*/
        ctx9[6];
      if (dirty & /*error*/
      128)
        inputwrapper_changes.error = /*error*/
        ctx9[7];
      if (dirty & /*required*/
      256)
        inputwrapper_changes.required = /*required*/
        ctx9[8];
      if (dirty & /*labelProps*/
      512)
        inputwrapper_changes.labelProps = /*labelProps*/
        ctx9[9];
      if (dirty & /*descriptionProps*/
      1024)
        inputwrapper_changes.descriptionProps = /*descriptionProps*/
        ctx9[10];
      if (dirty & /*errorProps*/
      2048)
        inputwrapper_changes.errorProps = /*errorProps*/
        ctx9[11];
      if (dirty & /*id*/
      4096)
        inputwrapper_changes.id = /*id*/
        ctx9[12];
      if (dirty & /*labelElement*/
      8192)
        inputwrapper_changes.labelElement = /*labelElement*/
        ctx9[13];
      if (dirty & /*$$scope, required, id, placeholder, $$restProps, use, _invalid, value*/
      17092870) {
        inputwrapper_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        inputwrapper_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      inputwrapper.$set(inputwrapper_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(inputwrapper.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(inputwrapper.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(inputwrapper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment67.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance67($$self, $$props, $$invalidate) {
  let _invalid;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "label",
    "description",
    "error",
    "required",
    "labelProps",
    "descriptionProps",
    "errorProps",
    "invalid",
    "id",
    "labelElement",
    "showRightSection",
    "value",
    "placeholder"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Textarea", slots, ["rightSection"]);
  const $$slots = compute_slots(slots);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, label = "", description = null, error = null, required = false, labelProps = {}, descriptionProps = {}, errorProps = {}, invalid = false, id = randomID("textarea"), labelElement = "label", showRightSection = void 0, value = "", placeholder = "" } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  const _showRightSection = showRightSection === void 0 ? !!$$slots.rightSection : showRightSection;
  function input_value_binding(value$1) {
    value = value$1;
    $$invalidate(1, value);
  }
  function inputwrapper_element_binding(value2) {
    element2 = value2;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(18, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(4, override = $$new_props.override);
    if ("label" in $$new_props)
      $$invalidate(5, label = $$new_props.label);
    if ("description" in $$new_props)
      $$invalidate(6, description = $$new_props.description);
    if ("error" in $$new_props)
      $$invalidate(7, error = $$new_props.error);
    if ("required" in $$new_props)
      $$invalidate(8, required = $$new_props.required);
    if ("labelProps" in $$new_props)
      $$invalidate(9, labelProps = $$new_props.labelProps);
    if ("descriptionProps" in $$new_props)
      $$invalidate(10, descriptionProps = $$new_props.descriptionProps);
    if ("errorProps" in $$new_props)
      $$invalidate(11, errorProps = $$new_props.errorProps);
    if ("invalid" in $$new_props)
      $$invalidate(19, invalid = $$new_props.invalid);
    if ("id" in $$new_props)
      $$invalidate(12, id = $$new_props.id);
    if ("labelElement" in $$new_props)
      $$invalidate(13, labelElement = $$new_props.labelElement);
    if ("showRightSection" in $$new_props)
      $$invalidate(20, showRightSection = $$new_props.showRightSection);
    if ("value" in $$new_props)
      $$invalidate(1, value = $$new_props.value);
    if ("placeholder" in $$new_props)
      $$invalidate(14, placeholder = $$new_props.placeholder);
    if ("$$scope" in $$new_props)
      $$invalidate(24, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    get_current_component,
    createEventForwarder,
    useActions,
    randomID,
    Input: Input_default,
    InputWrapper: InputWrapper_default,
    use,
    element: element2,
    className,
    override,
    label,
    description,
    error,
    required,
    labelProps,
    descriptionProps,
    errorProps,
    invalid,
    id,
    labelElement,
    showRightSection,
    value,
    placeholder,
    forwardEvents,
    _showRightSection,
    _invalid
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(4, override = $$new_props.override);
    if ("label" in $$props)
      $$invalidate(5, label = $$new_props.label);
    if ("description" in $$props)
      $$invalidate(6, description = $$new_props.description);
    if ("error" in $$props)
      $$invalidate(7, error = $$new_props.error);
    if ("required" in $$props)
      $$invalidate(8, required = $$new_props.required);
    if ("labelProps" in $$props)
      $$invalidate(9, labelProps = $$new_props.labelProps);
    if ("descriptionProps" in $$props)
      $$invalidate(10, descriptionProps = $$new_props.descriptionProps);
    if ("errorProps" in $$props)
      $$invalidate(11, errorProps = $$new_props.errorProps);
    if ("invalid" in $$props)
      $$invalidate(19, invalid = $$new_props.invalid);
    if ("id" in $$props)
      $$invalidate(12, id = $$new_props.id);
    if ("labelElement" in $$props)
      $$invalidate(13, labelElement = $$new_props.labelElement);
    if ("showRightSection" in $$props)
      $$invalidate(20, showRightSection = $$new_props.showRightSection);
    if ("value" in $$props)
      $$invalidate(1, value = $$new_props.value);
    if ("placeholder" in $$props)
      $$invalidate(14, placeholder = $$new_props.placeholder);
    if ("_invalid" in $$props)
      $$invalidate(15, _invalid = $$new_props._invalid);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*invalid, error*/
    524416) {
      $:
        $$invalidate(15, _invalid = invalid || !!error);
    }
  };
  return [
    element2,
    value,
    use,
    className,
    override,
    label,
    description,
    error,
    required,
    labelProps,
    descriptionProps,
    errorProps,
    id,
    labelElement,
    placeholder,
    _invalid,
    forwardEvents,
    _showRightSection,
    $$restProps,
    invalid,
    showRightSection,
    slots,
    input_value_binding,
    inputwrapper_element_binding,
    $$scope
  ];
}
var Textarea = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance67, create_fragment67, safe_not_equal, {
      use: 2,
      element: 0,
      class: 3,
      override: 4,
      label: 5,
      description: 6,
      error: 7,
      required: 8,
      labelProps: 9,
      descriptionProps: 10,
      errorProps: 11,
      invalid: 19,
      id: 12,
      labelElement: 13,
      showRightSection: 20,
      value: 1,
      placeholder: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Textarea",
      options,
      id: create_fragment67.name
    });
  }
  get use() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get description() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set description(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelProps() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelProps(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get descriptionProps() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set descriptionProps(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get errorProps() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set errorProps(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelElement() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelElement(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showRightSection() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showRightSection(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Textarea_default = Textarea;

// node_modules/@svelteuidev/core/dist/components/JsonInput/validate-json/validate-json.js
function validateJson(value, deserialize) {
  if (!value || typeof value === "string" && value.trim().length === 0) {
    return true;
  }
  try {
    deserialize(value);
    return true;
  } catch (e) {
    return false;
  }
}

// node_modules/@svelteuidev/core/dist/components/JsonInput/JsonInput.svelte
var get_rightSection_slot_changes4 = (dirty) => ({});
var get_rightSection_slot_context4 = (ctx8) => ({ slot: "rightSection" });
function create_rightSection_slot2(ctx8) {
  let current;
  const rightSection_slot_template = (
    /*#slots*/
    ctx8[13].rightSection
  );
  const rightSection_slot = create_slot(
    rightSection_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[15],
    get_rightSection_slot_context4
  );
  const block = {
    c: function create() {
      if (rightSection_slot)
        rightSection_slot.c();
    },
    l: function claim(nodes) {
      if (rightSection_slot)
        rightSection_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (rightSection_slot) {
        rightSection_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (rightSection_slot) {
        if (rightSection_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            rightSection_slot,
            rightSection_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[15]
            ) : get_slot_changes(
              rightSection_slot_template,
              /*$$scope*/
              ctx9[15],
              dirty,
              get_rightSection_slot_changes4
            ),
            get_rightSection_slot_context4
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rightSection_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rightSection_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (rightSection_slot)
        rightSection_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_rightSection_slot2.name,
    type: "slot",
    source: "(39:1) ",
    ctx: ctx8
  });
  return block;
}
function create_fragment68(ctx8) {
  let textarea;
  let updating_value;
  let current;
  const textarea_spread_levels = [
    { invalid: !/*valid*/
    ctx8[4] },
    {
      error: !/*valid*/
      ctx8[4] ? (
        /*validationError*/
        ctx8[1]
      ) : (
        /*error*/
        ctx8[0]
      )
    },
    { rows: (
      /*rows*/
      ctx8[2]
    ) },
    /*$$restProps*/
    ctx8[6]
  ];
  function textarea_value_binding(value) {
    ctx8[14](value);
  }
  let textarea_props = {
    $$slots: { rightSection: [create_rightSection_slot2] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < textarea_spread_levels.length; i2 += 1) {
    textarea_props = assign(textarea_props, textarea_spread_levels[i2]);
  }
  if (
    /*_value*/
    ctx8[3] !== void 0
  ) {
    textarea_props.value = /*_value*/
    ctx8[3];
  }
  textarea = new Textarea_default({ props: textarea_props, $$inline: true });
  binding_callbacks.push(() => bind(textarea, "value", textarea_value_binding));
  textarea.$on(
    "blur",
    /*handleBlur*/
    ctx8[5]
  );
  const block = {
    c: function create() {
      create_component(textarea.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(textarea.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(textarea, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const textarea_changes = dirty & /*valid, validationError, error, rows, $$restProps*/
      87 ? get_spread_update(textarea_spread_levels, [
        dirty & /*valid*/
        16 && { invalid: !/*valid*/
        ctx9[4] },
        dirty & /*valid, validationError, error*/
        19 && {
          error: !/*valid*/
          ctx9[4] ? (
            /*validationError*/
            ctx9[1]
          ) : (
            /*error*/
            ctx9[0]
          )
        },
        dirty & /*rows*/
        4 && { rows: (
          /*rows*/
          ctx9[2]
        ) },
        dirty & /*$$restProps*/
        64 && get_spread_object(
          /*$$restProps*/
          ctx9[6]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      32768) {
        textarea_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_value && dirty & /*_value*/
      8) {
        updating_value = true;
        textarea_changes.value = /*_value*/
        ctx9[3];
        add_flush_callback(() => updating_value = false);
      }
      textarea.$set(textarea_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(textarea.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(textarea.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(textarea, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment68.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance68($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "formatOnBlur",
    "error",
    "validationError",
    "onBlur",
    "readOnly",
    "value",
    "rows",
    "serialize",
    "deserialize"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("JsonInput", slots, ["rightSection"]);
  let { formatOnBlur = false, error = null, validationError = null, onBlur = void 0, readOnly = void 0, value = void 0, rows = 4, serialize = JSON.stringify, deserialize = JSON.parse } = $$props;
  let _value = value;
  let valid = validateJson(_value, deserialize);
  const handleBlur = (event) => {
    onBlur == null ? void 0 : onBlur(event);
    $$invalidate(4, valid = validateJson(event.currentTarget.value, deserialize));
    if (formatOnBlur && !readOnly && valid && event.currentTarget.value.trim() !== "") {
      $$invalidate(3, _value = serialize(deserialize(event.currentTarget.value), null, 2));
    }
  };
  function textarea_value_binding(value2) {
    _value = value2;
    $$invalidate(3, _value);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("formatOnBlur" in $$new_props)
      $$invalidate(7, formatOnBlur = $$new_props.formatOnBlur);
    if ("error" in $$new_props)
      $$invalidate(0, error = $$new_props.error);
    if ("validationError" in $$new_props)
      $$invalidate(1, validationError = $$new_props.validationError);
    if ("onBlur" in $$new_props)
      $$invalidate(8, onBlur = $$new_props.onBlur);
    if ("readOnly" in $$new_props)
      $$invalidate(9, readOnly = $$new_props.readOnly);
    if ("value" in $$new_props)
      $$invalidate(10, value = $$new_props.value);
    if ("rows" in $$new_props)
      $$invalidate(2, rows = $$new_props.rows);
    if ("serialize" in $$new_props)
      $$invalidate(11, serialize = $$new_props.serialize);
    if ("deserialize" in $$new_props)
      $$invalidate(12, deserialize = $$new_props.deserialize);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Textarea: Textarea_default,
    validateJson,
    formatOnBlur,
    error,
    validationError,
    onBlur,
    readOnly,
    value,
    rows,
    serialize,
    deserialize,
    _value,
    valid,
    handleBlur
  });
  $$self.$inject_state = ($$new_props) => {
    if ("formatOnBlur" in $$props)
      $$invalidate(7, formatOnBlur = $$new_props.formatOnBlur);
    if ("error" in $$props)
      $$invalidate(0, error = $$new_props.error);
    if ("validationError" in $$props)
      $$invalidate(1, validationError = $$new_props.validationError);
    if ("onBlur" in $$props)
      $$invalidate(8, onBlur = $$new_props.onBlur);
    if ("readOnly" in $$props)
      $$invalidate(9, readOnly = $$new_props.readOnly);
    if ("value" in $$props)
      $$invalidate(10, value = $$new_props.value);
    if ("rows" in $$props)
      $$invalidate(2, rows = $$new_props.rows);
    if ("serialize" in $$props)
      $$invalidate(11, serialize = $$new_props.serialize);
    if ("deserialize" in $$props)
      $$invalidate(12, deserialize = $$new_props.deserialize);
    if ("_value" in $$props)
      $$invalidate(3, _value = $$new_props._value);
    if ("valid" in $$props)
      $$invalidate(4, valid = $$new_props.valid);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    error,
    validationError,
    rows,
    _value,
    valid,
    handleBlur,
    $$restProps,
    formatOnBlur,
    onBlur,
    readOnly,
    value,
    serialize,
    deserialize,
    slots,
    textarea_value_binding,
    $$scope
  ];
}
var JsonInput = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance68, create_fragment68, safe_not_equal, {
      formatOnBlur: 7,
      error: 0,
      validationError: 1,
      onBlur: 8,
      readOnly: 9,
      value: 10,
      rows: 2,
      serialize: 11,
      deserialize: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "JsonInput",
      options,
      id: create_fragment68.name
    });
  }
  get formatOnBlur() {
    throw new Error("<JsonInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set formatOnBlur(value) {
    throw new Error("<JsonInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<JsonInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value) {
    throw new Error("<JsonInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validationError() {
    throw new Error("<JsonInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validationError(value) {
    throw new Error("<JsonInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onBlur() {
    throw new Error("<JsonInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onBlur(value) {
    throw new Error("<JsonInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readOnly() {
    throw new Error("<JsonInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readOnly(value) {
    throw new Error("<JsonInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<JsonInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<JsonInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rows() {
    throw new Error("<JsonInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rows(value) {
    throw new Error("<JsonInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get serialize() {
    throw new Error("<JsonInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set serialize(value) {
    throw new Error("<JsonInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get deserialize() {
    throw new Error("<JsonInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set deserialize(value) {
    throw new Error("<JsonInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var JsonInput_default = JsonInput;

// node_modules/@svelteuidev/core/dist/components/Kbd/Kbd.styles.js
var Kbd_styles_default = createStyles((theme4) => {
  return {
    root: {
      [`${theme4.dark} &`]: {
        bc: theme4.fn.themeColor("dark", 4),
        color: theme4.fn.themeColor("dark", 0),
        border: `1px solid ${theme4.fn.themeColor("dark", 9)}`,
        borderBottom: `3px solid ${theme4.fn.themeColor("dark", 9)}`
      },
      lineHeight: theme4.lineHeights.md.value,
      fontFamily: theme4.fonts.mono.value,
      fontSize: theme4.fontSizes.xs.value,
      fontWeight: 700,
      backgroundColor: theme4.fn.themeColor("gray", 0),
      color: theme4.fn.themeColor("gray", 7),
      padding: `3px ${+theme4.space.xs.value / 2}px`,
      borderRadius: theme4.radii.sm.value,
      border: `1px solid ${theme4.fn.themeColor("gray", 3)}`,
      borderBottom: `3px solid ${theme4.fn.themeColor("gray", 3)}`
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Kbd/Kbd.svelte
function create_default_slot50(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[10],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[10],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot50.name,
    type: "slot",
    source: '(8:0) <Box  bind:element  root=\\"kbd\\"  class={cx(className, classes.root, getStyles({ css: override }))}  {use}  {...$$restProps} >',
    ctx: ctx8
  });
  return block;
}
function create_fragment69(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { root: "kbd" },
    {
      class: (
        /*cx*/
        ctx8[6](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[5].root,
          /*getStyles*/
          ctx8[4]({ css: (
            /*override*/
            ctx8[3]
          ) })
        )
      )
    },
    { use: (
      /*use*/
      ctx8[1]
    ) },
    /*$$restProps*/
    ctx8[7]
  ];
  function box_element_binding(value) {
    ctx8[9](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot50] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*cx, className, classes, getStyles, override, use, $$restProps*/
      254 ? get_spread_update(box_spread_levels, [
        box_spread_levels[0],
        dirty & /*cx, className, classes, getStyles, override*/
        124 && {
          class: (
            /*cx*/
            ctx9[6](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[5].root,
              /*getStyles*/
              ctx9[4]({ css: (
                /*override*/
                ctx9[3]
              ) })
            )
          )
        },
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*$$restProps*/
        128 && get_spread_object(
          /*$$restProps*/
          ctx9[7]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      1024) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment69.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance69($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = ["use", "element", "class", "override"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Kbd", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {} } = $$props;
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: Kbd_styles_default,
    Box: Box_default,
    use,
    element: element2,
    className,
    override,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("getStyles" in $$props)
      $$invalidate(4, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(5, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(6, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $:
    $$invalidate(6, { cx: cx2, classes, getStyles } = Kbd_styles_default(null, { name: "Kbd" }), cx2, $$invalidate(5, classes), $$invalidate(4, getStyles));
  return [
    element2,
    use,
    className,
    override,
    getStyles,
    classes,
    cx2,
    $$restProps,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Kbd = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance69, create_fragment69, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Kbd",
      options,
      id: create_fragment69.name
    });
  }
  get use() {
    throw new Error("<Kbd>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Kbd>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Kbd>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Kbd>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Kbd>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Kbd>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Kbd>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Kbd>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Kbd_default = Kbd;

// node_modules/@svelteuidev/core/dist/components/Mark/Mark.styles.js
var Mark_styles_default = createStyles((theme4, { color }) => {
  return {
    root: {
      backgroundColor: theme4.fn.themeColor(color, 2),
      darkMode: {
        backgroundColor: theme4.fn.themeColor(color, 5),
        color: theme4.colors.dark900.value
      }
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Mark/Mark.svelte
function create_default_slot51(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[10],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[10],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot51.name,
    type: "slot",
    source: "(20:0) <Text bind:element class={cx(className, classes.root)} {root} {...$$restProps}>",
    ctx: ctx8
  });
  return block;
}
function create_fragment70(ctx8) {
  let text_1;
  let updating_element;
  let current;
  const text_1_spread_levels = [
    {
      class: (
        /*cx*/
        ctx8[4](
          /*className*/
          ctx8[1],
          /*classes*/
          ctx8[3].root
        )
      )
    },
    { root: (
      /*root*/
      ctx8[2]
    ) },
    /*$$restProps*/
    ctx8[5]
  ];
  function text_1_element_binding(value) {
    ctx8[9](value);
  }
  let text_1_props = {
    $$slots: { default: [create_default_slot51] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < text_1_spread_levels.length; i2 += 1) {
    text_1_props = assign(text_1_props, text_1_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    text_1_props.element = /*element*/
    ctx8[0];
  }
  text_1 = new Text_default({ props: text_1_props, $$inline: true });
  binding_callbacks.push(() => bind(text_1, "element", text_1_element_binding));
  const block = {
    c: function create() {
      create_component(text_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(text_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(text_1, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const text_1_changes = dirty & /*cx, className, classes, root, $$restProps*/
      62 ? get_spread_update(text_1_spread_levels, [
        dirty & /*cx, className, classes*/
        26 && {
          class: (
            /*cx*/
            ctx9[4](
              /*className*/
              ctx9[1],
              /*classes*/
              ctx9[3].root
            )
          )
        },
        dirty & /*root*/
        4 && { root: (
          /*root*/
          ctx9[2]
        ) },
        dirty & /*$$restProps*/
        32 && get_spread_object(
          /*$$restProps*/
          ctx9[5]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      1024) {
        text_1_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        text_1_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      text_1.$set(text_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(text_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment70.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance70($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  const omit_props_names = ["element", "class", "override", "root", "color"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Mark", slots, ["default"]);
  let { element: element2 = void 0, class: className = "", override = {}, root = "mark", color = "yellow" } = $$props;
  function text_1_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(6, override = $$new_props.override);
    if ("root" in $$new_props)
      $$invalidate(2, root = $$new_props.root);
    if ("color" in $$new_props)
      $$invalidate(7, color = $$new_props.color);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: Mark_styles_default,
    Text: Text_default,
    element: element2,
    className,
    override,
    root,
    color,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(6, override = $$new_props.override);
    if ("root" in $$props)
      $$invalidate(2, root = $$new_props.root);
    if ("color" in $$props)
      $$invalidate(7, color = $$new_props.color);
    if ("classes" in $$props)
      $$invalidate(3, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(4, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*color, override*/
    192) {
      $:
        $$invalidate(4, { cx: cx2, classes } = Mark_styles_default({ color }, { override, name: "Mark" }), cx2, ($$invalidate(3, classes), $$invalidate(7, color), $$invalidate(6, override)));
    }
  };
  return [
    element2,
    className,
    root,
    classes,
    cx2,
    $$restProps,
    override,
    color,
    slots,
    text_1_element_binding,
    $$scope
  ];
}
var Mark = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance70, create_fragment70, safe_not_equal, {
      element: 0,
      class: 1,
      override: 6,
      root: 2,
      color: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Mark",
      options,
      id: create_fragment70.name
    });
  }
  get element() {
    throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get root() {
    throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set root(value) {
    throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Mark>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Mark>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Mark_default = Mark;

// node_modules/@svelteuidev/core/dist/components/MediaQuery/MediaQuery.styles.js
var MediaQuery_styles_default = createStyles((theme4, { query, styles, largerThan, smallerThan }) => {
  const media = { root: {} };
  const minWidth = theme4.fn.size({ size: largerThan, sizes: theme4.breakpoints }) + 1;
  const maxWidth = theme4.fn.size({ size: smallerThan, sizes: theme4.breakpoints });
  if (largerThan !== void 0 && smallerThan !== void 0) {
    media.root[`@media (min-width: ${minWidth}px) and (max-width: ${maxWidth}px)`] = styles;
  } else {
    if (largerThan !== void 0) {
      media.root[`@media (min-width: ${theme4.fn.size({ size: largerThan, sizes: theme4.breakpoints }) + 1}px)`] = styles;
    }
    if (smallerThan !== void 0) {
      media.root[`@media (max-width: ${theme4.fn.size({ size: smallerThan, sizes: theme4.breakpoints })}px)`] = styles;
    }
  }
  if (query) {
    media.root[`@media ${query}`] = styles;
  }
  return media;
});

// node_modules/@svelteuidev/core/dist/components/MediaQuery/MediaQuery.svelte
function create_default_slot52(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[13],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[13],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot52.name,
    type: "slot",
    source: "(13:0) <Box {use} bind:element class={cx(className, classes.root, getStyles({ css: override }))}>",
    ctx: ctx8
  });
  return block;
}
function create_fragment71(ctx8) {
  let box;
  let updating_element;
  let current;
  function box_element_binding(value) {
    ctx8[12](value);
  }
  let box_props = {
    use: (
      /*use*/
      ctx8[1]
    ),
    class: (
      /*cx*/
      ctx8[6](
        /*className*/
        ctx8[2],
        /*classes*/
        ctx8[5].root,
        /*getStyles*/
        ctx8[4]({ css: (
          /*override*/
          ctx8[3]
        ) })
      )
    ),
    $$slots: { default: [create_default_slot52] },
    $$scope: { ctx: ctx8 }
  };
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = {};
      if (dirty & /*use*/
      2)
        box_changes.use = /*use*/
        ctx9[1];
      if (dirty & /*cx, className, classes, getStyles, override*/
      124)
        box_changes.class = /*cx*/
        ctx9[6](
          /*className*/
          ctx9[2],
          /*classes*/
          ctx9[5].root,
          /*getStyles*/
          ctx9[4]({ css: (
            /*override*/
            ctx9[3]
          ) })
        );
      if (dirty & /*$$scope*/
      8192) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment71.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance71($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MediaQuery", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, smallerThan = void 0, largerThan = void 0, styles = void 0, query = void 0 } = $$props;
  function styleChildElement() {
    element2.children[0].classList.add(getStyles().selector);
  }
  onMount(styleChildElement);
  const writable_props = [
    "use",
    "element",
    "class",
    "override",
    "smallerThan",
    "largerThan",
    "styles",
    "query"
  ];
  Object.keys($$props).forEach((key3) => {
    if (!~writable_props.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<MediaQuery> was created with unknown prop '${key3}'`);
  });
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$props2) => {
    if ("use" in $$props2)
      $$invalidate(1, use = $$props2.use);
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("class" in $$props2)
      $$invalidate(2, className = $$props2.class);
    if ("override" in $$props2)
      $$invalidate(3, override = $$props2.override);
    if ("smallerThan" in $$props2)
      $$invalidate(7, smallerThan = $$props2.smallerThan);
    if ("largerThan" in $$props2)
      $$invalidate(8, largerThan = $$props2.largerThan);
    if ("styles" in $$props2)
      $$invalidate(9, styles = $$props2.styles);
    if ("query" in $$props2)
      $$invalidate(10, query = $$props2.query);
    if ("$$scope" in $$props2)
      $$invalidate(13, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    Box: Box_default,
    useStyles: MediaQuery_styles_default,
    use,
    element: element2,
    className,
    override,
    smallerThan,
    largerThan,
    styles,
    query,
    styleChildElement,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$props2) => {
    if ("use" in $$props2)
      $$invalidate(1, use = $$props2.use);
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("className" in $$props2)
      $$invalidate(2, className = $$props2.className);
    if ("override" in $$props2)
      $$invalidate(3, override = $$props2.override);
    if ("smallerThan" in $$props2)
      $$invalidate(7, smallerThan = $$props2.smallerThan);
    if ("largerThan" in $$props2)
      $$invalidate(8, largerThan = $$props2.largerThan);
    if ("styles" in $$props2)
      $$invalidate(9, styles = $$props2.styles);
    if ("query" in $$props2)
      $$invalidate(10, query = $$props2.query);
    if ("getStyles" in $$props2)
      $$invalidate(4, getStyles = $$props2.getStyles);
    if ("classes" in $$props2)
      $$invalidate(5, classes = $$props2.classes);
    if ("cx" in $$props2)
      $$invalidate(6, cx2 = $$props2.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*query, styles, largerThan, smallerThan*/
    1920) {
      $:
        $$invalidate(6, { cx: cx2, classes, getStyles } = MediaQuery_styles_default({ query, styles, largerThan, smallerThan }, { name: "MediaQuery" }), cx2, ($$invalidate(5, classes), $$invalidate(10, query), $$invalidate(9, styles), $$invalidate(8, largerThan), $$invalidate(7, smallerThan)), ($$invalidate(4, getStyles), $$invalidate(10, query), $$invalidate(9, styles), $$invalidate(8, largerThan), $$invalidate(7, smallerThan)));
    }
  };
  return [
    element2,
    use,
    className,
    override,
    getStyles,
    classes,
    cx2,
    smallerThan,
    largerThan,
    styles,
    query,
    slots,
    box_element_binding,
    $$scope
  ];
}
var MediaQuery = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance71, create_fragment71, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      smallerThan: 7,
      largerThan: 8,
      styles: 9,
      query: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MediaQuery",
      options,
      id: create_fragment71.name
    });
  }
  get use() {
    throw new Error("<MediaQuery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<MediaQuery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<MediaQuery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<MediaQuery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MediaQuery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MediaQuery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<MediaQuery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<MediaQuery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get smallerThan() {
    throw new Error("<MediaQuery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set smallerThan(value) {
    throw new Error("<MediaQuery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get largerThan() {
    throw new Error("<MediaQuery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set largerThan(value) {
    throw new Error("<MediaQuery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get styles() {
    throw new Error("<MediaQuery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set styles(value) {
    throw new Error("<MediaQuery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get query() {
    throw new Error("<MediaQuery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set query(value) {
    throw new Error("<MediaQuery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MediaQuery_default = MediaQuery;

// node_modules/@svelteuidev/core/dist/components/Menu/Menu.styles.js
var sizes10 = {
  xs: 120,
  sm: 160,
  md: 200,
  lg: 240,
  xl: 300
};
var MENU_PADDING = 4;
function getNextItem(active, items) {
  for (let i2 = active + 1; i2 < items.length; i2 += 1) {
    if (!items[i2].disabled) {
      return i2;
    }
  }
  return active;
}
function findInitialItem(items) {
  for (let i2 = 0; i2 < items.length; i2 += 1) {
    if (!items[i2].disabled) {
      return i2;
    }
  }
  return -1;
}
function getPreviousItem(active, items) {
  for (let i2 = active - 1; i2 >= 0; i2 -= 1) {
    if (!items[i2].disabled) {
      return i2;
    }
  }
  if (!items[active]) {
    return findInitialItem(items);
  }
  return active;
}
var Menu_styles_default = createStyles((theme4, { size: size3 }) => ({
  root: {
    display: "inline-block",
    position: "relative"
  },
  arrow: {
    darkMode: {
      borderColor: theme4.fn.themeColor("dark", 6),
      background: theme4.fn.themeColor("dark", 6)
    },
    borderColor: theme4.fn.themeColor("gray", 2),
    background: theme4.colors.white.value
  },
  body: {
    darkMode: {
      border: `1px solid ${theme4.fn.themeColor("dark", 6)}`,
      backgroundColor: theme4.fn.themeColor("dark", 6),
      "& .svelteui-Divider-horizontal": {
        borderTopColor: theme4.fn.themeColor("dark", 7)
      }
    },
    width: theme4.fn.size({ size: size3, sizes: sizes10 }),
    overflow: "hidden",
    pointerEvents: "all",
    border: `1px solid ${theme4.fn.themeColor("gray", 2)}`,
    backgroundColor: theme4.colors.white.value,
    padding: MENU_PADDING,
    "& .svelteui-Divider-horizontal": {
      margin: `${parseInt(theme4.space.xs.value) / 2}px -${MENU_PADDING}px`,
      borderTopColor: theme4.fn.themeColor("gray", 2)
    }
  },
  label: {
    darkMode: {
      color: theme4.fn.themeColor("dark", 2)
    },
    color: theme4.fn.themeColor("gray", 2),
    fontWeight: 500,
    fontSize: theme4.fontSizes.xs,
    fontFamily: theme4.fonts.standard.value,
    padding: `${parseInt(theme4.space.xs.value) / 2}px ${parseInt(theme4.space.sm.value)}px`,
    cursor: "default"
  }
}));

// node_modules/@svelteuidev/core/dist/components/Popper/Popper.styles.js
function calculateArrowPlacement(arrowSize, arrowDistance, position, placement) {
  switch (position) {
    case "top":
      return {
        top: "unset",
        bottom: `${-1 * arrowSize}px`,
        left: placement === "start" ? `${arrowSize * arrowDistance}px` : "unset",
        right: placement === "start" ? "unset" : `${arrowSize * arrowDistance}px`
      };
    case "bottom":
      return {
        top: `${-1 * arrowSize}px`,
        bottom: "unset",
        left: placement === "start" ? `${arrowSize * arrowDistance}px` : "unset",
        right: placement === "start" ? "unset" : `${arrowSize * arrowDistance}px`
      };
    case "left":
      return {
        right: `${-1 * arrowSize}px`,
        left: "unset",
        top: placement === "start" ? `${arrowSize * arrowDistance}px` : "unset",
        bottom: placement === "start" ? "unset" : `${arrowSize * arrowDistance}px`
      };
    case "right":
      return {
        right: "unset",
        left: `${-1 * arrowSize}px`,
        top: placement === "start" ? `${arrowSize * arrowDistance}px` : "unset",
        bottom: placement === "start" ? "unset" : `${arrowSize * arrowDistance}px`
      };
  }
}
var Popper_styles_default = createStyles((_, { arrowSize, zIndex }) => {
  return {
    root: {
      position: "absolute",
      zIndex
    },
    arrowStyles: {
      width: arrowSize * 2,
      height: arrowSize * 2,
      position: "absolute",
      transform: "rotate(45deg)",
      border: "1px solid transparent",
      zIndex
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Popper/Popper.svelte
var file31 = "node_modules/@svelteuidev/core/dist/components/Popper/Popper.svelte";
function create_if_block25(ctx8) {
  let div;
  let t;
  let div_class_value;
  let useActions_action;
  let forwardEvents_action;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*withArrow*/
    ctx8[5] && create_if_block_115(ctx8)
  );
  const default_slot_template = (
    /*#slots*/
    ctx8[27].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[26],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      t = claim_space(div_nodes);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*cx*/
      ctx8[11](
        /*className*/
        ctx8[2],
        /*classes*/
        ctx8[10].root,
        /*getStyles*/
        ctx8[9]({ css: (
          /*override*/
          ctx8[3]
        ) })
      ));
      add_location(div, file31, 101, 1, 3824);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append_hydration_dev(div, t);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx8[29](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div,
            /*use*/
            ctx8[1]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx8[15].call(null, div))
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx8 = new_ctx;
      if (
        /*withArrow*/
        ctx8[5]
      ) {
        if (if_block) {
          if_block.p(ctx8, dirty);
        } else {
          if_block = create_if_block_115(ctx8);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        67108864)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx8,
            /*$$scope*/
            ctx8[26],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx8[26]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx8[26],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*cx, className, classes, getStyles, override*/
      3596 && div_class_value !== (div_class_value = /*cx*/
      ctx8[11](
        /*className*/
        ctx8[2],
        /*classes*/
        ctx8[10].root,
        /*getStyles*/
        ctx8[9]({ css: (
          /*override*/
          ctx8[3]
        ) })
      ))) {
        attr_dev(div, "class", div_class_value);
      }
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/
      2)
        useActions_action.update.call(
          null,
          /*use*/
          ctx8[1]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (div_outro)
            div_outro.end(1);
          div_intro = create_in_transition(
            div,
            /*_transition*/
            ctx8[13],
            /*transitionOptions*/
            ctx8[6]
          );
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (div_intro)
        div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(
          div,
          /*_exitTransition*/
          ctx8[12],
          /*exitTransitionOptions*/
          ctx8[7]
        );
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      ctx8[29](null);
      if (detaching && div_outro)
        div_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block25.name,
    type: "if",
    source: "(101:0) {#if _mounted}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_115(ctx8) {
  let div;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*cx*/
      ctx8[11](
        /*arrowClassName*/
        ctx8[4],
        { arrowClassName: true },
        /*classes*/
        ctx8[10].arrowStyles
      ));
      add_location(div, file31, 110, 3, 4069);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      ctx8[28](div);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*cx, arrowClassName, classes*/
      3088 && div_class_value !== (div_class_value = /*cx*/
      ctx9[11](
        /*arrowClassName*/
        ctx9[4],
        { arrowClassName: true },
        /*classes*/
        ctx9[10].arrowStyles
      ))) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      ctx8[28](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_115.name,
    type: "if",
    source: "(110:2) {#if withArrow}",
    ctx: ctx8
  });
  return block;
}
function create_fragment72(ctx8) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*_mounted*/
    ctx8[14] && create_if_block25(ctx8)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (
        /*_mounted*/
        ctx9[14]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
          if (dirty[0] & /*_mounted*/
          16384) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block25(ctx9);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment72.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance72($$self, $$props, $$invalidate) {
  let _mounted;
  let _transition;
  let _exitTransition;
  let cx2;
  let classes;
  let getStyles;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Popper", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, position = "top", placement = "center", gutter = 5, arrowSize = 3, arrowDistance = 3, arrowClassName = "arrow", withArrow = false, zIndex = 1, transition = "fade", transitionOptions = { duration: 100 }, exitTransition = transition, exitTransitionOptions = transitionOptions, mounted = false, reference = null } = $$props;
  let cleanup = () => {
  };
  let arrowElement;
  const forwardEvents = createEventForwarder(get_current_component());
  onDestroy(() => {
    cleanup();
  });
  function updatePopper(_) {
    if (!element2 || !reference)
      return;
    const _placement = placement;
    const placementString = placement !== "center" ? `${position}-${placement}` : position;
    const middleware = [offset(gutter), flip(), shift({ padding: 10 })];
    if (withArrow)
      middleware.push(arrow({
        element: arrowElement,
        padding: arrowDistance
      }));
    computePosition(reference, element2, { placement: placementString, middleware }).then(({ x, y, placement: placement2, middlewareData }) => {
      if (!element2)
        return;
      Object.assign(element2.style, { left: `${x}px`, top: `${y}px` });
      if (!withArrow)
        return;
      const { x: arrowX, y: arrowY } = middlewareData.arrow;
      const _position = placement2.split("-")[0];
      const staticSide = {
        top: "bottom",
        right: "left",
        bottom: "top",
        left: "right"
      }[_position];
      Object.assign(arrowElement.style, {
        left: arrowX != null ? `${arrowX}px` : "unset",
        top: arrowY != null ? `${arrowY}px` : "unset",
        [staticSide]: `${-1 * arrowSize}px`,
        ..._placement !== "center" ? calculateArrowPlacement(arrowSize, arrowDistance, _position, _placement) : {}
      });
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      arrowElement = $$value;
      $$invalidate(8, arrowElement);
    });
  }
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(32, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("position" in $$new_props)
      $$invalidate(16, position = $$new_props.position);
    if ("placement" in $$new_props)
      $$invalidate(17, placement = $$new_props.placement);
    if ("gutter" in $$new_props)
      $$invalidate(18, gutter = $$new_props.gutter);
    if ("arrowSize" in $$new_props)
      $$invalidate(19, arrowSize = $$new_props.arrowSize);
    if ("arrowDistance" in $$new_props)
      $$invalidate(20, arrowDistance = $$new_props.arrowDistance);
    if ("arrowClassName" in $$new_props)
      $$invalidate(4, arrowClassName = $$new_props.arrowClassName);
    if ("withArrow" in $$new_props)
      $$invalidate(5, withArrow = $$new_props.withArrow);
    if ("zIndex" in $$new_props)
      $$invalidate(21, zIndex = $$new_props.zIndex);
    if ("transition" in $$new_props)
      $$invalidate(22, transition = $$new_props.transition);
    if ("transitionOptions" in $$new_props)
      $$invalidate(6, transitionOptions = $$new_props.transitionOptions);
    if ("exitTransition" in $$new_props)
      $$invalidate(23, exitTransition = $$new_props.exitTransition);
    if ("exitTransitionOptions" in $$new_props)
      $$invalidate(7, exitTransitionOptions = $$new_props.exitTransitionOptions);
    if ("mounted" in $$new_props)
      $$invalidate(24, mounted = $$new_props.mounted);
    if ("reference" in $$new_props)
      $$invalidate(25, reference = $$new_props.reference);
    if ("$$scope" in $$new_props)
      $$invalidate(26, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: Popper_styles_default,
    calculateArrowPlacement,
    arrow,
    autoUpdate,
    computePosition,
    offset,
    flip,
    shift,
    get_current_component,
    onDestroy,
    createEventForwarder,
    getTransition,
    useActions,
    use,
    element: element2,
    className,
    override,
    position,
    placement,
    gutter,
    arrowSize,
    arrowDistance,
    arrowClassName,
    withArrow,
    zIndex,
    transition,
    transitionOptions,
    exitTransition,
    exitTransitionOptions,
    mounted,
    reference,
    cleanup,
    arrowElement,
    forwardEvents,
    updatePopper,
    getStyles,
    classes,
    cx: cx2,
    _exitTransition,
    _transition,
    _mounted
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(32, $$props = assign(assign({}, $$props), $$new_props));
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("position" in $$props)
      $$invalidate(16, position = $$new_props.position);
    if ("placement" in $$props)
      $$invalidate(17, placement = $$new_props.placement);
    if ("gutter" in $$props)
      $$invalidate(18, gutter = $$new_props.gutter);
    if ("arrowSize" in $$props)
      $$invalidate(19, arrowSize = $$new_props.arrowSize);
    if ("arrowDistance" in $$props)
      $$invalidate(20, arrowDistance = $$new_props.arrowDistance);
    if ("arrowClassName" in $$props)
      $$invalidate(4, arrowClassName = $$new_props.arrowClassName);
    if ("withArrow" in $$props)
      $$invalidate(5, withArrow = $$new_props.withArrow);
    if ("zIndex" in $$props)
      $$invalidate(21, zIndex = $$new_props.zIndex);
    if ("transition" in $$props)
      $$invalidate(22, transition = $$new_props.transition);
    if ("transitionOptions" in $$props)
      $$invalidate(6, transitionOptions = $$new_props.transitionOptions);
    if ("exitTransition" in $$props)
      $$invalidate(23, exitTransition = $$new_props.exitTransition);
    if ("exitTransitionOptions" in $$props)
      $$invalidate(7, exitTransitionOptions = $$new_props.exitTransitionOptions);
    if ("mounted" in $$props)
      $$invalidate(24, mounted = $$new_props.mounted);
    if ("reference" in $$props)
      $$invalidate(25, reference = $$new_props.reference);
    if ("cleanup" in $$props)
      cleanup = $$new_props.cleanup;
    if ("arrowElement" in $$props)
      $$invalidate(8, arrowElement = $$new_props.arrowElement);
    if ("getStyles" in $$props)
      $$invalidate(9, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(10, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(11, cx2 = $$new_props.cx);
    if ("_exitTransition" in $$props)
      $$invalidate(12, _exitTransition = $$new_props._exitTransition);
    if ("_transition" in $$props)
      $$invalidate(13, _transition = $$new_props._transition);
    if ("_mounted" in $$props)
      $$invalidate(14, _mounted = $$new_props._mounted);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $: {
      if (element2 && reference) {
        cleanup = autoUpdate(reference, element2, () => {
          updatePopper({ ...$$props });
        });
      }
    }
    if ($$self.$$.dirty[0] & /*mounted*/
    16777216) {
      $:
        $$invalidate(14, _mounted = mounted);
    }
    if ($$self.$$.dirty[0] & /*transition*/
    4194304) {
      $:
        $$invalidate(13, _transition = getTransition(transition));
    }
    if ($$self.$$.dirty[0] & /*exitTransition*/
    8388608) {
      $:
        $$invalidate(12, _exitTransition = getTransition(exitTransition));
    }
    $:
      updatePopper({ ...$$props });
    if ($$self.$$.dirty[0] & /*arrowSize, zIndex*/
    2621440) {
      $:
        $$invalidate(11, { cx: cx2, classes, getStyles } = Popper_styles_default({ arrowSize, zIndex }, { name: "Popper" }), cx2, ($$invalidate(10, classes), $$invalidate(19, arrowSize), $$invalidate(21, zIndex)), ($$invalidate(9, getStyles), $$invalidate(19, arrowSize), $$invalidate(21, zIndex)));
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    element2,
    use,
    className,
    override,
    arrowClassName,
    withArrow,
    transitionOptions,
    exitTransitionOptions,
    arrowElement,
    getStyles,
    classes,
    cx2,
    _exitTransition,
    _transition,
    _mounted,
    forwardEvents,
    position,
    placement,
    gutter,
    arrowSize,
    arrowDistance,
    zIndex,
    transition,
    exitTransition,
    mounted,
    reference,
    $$scope,
    slots,
    div_binding,
    div_binding_1
  ];
}
var Popper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance72,
      create_fragment72,
      safe_not_equal,
      {
        use: 1,
        element: 0,
        class: 2,
        override: 3,
        position: 16,
        placement: 17,
        gutter: 18,
        arrowSize: 19,
        arrowDistance: 20,
        arrowClassName: 4,
        withArrow: 5,
        zIndex: 21,
        transition: 22,
        transitionOptions: 6,
        exitTransition: 23,
        exitTransitionOptions: 7,
        mounted: 24,
        reference: 25
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Popper",
      options,
      id: create_fragment72.name
    });
  }
  get use() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placement() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placement(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gutter() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gutter(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get arrowSize() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set arrowSize(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get arrowDistance() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set arrowDistance(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get arrowClassName() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set arrowClassName(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withArrow() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withArrow(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transition() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionOptions() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionOptions(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get exitTransition() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set exitTransition(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get exitTransitionOptions() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set exitTransitionOptions(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mounted() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mounted(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get reference() {
    throw new Error("<Popper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set reference(value) {
    throw new Error("<Popper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Popper_default = Popper;

// node_modules/@svelteuidev/core/dist/components/Popper/PopperContainer/PopperContainer.svelte
var get_default_slot_changes = (dirty) => ({ ref: dirty & /*target*/
2 });
var get_default_slot_context = (ctx8) => ({ ref: (
  /*target*/
  ctx8[1]
) });
function create_else_block11(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[3],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block11.name,
    type: "else",
    source: "(10:0) {:else}",
    ctx: ctx8
  });
  return block;
}
function create_if_block26(ctx8) {
  let portal2;
  let current;
  portal2 = new Portal_default({
    props: {
      target: (
        /*target*/
        ctx8[1]
      ),
      $$slots: { default: [create_default_slot53] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(portal2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(portal2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(portal2, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const portal_changes = {};
      if (dirty & /*target*/
      2)
        portal_changes.target = /*target*/
        ctx9[1];
      if (dirty & /*$$scope, target*/
      10) {
        portal_changes.$$scope = { dirty, ctx: ctx9 };
      }
      portal2.$set(portal_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(portal2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(portal2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(portal2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block26.name,
    type: "if",
    source: "(6:0) {#if withinPortal}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot53(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[3],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, target*/
        10)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[3],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot53.name,
    type: "slot",
    source: "(7:1) <Portal {target}>",
    ctx: ctx8
  });
  return block;
}
function create_fragment73(ctx8) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block26, create_else_block11];
  const if_blocks = [];
  function select_block_type(ctx9, dirty) {
    if (
      /*withinPortal*/
      ctx9[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx8, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx8);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx9, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx9, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx9);
          if_block.c();
        } else {
          if_block.p(ctx9, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment73.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance73($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PopperContainer", slots, ["default"]);
  let { withinPortal = false } = $$props;
  let { target = "body" } = $$props;
  const writable_props = ["withinPortal", "target"];
  Object.keys($$props).forEach((key3) => {
    if (!~writable_props.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<PopperContainer> was created with unknown prop '${key3}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("withinPortal" in $$props2)
      $$invalidate(0, withinPortal = $$props2.withinPortal);
    if ("target" in $$props2)
      $$invalidate(1, target = $$props2.target);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ Portal: Portal_default, withinPortal, target });
  $$self.$inject_state = ($$props2) => {
    if ("withinPortal" in $$props2)
      $$invalidate(0, withinPortal = $$props2.withinPortal);
    if ("target" in $$props2)
      $$invalidate(1, target = $$props2.target);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [withinPortal, target, slots, $$scope];
}
var PopperContainer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance73, create_fragment73, safe_not_equal, { withinPortal: 0, target: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PopperContainer",
      options,
      id: create_fragment73.name
    });
  }
  get withinPortal() {
    throw new Error("<PopperContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withinPortal(value) {
    throw new Error("<PopperContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error("<PopperContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error("<PopperContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PopperContainer_default = PopperContainer;

// node_modules/@svelteuidev/core/dist/components/Menu/Menu.svelte
var { window: window_1 } = globals;
var get_control_slot_changes2 = (dirty) => ({});
var get_control_slot_context2 = (ctx8) => ({});
function fallback_block15(ctx8) {
  let menuicon;
  let updating_element;
  let current;
  function menuicon_element_binding(value) {
    ctx8[46](value);
  }
  let menuicon_props = {
    role: "button",
    "aria-haspopup": "menu",
    "aria-expanded": (
      /*_opened*/
      ctx8[18]
    ),
    "aria-controls": (
      /*uuid*/
      ctx8[24]
    ),
    "aria-label": (
      /*menuButtonLabel*/
      ctx8[4]
    ),
    title: (
      /*menuButtonLabel*/
      ctx8[4]
    )
  };
  if (
    /*referenceElement*/
    ctx8[19] !== void 0
  ) {
    menuicon_props.element = /*referenceElement*/
    ctx8[19];
  }
  menuicon = new MenuIcon_default({ props: menuicon_props, $$inline: true });
  binding_callbacks.push(() => bind(menuicon, "element", menuicon_element_binding));
  menuicon.$on(
    "click!stopPropagation",
    /*toggleMenu*/
    ctx8[29]
  );
  menuicon.$on(
    "keydown",
    /*keydown_handler*/
    ctx8[47]
  );
  menuicon.$on(
    "mouseenter",
    /*mouseenter_handler*/
    ctx8[48]
  );
  const block = {
    c: function create() {
      create_component(menuicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(menuicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(menuicon, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const menuicon_changes = {};
      if (dirty[0] & /*_opened*/
      262144)
        menuicon_changes["aria-expanded"] = /*_opened*/
        ctx9[18];
      if (dirty[0] & /*menuButtonLabel*/
      16)
        menuicon_changes["aria-label"] = /*menuButtonLabel*/
        ctx9[4];
      if (dirty[0] & /*menuButtonLabel*/
      16)
        menuicon_changes.title = /*menuButtonLabel*/
        ctx9[4];
      if (!updating_element && dirty[0] & /*referenceElement*/
      524288) {
        updating_element = true;
        menuicon_changes.element = /*referenceElement*/
        ctx9[19];
        add_flush_callback(() => updating_element = false);
      }
      menuicon.$set(menuicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(menuicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(menuicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(menuicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block15.name,
    type: "fallback",
    source: "(164:22)    ",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_32(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[44].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[52],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[52],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[52]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[52],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_32.name,
    type: "slot",
    source: '(192:3) <Paper     bind:element={dropdownElement}     use={[[clickoutside, clickOutsideParams]]}     id={uuid}     role=\\"menu\\"     class={cx(classes.body)}     aria-orientation=\\"vertical\\"     {radius}     on:mouseleave={() => (hovered = -1)}     {shadow}    >',
    ctx: ctx8
  });
  return block;
}
function create_default_slot_25(ctx8) {
  let paper;
  let updating_element;
  let current;
  function paper_element_binding(value) {
    ctx8[49](value);
  }
  let paper_props = {
    use: [[
      clickoutside,
      /*clickOutsideParams*/
      ctx8[23]
    ]],
    id: (
      /*uuid*/
      ctx8[24]
    ),
    role: "menu",
    class: (
      /*cx*/
      ctx8[22](
        /*classes*/
        ctx8[21].body
      )
    ),
    "aria-orientation": "vertical",
    radius: (
      /*radius*/
      ctx8[5]
    ),
    shadow: (
      /*shadow*/
      ctx8[6]
    ),
    $$slots: { default: [create_default_slot_32] },
    $$scope: { ctx: ctx8 }
  };
  if (
    /*dropdownElement*/
    ctx8[20] !== void 0
  ) {
    paper_props.element = /*dropdownElement*/
    ctx8[20];
  }
  paper = new Paper_default({ props: paper_props, $$inline: true });
  binding_callbacks.push(() => bind(paper, "element", paper_element_binding));
  paper.$on(
    "mouseleave",
    /*mouseleave_handler*/
    ctx8[50]
  );
  const block = {
    c: function create() {
      create_component(paper.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(paper.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(paper, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const paper_changes = {};
      if (dirty[0] & /*cx, classes*/
      6291456)
        paper_changes.class = /*cx*/
        ctx9[22](
          /*classes*/
          ctx9[21].body
        );
      if (dirty[0] & /*radius*/
      32)
        paper_changes.radius = /*radius*/
        ctx9[5];
      if (dirty[0] & /*shadow*/
      64)
        paper_changes.shadow = /*shadow*/
        ctx9[6];
      if (dirty[1] & /*$$scope*/
      2097152) {
        paper_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty[0] & /*dropdownElement*/
      1048576) {
        updating_element = true;
        paper_changes.element = /*dropdownElement*/
        ctx9[20];
        add_flush_callback(() => updating_element = false);
      }
      paper.$set(paper_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(paper.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(paper.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(paper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_25.name,
    type: "slot",
    source: "(179:2) <Popper    reference={control ?? referenceElement}    mounted={_opened}    arrowSize={3}    arrowClassName={classes.arrow}    {transition}    {transitionOptions}    {position}    {placement}    {gutter}    {withArrow}    {zIndex}   >",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_112(ctx8) {
  let popper;
  let current;
  popper = new Popper_default({
    props: {
      reference: (
        /*control*/
        ctx8[16] ?? /*referenceElement*/
        ctx8[19]
      ),
      mounted: (
        /*_opened*/
        ctx8[18]
      ),
      arrowSize: 3,
      arrowClassName: (
        /*classes*/
        ctx8[21].arrow
      ),
      transition: (
        /*transition*/
        ctx8[14]
      ),
      transitionOptions: (
        /*transitionOptions*/
        ctx8[15]
      ),
      position: (
        /*position*/
        ctx8[13]
      ),
      placement: (
        /*placement*/
        ctx8[12]
      ),
      gutter: (
        /*gutter*/
        ctx8[11]
      ),
      withArrow: (
        /*withArrow*/
        ctx8[10]
      ),
      zIndex: (
        /*zIndex*/
        ctx8[9]
      ),
      $$slots: { default: [create_default_slot_25] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(popper.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(popper.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(popper, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const popper_changes = {};
      if (dirty[0] & /*control, referenceElement*/
      589824)
        popper_changes.reference = /*control*/
        ctx9[16] ?? /*referenceElement*/
        ctx9[19];
      if (dirty[0] & /*_opened*/
      262144)
        popper_changes.mounted = /*_opened*/
        ctx9[18];
      if (dirty[0] & /*classes*/
      2097152)
        popper_changes.arrowClassName = /*classes*/
        ctx9[21].arrow;
      if (dirty[0] & /*transition*/
      16384)
        popper_changes.transition = /*transition*/
        ctx9[14];
      if (dirty[0] & /*transitionOptions*/
      32768)
        popper_changes.transitionOptions = /*transitionOptions*/
        ctx9[15];
      if (dirty[0] & /*position*/
      8192)
        popper_changes.position = /*position*/
        ctx9[13];
      if (dirty[0] & /*placement*/
      4096)
        popper_changes.placement = /*placement*/
        ctx9[12];
      if (dirty[0] & /*gutter*/
      2048)
        popper_changes.gutter = /*gutter*/
        ctx9[11];
      if (dirty[0] & /*withArrow*/
      1024)
        popper_changes.withArrow = /*withArrow*/
        ctx9[10];
      if (dirty[0] & /*zIndex*/
      512)
        popper_changes.zIndex = /*zIndex*/
        ctx9[9];
      if (dirty[0] & /*cx, classes, radius, shadow, dropdownElement, hovered*/
      7471200 | dirty[1] & /*$$scope*/
      2097152) {
        popper_changes.$$scope = { dirty, ctx: ctx9 };
      }
      popper.$set(popper_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(popper.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(popper.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(popper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_112.name,
    type: "slot",
    source: "(178:1) <PopperContainer {withinPortal}>",
    ctx: ctx8
  });
  return block;
}
function create_default_slot54(ctx8) {
  let t;
  let poppercontainer;
  let current;
  const control_slot_template = (
    /*#slots*/
    ctx8[44].control
  );
  const control_slot = create_slot(
    control_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[52],
    get_control_slot_context2
  );
  const control_slot_or_fallback = control_slot || fallback_block15(ctx8);
  poppercontainer = new PopperContainer_default({
    props: {
      withinPortal: (
        /*withinPortal*/
        ctx8[8]
      ),
      $$slots: { default: [create_default_slot_112] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      if (control_slot_or_fallback)
        control_slot_or_fallback.c();
      t = space();
      create_component(poppercontainer.$$.fragment);
    },
    l: function claim(nodes) {
      if (control_slot_or_fallback)
        control_slot_or_fallback.l(nodes);
      t = claim_space(nodes);
      claim_component(poppercontainer.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      if (control_slot_or_fallback) {
        control_slot_or_fallback.m(target, anchor);
      }
      insert_hydration_dev(target, t, anchor);
      mount_component(poppercontainer, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (control_slot) {
        if (control_slot.p && (!current || dirty[1] & /*$$scope*/
        2097152)) {
          update_slot_base(
            control_slot,
            control_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[52],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[52]
            ) : get_slot_changes(
              control_slot_template,
              /*$$scope*/
              ctx9[52],
              dirty,
              get_control_slot_changes2
            ),
            get_control_slot_context2
          );
        }
      } else {
        if (control_slot_or_fallback && control_slot_or_fallback.p && (!current || dirty[0] & /*_opened, menuButtonLabel, referenceElement, trigger*/
        786576)) {
          control_slot_or_fallback.p(ctx9, !current ? [-1, -1] : dirty);
        }
      }
      const poppercontainer_changes = {};
      if (dirty[0] & /*withinPortal*/
      256)
        poppercontainer_changes.withinPortal = /*withinPortal*/
        ctx9[8];
      if (dirty[0] & /*control, referenceElement, _opened, classes, transition, transitionOptions, position, placement, gutter, withArrow, zIndex, cx, radius, shadow, dropdownElement, hovered*/
      8388192 | dirty[1] & /*$$scope*/
      2097152) {
        poppercontainer_changes.$$scope = { dirty, ctx: ctx9 };
      }
      poppercontainer.$set(poppercontainer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(control_slot_or_fallback, local);
      transition_in(poppercontainer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(control_slot_or_fallback, local);
      transition_out(poppercontainer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      if (control_slot_or_fallback)
        control_slot_or_fallback.d(detaching);
      destroy_component(poppercontainer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot54.name,
    type: "slot",
    source: "(156:0) <Box  bind:element  use={[forwardEvents, [useActions, use], [clickoutside, clickOutsideParams]]}  class={cx(classes.root, className)}  on:mouseleave={handleMouseLeave}  on:mouseenter={handleMouseEnter}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment74(ctx8) {
  let box;
  let updating_element;
  let current;
  let mounted;
  let dispose;
  const box_spread_levels = [
    {
      use: [
        /*forwardEvents*/
        ctx8[25],
        [
          useActions,
          /*use*/
          ctx8[1]
        ],
        [
          clickoutside,
          /*clickOutsideParams*/
          ctx8[23]
        ]
      ]
    },
    {
      class: (
        /*cx*/
        ctx8[22](
          /*classes*/
          ctx8[21].root,
          /*className*/
          ctx8[2]
        )
      )
    },
    /*$$restProps*/
    ctx8[33]
  ];
  function box_element_binding(value) {
    ctx8[51](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot54] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  box.$on(
    "mouseleave",
    /*handleMouseLeave*/
    ctx8[30]
  );
  box.$on(
    "mouseenter",
    /*handleMouseEnter*/
    ctx8[31]
  );
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window_1,
          "scroll",
          /*scroll_handler*/
          ctx8[45],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx9, dirty) {
      const box_changes = dirty[0] & /*forwardEvents, use, clickOutsideParams, cx, classes, className*/
      48234502 | dirty[1] & /*$$restProps*/
      4 ? get_spread_update(box_spread_levels, [
        dirty[0] & /*forwardEvents, use, clickOutsideParams*/
        41943042 && {
          use: [
            /*forwardEvents*/
            ctx9[25],
            [
              useActions,
              /*use*/
              ctx9[1]
            ],
            [
              clickoutside,
              /*clickOutsideParams*/
              ctx9[23]
            ]
          ]
        },
        dirty[0] & /*cx, classes, className*/
        6291460 && {
          class: (
            /*cx*/
            ctx9[22](
              /*classes*/
              ctx9[21].root,
              /*className*/
              ctx9[2]
            )
          )
        },
        dirty[1] & /*$$restProps*/
        4 && get_spread_object(
          /*$$restProps*/
          ctx9[33]
        )
      ]) : {};
      if (dirty[0] & /*withinPortal, control, referenceElement, _opened, classes, transition, transitionOptions, position, placement, gutter, withArrow, zIndex, cx, radius, shadow, dropdownElement, hovered, menuButtonLabel, trigger*/
      8388592 | dirty[1] & /*$$scope*/
      2097152) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty[0] & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment74.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
var ctx4 = "Menu";
function instance74($$self, $$props, $$invalidate) {
  let _opened;
  let cx2;
  let classes;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "closeOnItemClick",
    "closeOnScroll",
    "delay",
    "menuButtonLabel",
    "menuId",
    "radius",
    "opened",
    "shadow",
    "size",
    "trigger",
    "trapFocus",
    "withinPortal",
    "zIndex",
    "withArrow",
    "gutter",
    "placement",
    "position",
    "transition",
    "transitionOptions",
    "open",
    "close",
    "toggle"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Menu", slots, ["control", "default"]);
  const $$slots = compute_slots(slots);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, closeOnItemClick = true, closeOnScroll = false, delay = 100, menuButtonLabel = void 0, menuId = void 0, radius: radius2 = "sm", opened = false, shadow = "md", size: size3 = "md", trigger = "click", trapFocus = true, withinPortal = true, zIndex = 300, withArrow = false, gutter = 5, placement = "start", position = "bottom", transition = "fade", transitionOptions = { duration: 100 } } = $$props;
  const dispatch = createEventDispatcher();
  function open() {
    external = true;
    handleOpen();
    onExternal();
  }
  function close() {
    external = true;
    handleClose();
    onExternal();
  }
  function toggle() {
    external = true;
    toggleMenu();
    onExternal();
  }
  function onExternal() {
    window.setTimeout(() => external = false, 0);
  }
  let external = false;
  let delayTimeout;
  let referenceElement;
  let dropdownElement;
  let control;
  let hovered = -1;
  const clickOutsideParams = {
    enabled: true,
    callback: () => _opened && !external && handleClose()
  };
  const uuid = useHash(menuId);
  const forwardEvents = createEventForwarder(get_current_component(), ["open", "close"]);
  const castKeyboardEvent = (event) => event;
  const focusReference = () => window.setTimeout(() => referenceElement == null ? void 0 : referenceElement.focus(), 0);
  onMount(() => {
    if (!$$slots.control)
      return;
    $$invalidate(16, control = element2.children[0]);
    control.setAttribute("role", "button");
    control.setAttribute("aria-haspopup", "menu");
    control.setAttribute("aria-expanded", String(_opened));
    control.setAttribute("aria-controls", uuid);
    if (menuButtonLabel)
      control.setAttribute("aria-label", menuButtonLabel);
    control.addEventListener("click", (event) => {
      event.stopPropagation();
      toggleMenu();
    });
    control.addEventListener("mouseenter", () => trigger === "hover" ? handleOpen() : null);
    control.addEventListener("keydown", (event) => handleKeyDown(castKeyboardEvent(event)));
  });
  const handleClose = () => {
    if (_opened) {
      $$invalidate(18, _opened = false);
      $$invalidate(34, opened = false);
      dispatch("close");
    }
  };
  const handleOpen = () => {
    $$invalidate(18, _opened = true);
    $$invalidate(34, opened = true);
    dispatch("open");
  };
  const toggleMenu = () => {
    _opened ? handleClose() : handleOpen();
  };
  const handleMouseLeave = () => {
    if (trigger === "hover") {
      if (delay > 0) {
        delayTimeout = window.setTimeout(() => handleClose(), delay);
      } else {
        handleClose();
      }
    }
  };
  const handleMouseEnter = () => {
    window.clearTimeout(delayTimeout);
  };
  const handleKeyDown = (event) => {
    if (_opened) {
      const elements = Array.from(dropdownElement.querySelectorAll(".svelteui-MenuItem-root"));
      if (event.code === "Tab" && trapFocus) {
        event.preventDefault();
      }
      if (event.code === "ArrowDown") {
        event.preventDefault();
        const prevIndex = getNextItem(hovered, elements);
        $$invalidate(17, hovered = prevIndex);
        elements[prevIndex].focus();
      }
      if (event.code === "ArrowUp") {
        event.preventDefault();
        const prevIndex = getPreviousItem(hovered, elements);
        $$invalidate(17, hovered = prevIndex);
        elements[prevIndex].focus();
      }
      if (event.code === "Escape") {
        handleClose();
        focusReference();
      }
    }
  };
  const handleItemClick = (event) => {
    if (!closeOnItemClick) {
      event.preventDefault();
      event.stopPropagation();
      return;
    }
    handleClose();
    trigger === "click" && focusReference();
  };
  const contextStore = writable({
    hovered,
    radius: radius2,
    onItemHover: (hover) => $$invalidate(17, hovered = hover),
    onItemKeyDown: handleKeyDown,
    onItemClick: handleItemClick
  });
  setContext(ctx4, contextStore);
  const scroll_handler = () => closeOnScroll && handleClose();
  function menuicon_element_binding(value) {
    referenceElement = value;
    $$invalidate(19, referenceElement);
  }
  const keydown_handler = (event) => handleKeyDown(castKeyboardEvent(event));
  const mouseenter_handler = () => trigger === "hover" ? handleOpen() : null;
  function paper_element_binding(value) {
    dropdownElement = value;
    $$invalidate(20, dropdownElement);
  }
  const mouseleave_handler = () => $$invalidate(17, hovered = -1);
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(33, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(35, override = $$new_props.override);
    if ("closeOnItemClick" in $$new_props)
      $$invalidate(36, closeOnItemClick = $$new_props.closeOnItemClick);
    if ("closeOnScroll" in $$new_props)
      $$invalidate(3, closeOnScroll = $$new_props.closeOnScroll);
    if ("delay" in $$new_props)
      $$invalidate(37, delay = $$new_props.delay);
    if ("menuButtonLabel" in $$new_props)
      $$invalidate(4, menuButtonLabel = $$new_props.menuButtonLabel);
    if ("menuId" in $$new_props)
      $$invalidate(38, menuId = $$new_props.menuId);
    if ("radius" in $$new_props)
      $$invalidate(5, radius2 = $$new_props.radius);
    if ("opened" in $$new_props)
      $$invalidate(34, opened = $$new_props.opened);
    if ("shadow" in $$new_props)
      $$invalidate(6, shadow = $$new_props.shadow);
    if ("size" in $$new_props)
      $$invalidate(39, size3 = $$new_props.size);
    if ("trigger" in $$new_props)
      $$invalidate(7, trigger = $$new_props.trigger);
    if ("trapFocus" in $$new_props)
      $$invalidate(40, trapFocus = $$new_props.trapFocus);
    if ("withinPortal" in $$new_props)
      $$invalidate(8, withinPortal = $$new_props.withinPortal);
    if ("zIndex" in $$new_props)
      $$invalidate(9, zIndex = $$new_props.zIndex);
    if ("withArrow" in $$new_props)
      $$invalidate(10, withArrow = $$new_props.withArrow);
    if ("gutter" in $$new_props)
      $$invalidate(11, gutter = $$new_props.gutter);
    if ("placement" in $$new_props)
      $$invalidate(12, placement = $$new_props.placement);
    if ("position" in $$new_props)
      $$invalidate(13, position = $$new_props.position);
    if ("transition" in $$new_props)
      $$invalidate(14, transition = $$new_props.transition);
    if ("transitionOptions" in $$new_props)
      $$invalidate(15, transitionOptions = $$new_props.transitionOptions);
    if ("$$scope" in $$new_props)
      $$invalidate(52, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    ctx: ctx4,
    useStyles: Menu_styles_default,
    getNextItem,
    getPreviousItem,
    createEventDispatcher,
    onMount,
    setContext,
    writable,
    Box: Box_default,
    Popper: Popper_default,
    PopperContainer: PopperContainer_default,
    Paper: Paper_default,
    MenuIcon: MenuIcon_default,
    clickoutside,
    useHash,
    createEventForwarder,
    useActions,
    get_current_component,
    use,
    element: element2,
    className,
    override,
    closeOnItemClick,
    closeOnScroll,
    delay,
    menuButtonLabel,
    menuId,
    radius: radius2,
    opened,
    shadow,
    size: size3,
    trigger,
    trapFocus,
    withinPortal,
    zIndex,
    withArrow,
    gutter,
    placement,
    position,
    transition,
    transitionOptions,
    dispatch,
    open,
    close,
    toggle,
    onExternal,
    external,
    delayTimeout,
    referenceElement,
    dropdownElement,
    control,
    hovered,
    clickOutsideParams,
    uuid,
    forwardEvents,
    castKeyboardEvent,
    focusReference,
    handleClose,
    handleOpen,
    toggleMenu,
    handleMouseLeave,
    handleMouseEnter,
    handleKeyDown,
    handleItemClick,
    contextStore,
    classes,
    cx: cx2,
    _opened
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(35, override = $$new_props.override);
    if ("closeOnItemClick" in $$props)
      $$invalidate(36, closeOnItemClick = $$new_props.closeOnItemClick);
    if ("closeOnScroll" in $$props)
      $$invalidate(3, closeOnScroll = $$new_props.closeOnScroll);
    if ("delay" in $$props)
      $$invalidate(37, delay = $$new_props.delay);
    if ("menuButtonLabel" in $$props)
      $$invalidate(4, menuButtonLabel = $$new_props.menuButtonLabel);
    if ("menuId" in $$props)
      $$invalidate(38, menuId = $$new_props.menuId);
    if ("radius" in $$props)
      $$invalidate(5, radius2 = $$new_props.radius);
    if ("opened" in $$props)
      $$invalidate(34, opened = $$new_props.opened);
    if ("shadow" in $$props)
      $$invalidate(6, shadow = $$new_props.shadow);
    if ("size" in $$props)
      $$invalidate(39, size3 = $$new_props.size);
    if ("trigger" in $$props)
      $$invalidate(7, trigger = $$new_props.trigger);
    if ("trapFocus" in $$props)
      $$invalidate(40, trapFocus = $$new_props.trapFocus);
    if ("withinPortal" in $$props)
      $$invalidate(8, withinPortal = $$new_props.withinPortal);
    if ("zIndex" in $$props)
      $$invalidate(9, zIndex = $$new_props.zIndex);
    if ("withArrow" in $$props)
      $$invalidate(10, withArrow = $$new_props.withArrow);
    if ("gutter" in $$props)
      $$invalidate(11, gutter = $$new_props.gutter);
    if ("placement" in $$props)
      $$invalidate(12, placement = $$new_props.placement);
    if ("position" in $$props)
      $$invalidate(13, position = $$new_props.position);
    if ("transition" in $$props)
      $$invalidate(14, transition = $$new_props.transition);
    if ("transitionOptions" in $$props)
      $$invalidate(15, transitionOptions = $$new_props.transitionOptions);
    if ("external" in $$props)
      external = $$new_props.external;
    if ("delayTimeout" in $$props)
      delayTimeout = $$new_props.delayTimeout;
    if ("referenceElement" in $$props)
      $$invalidate(19, referenceElement = $$new_props.referenceElement);
    if ("dropdownElement" in $$props)
      $$invalidate(20, dropdownElement = $$new_props.dropdownElement);
    if ("control" in $$props)
      $$invalidate(16, control = $$new_props.control);
    if ("hovered" in $$props)
      $$invalidate(17, hovered = $$new_props.hovered);
    if ("classes" in $$props)
      $$invalidate(21, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(22, cx2 = $$new_props.cx);
    if ("_opened" in $$props)
      $$invalidate(18, _opened = $$new_props._opened);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & /*opened*/
    8) {
      $:
        $$invalidate(18, _opened = opened);
    }
    if ($$self.$$.dirty[0] & /*control, _opened*/
    327680) {
      $:
        if ($$slots.control && control)
          control.setAttribute("aria-expanded", String(_opened));
    }
    if ($$self.$$.dirty[0] & /*hovered, radius*/
    131104) {
      $:
        contextStore.set({
          hovered,
          radius: radius2,
          onItemHover: (hover) => $$invalidate(17, hovered = hover),
          onItemKeyDown: handleKeyDown,
          onItemClick: handleItemClick
        });
    }
    if ($$self.$$.dirty[1] & /*size, override*/
    272) {
      $:
        $$invalidate(22, { cx: cx2, classes } = Menu_styles_default({ size: size3 }, { override, name: "Menu" }), cx2, ($$invalidate(21, classes), $$invalidate(39, size3), $$invalidate(35, override)));
    }
  };
  return [
    element2,
    use,
    className,
    closeOnScroll,
    menuButtonLabel,
    radius2,
    shadow,
    trigger,
    withinPortal,
    zIndex,
    withArrow,
    gutter,
    placement,
    position,
    transition,
    transitionOptions,
    control,
    hovered,
    _opened,
    referenceElement,
    dropdownElement,
    classes,
    cx2,
    clickOutsideParams,
    uuid,
    forwardEvents,
    castKeyboardEvent,
    handleClose,
    handleOpen,
    toggleMenu,
    handleMouseLeave,
    handleMouseEnter,
    handleKeyDown,
    $$restProps,
    opened,
    override,
    closeOnItemClick,
    delay,
    menuId,
    size3,
    trapFocus,
    open,
    close,
    toggle,
    slots,
    scroll_handler,
    menuicon_element_binding,
    keydown_handler,
    mouseenter_handler,
    paper_element_binding,
    mouseleave_handler,
    box_element_binding,
    $$scope
  ];
}
var Menu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance74,
      create_fragment74,
      safe_not_equal,
      {
        use: 1,
        element: 0,
        class: 2,
        override: 35,
        closeOnItemClick: 36,
        closeOnScroll: 3,
        delay: 37,
        menuButtonLabel: 4,
        menuId: 38,
        radius: 5,
        opened: 34,
        shadow: 6,
        size: 39,
        trigger: 7,
        trapFocus: 40,
        withinPortal: 8,
        zIndex: 9,
        withArrow: 10,
        gutter: 11,
        placement: 12,
        position: 13,
        transition: 14,
        transitionOptions: 15,
        open: 41,
        close: 42,
        toggle: 43
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Menu",
      options,
      id: create_fragment74.name
    });
  }
  get use() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnItemClick() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnItemClick(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnScroll() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnScroll(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get delay() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set delay(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get menuButtonLabel() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set menuButtonLabel(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get menuId() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set menuId(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opened() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opened(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get trigger() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set trigger(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get trapFocus() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set trapFocus(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withinPortal() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withinPortal(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withArrow() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withArrow(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gutter() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gutter(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placement() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placement(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transition() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionOptions() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionOptions(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    return this.$$.ctx[41];
  }
  set open(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get close() {
    return this.$$.ctx[42];
  }
  set close(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggle() {
    return this.$$.ctx[43];
  }
  set toggle(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Menu_default = Menu;

// node_modules/@svelteuidev/core/dist/components/Menu/MenuItem/MenuItem.styles.js
function findAncestor(element2, className) {
  let _element = element2;
  while ((_element = _element.parentElement) && !_element.classList.contains(className))
    ;
  return _element;
}
function getContextItemIndex(options, node) {
  var _a;
  if (!node) {
    return -1;
  }
  return Array.from(((_a = findAncestor(node, options.parentClassName)) == null ? void 0 : _a.querySelectorAll(options.elementSelector)) ?? []).findIndex((element2) => element2 === node);
}
var MenuItem_styles_default = createStyles((theme4, { color, radius: radius2 }) => {
  return {
    root: {
      darkMode: {
        color: color ? theme4.fn.themeColor(color, 5) : theme4.fn.themeColor("dark", 0),
        "&:disabled": {
          color: theme4.fn.themeColor("dark", 3)
        }
      },
      WebkitTapHighlightColor: "transparent",
      fontFamily: theme4.fonts.standard.value,
      fontSize: theme4.fontSizes.sm.value,
      border: 0,
      backgroundColor: "transparent",
      outline: 0,
      width: "100%",
      textAlign: "left",
      display: "inline-block",
      textDecoration: "none",
      boxSizing: "border-box",
      padding: `${+theme4.space.xs.value}px ${+theme4.space.sm.value}px`,
      cursor: "pointer",
      borderRadius: theme4.fn.radius(radius2),
      color: color ? theme4.fn.themeColor(color, 7) : "black",
      "&:disabled": {
        color: theme4.fn.themeColor("gray", 5),
        pointerEvents: "none"
      },
      "&.itemHovered": {
        [`${theme4.dark} &`]: {
          backgroundColor: color ? theme4.fn.rgba(theme4.fn.themeColor(color, 8), 0.35) : theme4.fn.rgba(theme4.fn.themeColor("dark", 3), 0.35)
        },
        backgroundColor: color ? theme4.fn.rgba(theme4.fn.themeColor(color, 0), 1) : theme4.fn.themeColor("gray", 0)
      }
    },
    itemInner: {
      display: "flex",
      alignItems: "center",
      height: "100%"
    },
    itemBody: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      flex: 1
    },
    itemIcon: {
      marginRight: theme4.space.xsPX.value,
      "& *": {
        display: "block"
      }
    },
    itemLabel: {
      lineHeight: 1
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Menu/MenuItem/MenuItem.svelte
var file32 = "node_modules/@svelteuidev/core/dist/components/Menu/MenuItem/MenuItem.svelte";
var get_rightSection_slot_changes5 = (dirty) => ({});
var get_rightSection_slot_context5 = (ctx8) => ({});
var get_icon_slot_changes5 = (dirty) => ({});
var get_icon_slot_context5 = (ctx8) => ({});
function create_if_block27(ctx8) {
  let iconrenderer;
  let current;
  iconrenderer = new IconRenderer_default({
    props: {
      icon: (
        /*icon*/
        ctx8[5]
      ),
      className: (
        /*classes*/
        ctx8[12].itemIcon
      ),
      iconSize: (
        /*iconSize*/
        ctx8[6]
      ),
      iconProps: (
        /*iconProps*/
        ctx8[7]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(iconrenderer.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconrenderer.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconrenderer, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const iconrenderer_changes = {};
      if (dirty & /*icon*/
      32)
        iconrenderer_changes.icon = /*icon*/
        ctx9[5];
      if (dirty & /*classes*/
      4096)
        iconrenderer_changes.className = /*classes*/
        ctx9[12].itemIcon;
      if (dirty & /*iconSize*/
      64)
        iconrenderer_changes.iconSize = /*iconSize*/
        ctx9[6];
      if (dirty & /*iconProps*/
      128)
        iconrenderer_changes.iconProps = /*iconProps*/
        ctx9[7];
      iconrenderer.$set(iconrenderer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconrenderer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconrenderer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconrenderer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block27.name,
    type: "if",
    source: "(36:3) {#if icon}",
    ctx: ctx8
  });
  return block;
}
function fallback_block16(ctx8) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*icon*/
    ctx8[5] && create_if_block27(ctx8)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (
        /*icon*/
        ctx9[5]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
          if (dirty & /*icon*/
          32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block27(ctx9);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block16.name,
    type: "fallback",
    source: "(35:20)     ",
    ctx: ctx8
  });
  return block;
}
function create_default_slot55(ctx8) {
  let div2;
  let t0;
  let div1;
  let div0;
  let div0_class_value;
  let t1;
  let div1_class_value;
  let div2_class_value;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx8[23].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[28],
    get_icon_slot_context5
  );
  const icon_slot_or_fallback = icon_slot || fallback_block16(ctx8);
  const default_slot_template = (
    /*#slots*/
    ctx8[23].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[28],
    null
  );
  const rightSection_slot_template = (
    /*#slots*/
    ctx8[23].rightSection
  );
  const rightSection_slot = create_slot(
    rightSection_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[28],
    get_rightSection_slot_context5
  );
  const block = {
    c: function create() {
      div2 = element("div");
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.c();
      t0 = space();
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (rightSection_slot)
        rightSection_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.l(div2_nodes);
      t0 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      if (rightSection_slot)
        rightSection_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = /*classes*/
      ctx8[12].itemLabel);
      add_location(div0, file32, 40, 3, 1650);
      attr_dev(div1, "class", div1_class_value = /*classes*/
      ctx8[12].itemBody);
      add_location(div1, file32, 39, 2, 1616);
      attr_dev(div2, "class", div2_class_value = /*classes*/
      ctx8[12].itemInner);
      add_location(div2, file32, 33, 1, 1448);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(div2, null);
      }
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append_hydration_dev(div1, t1);
      if (rightSection_slot) {
        rightSection_slot.m(div1, null);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        268435456)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[28]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx9[28],
              dirty,
              get_icon_slot_changes5
            ),
            get_icon_slot_context5
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty & /*icon, classes, iconSize, iconProps*/
        4320)) {
          icon_slot_or_fallback.p(ctx9, !current ? -1 : dirty);
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        268435456)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[28]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[28],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classes*/
      4096 && div0_class_value !== (div0_class_value = /*classes*/
      ctx9[12].itemLabel)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (rightSection_slot) {
        if (rightSection_slot.p && (!current || dirty & /*$$scope*/
        268435456)) {
          update_slot_base(
            rightSection_slot,
            rightSection_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[28]
            ) : get_slot_changes(
              rightSection_slot_template,
              /*$$scope*/
              ctx9[28],
              dirty,
              get_rightSection_slot_changes5
            ),
            get_rightSection_slot_context5
          );
        }
      }
      if (!current || dirty & /*classes*/
      4096 && div1_class_value !== (div1_class_value = /*classes*/
      ctx9[12].itemBody)) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*classes*/
      4096 && div2_class_value !== (div2_class_value = /*classes*/
      ctx9[12].itemInner)) {
        attr_dev(div2, "class", div2_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot_or_fallback, local);
      transition_in(default_slot, local);
      transition_in(rightSection_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot_or_fallback, local);
      transition_out(default_slot, local);
      transition_out(rightSection_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (rightSection_slot)
        rightSection_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot55.name,
    type: "slot",
    source: '(18:0) <Box  {root}  use={[forwardEvents, [useActions, use]]}  bind:element  type=\\"button\\"  role=\\"menuitem\\"  class={cx(className, classes.root, {   itemHovered: hovered === itemIndex  })}  {disabled}  on:mouseenter={() => !disabled && onItemHover(itemIndex)}  on:mouseleave={() => onItemHover(-1)}  on:keydown={(event) => onItemKeyDown(castKeyboardEvent(event))}  on:click={onItemClick}  {...$$restProps} >',
    ctx: ctx8
  });
  return block;
}
function create_fragment75(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { root: (
      /*root*/
      ctx8[3]
    ) },
    {
      use: [
        /*forwardEvents*/
        ctx8[16],
        [
          useActions,
          /*use*/
          ctx8[1]
        ]
      ]
    },
    { type: "button" },
    { role: "menuitem" },
    {
      class: (
        /*cx*/
        ctx8[13](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[12].root,
          {
            itemHovered: (
              /*hovered*/
              ctx8[11] === /*itemIndex*/
              ctx8[14]
            )
          }
        )
      )
    },
    { disabled: (
      /*disabled*/
      ctx8[4]
    ) },
    /*$$restProps*/
    ctx8[18]
  ];
  function box_element_binding(value) {
    ctx8[24](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot55] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  box.$on(
    "mouseenter",
    /*mouseenter_handler*/
    ctx8[25]
  );
  box.$on(
    "mouseleave",
    /*mouseleave_handler*/
    ctx8[26]
  );
  box.$on(
    "keydown",
    /*keydown_handler*/
    ctx8[27]
  );
  box.$on("click", function() {
    if (is_function(
      /*onItemClick*/
      ctx8[10]
    ))
      ctx8[10].apply(this, arguments);
  });
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(new_ctx, [dirty]) {
      ctx8 = new_ctx;
      const box_changes = dirty & /*root, forwardEvents, use, cx, className, classes, hovered, itemIndex, disabled, $$restProps*/
      358430 ? get_spread_update(box_spread_levels, [
        dirty & /*root*/
        8 && { root: (
          /*root*/
          ctx8[3]
        ) },
        dirty & /*forwardEvents, use*/
        65538 && {
          use: [
            /*forwardEvents*/
            ctx8[16],
            [
              useActions,
              /*use*/
              ctx8[1]
            ]
          ]
        },
        box_spread_levels[2],
        box_spread_levels[3],
        dirty & /*cx, className, classes, hovered, itemIndex*/
        30724 && {
          class: (
            /*cx*/
            ctx8[13](
              /*className*/
              ctx8[2],
              /*classes*/
              ctx8[12].root,
              {
                itemHovered: (
                  /*hovered*/
                  ctx8[11] === /*itemIndex*/
                  ctx8[14]
                )
              }
            )
          )
        },
        dirty & /*disabled*/
        16 && { disabled: (
          /*disabled*/
          ctx8[4]
        ) },
        dirty & /*$$restProps*/
        262144 && get_spread_object(
          /*$$restProps*/
          ctx8[18]
        )
      ]) : {};
      if (dirty & /*$$scope, classes, icon, iconSize, iconProps*/
      268439776) {
        box_changes.$$scope = { dirty, ctx: ctx8 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx8[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment75.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance75($$self, $$props, $$invalidate) {
  let itemIndex;
  let cx2;
  let classes;
  let hovered;
  let radius2;
  let onItemClick;
  let onItemHover;
  let onItemKeyDown;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "root",
    "color",
    "disabled",
    "icon",
    "iconSize",
    "iconProps"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $state;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenuItem", slots, ["icon", "default", "rightSection"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, root = "button", color = void 0, disabled = false, icon = void 0, iconSize = void 0, iconProps = void 0 } = $$props;
  const state = getContext(ctx4);
  validate_store(state, "state");
  component_subscribe($$self, state, (value) => $$invalidate(22, $state = value));
  const forwardEvents = createEventForwarder(get_current_component());
  const castKeyboardEvent = (event) => event;
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  const mouseenter_handler = () => !disabled && onItemHover(itemIndex);
  const mouseleave_handler = () => onItemHover(-1);
  const keydown_handler = (event) => onItemKeyDown(castKeyboardEvent(event));
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(18, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(19, override = $$new_props.override);
    if ("root" in $$new_props)
      $$invalidate(3, root = $$new_props.root);
    if ("color" in $$new_props)
      $$invalidate(20, color = $$new_props.color);
    if ("disabled" in $$new_props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("icon" in $$new_props)
      $$invalidate(5, icon = $$new_props.icon);
    if ("iconSize" in $$new_props)
      $$invalidate(6, iconSize = $$new_props.iconSize);
    if ("iconProps" in $$new_props)
      $$invalidate(7, iconProps = $$new_props.iconProps);
    if ("$$scope" in $$new_props)
      $$invalidate(28, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    get_current_component,
    createEventForwarder,
    useActions,
    Box: Box_default,
    IconRenderer: IconRenderer_default,
    ctx: ctx4,
    useStyles: MenuItem_styles_default,
    getContextItemIndex,
    use,
    element: element2,
    className,
    override,
    root,
    color,
    disabled,
    icon,
    iconSize,
    iconProps,
    state,
    forwardEvents,
    castKeyboardEvent,
    onItemKeyDown,
    onItemHover,
    onItemClick,
    radius: radius2,
    hovered,
    classes,
    cx: cx2,
    itemIndex,
    $state
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(19, override = $$new_props.override);
    if ("root" in $$props)
      $$invalidate(3, root = $$new_props.root);
    if ("color" in $$props)
      $$invalidate(20, color = $$new_props.color);
    if ("disabled" in $$props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("icon" in $$props)
      $$invalidate(5, icon = $$new_props.icon);
    if ("iconSize" in $$props)
      $$invalidate(6, iconSize = $$new_props.iconSize);
    if ("iconProps" in $$props)
      $$invalidate(7, iconProps = $$new_props.iconProps);
    if ("onItemKeyDown" in $$props)
      $$invalidate(8, onItemKeyDown = $$new_props.onItemKeyDown);
    if ("onItemHover" in $$props)
      $$invalidate(9, onItemHover = $$new_props.onItemHover);
    if ("onItemClick" in $$props)
      $$invalidate(10, onItemClick = $$new_props.onItemClick);
    if ("radius" in $$props)
      $$invalidate(21, radius2 = $$new_props.radius);
    if ("hovered" in $$props)
      $$invalidate(11, hovered = $$new_props.hovered);
    if ("classes" in $$props)
      $$invalidate(12, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(13, cx2 = $$new_props.cx);
    if ("itemIndex" in $$props)
      $$invalidate(14, itemIndex = $$new_props.itemIndex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*element*/
    1) {
      $:
        $$invalidate(14, itemIndex = getContextItemIndex(
          {
            elementSelector: ".svelteui-MenuItem-root",
            parentClassName: "svelteui-Menu-body"
          },
          element2
        ));
    }
    if ($$self.$$.dirty & /*$state*/
    4194304) {
      $:
        $$invalidate(11, { hovered, radius: radius2, onItemClick, onItemHover, onItemKeyDown } = $state, hovered, ($$invalidate(21, radius2), $$invalidate(22, $state)), ($$invalidate(10, onItemClick), $$invalidate(22, $state)), ($$invalidate(9, onItemHover), $$invalidate(22, $state)), ($$invalidate(8, onItemKeyDown), $$invalidate(22, $state)));
    }
    if ($$self.$$.dirty & /*color, radius, override*/
    3670016) {
      $:
        $$invalidate(13, { cx: cx2, classes } = MenuItem_styles_default({ color, radius: radius2 }, { override, name: "MenuItem" }), cx2, ($$invalidate(12, classes), $$invalidate(20, color), $$invalidate(21, radius2), $$invalidate(19, override), $$invalidate(22, $state)));
    }
  };
  return [
    element2,
    use,
    className,
    root,
    disabled,
    icon,
    iconSize,
    iconProps,
    onItemKeyDown,
    onItemHover,
    onItemClick,
    hovered,
    classes,
    cx2,
    itemIndex,
    state,
    forwardEvents,
    castKeyboardEvent,
    $$restProps,
    override,
    color,
    radius2,
    $state,
    slots,
    box_element_binding,
    mouseenter_handler,
    mouseleave_handler,
    keydown_handler,
    $$scope
  ];
}
var MenuItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance75, create_fragment75, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 19,
      root: 3,
      color: 20,
      disabled: 4,
      icon: 5,
      iconSize: 6,
      iconProps: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenuItem",
      options,
      id: create_fragment75.name
    });
  }
  get use() {
    throw new Error("<MenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<MenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<MenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<MenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<MenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<MenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get root() {
    throw new Error("<MenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set root(value) {
    throw new Error("<MenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<MenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<MenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<MenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<MenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<MenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<MenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconSize() {
    throw new Error("<MenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconSize(value) {
    throw new Error("<MenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconProps() {
    throw new Error("<MenuItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconProps(value) {
    throw new Error("<MenuItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenuItem_default = MenuItem;

// node_modules/@svelteuidev/core/dist/components/Menu/MenuLabel/MenuLabel.svelte
function create_default_slot56(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[6],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot56.name,
    type: "slot",
    source: "(18:0) <Text bind:element class={className} {...$$restProps} override={classes}>",
    ctx: ctx8
  });
  return block;
}
function create_fragment76(ctx8) {
  let text_1;
  let updating_element;
  let current;
  const text_1_spread_levels = [
    { class: (
      /*className*/
      ctx8[1]
    ) },
    /*$$restProps*/
    ctx8[3],
    { override: (
      /*classes*/
      ctx8[2]
    ) }
  ];
  function text_1_element_binding(value) {
    ctx8[5](value);
  }
  let text_1_props = {
    $$slots: { default: [create_default_slot56] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < text_1_spread_levels.length; i2 += 1) {
    text_1_props = assign(text_1_props, text_1_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    text_1_props.element = /*element*/
    ctx8[0];
  }
  text_1 = new Text_default({ props: text_1_props, $$inline: true });
  binding_callbacks.push(() => bind(text_1, "element", text_1_element_binding));
  const block = {
    c: function create() {
      create_component(text_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(text_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(text_1, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const text_1_changes = dirty & /*className, $$restProps, classes*/
      14 ? get_spread_update(text_1_spread_levels, [
        dirty & /*className*/
        2 && { class: (
          /*className*/
          ctx9[1]
        ) },
        dirty & /*$$restProps*/
        8 && get_spread_object(
          /*$$restProps*/
          ctx9[3]
        ),
        dirty & /*classes*/
        4 && { override: (
          /*classes*/
          ctx9[2]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      64) {
        text_1_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        text_1_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      text_1.$set(text_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(text_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment76.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance76($$self, $$props, $$invalidate) {
  var _a;
  const omit_props_names = ["element", "class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenuLabel", slots, ["default"]);
  let { element: element2 = void 0, class: className = "" } = $$props;
  const theme4 = ((_a = useSvelteUIThemeContext()) == null ? void 0 : _a.theme) || useSvelteUITheme();
  const classes = {
    [`${theme4.dark} &`]: { color: theme4.fn.themeColor("dark", 2) },
    color: theme4.fn.themeColor("gray", 6),
    fontWeight: 500,
    fontSize: theme4.fontSizes.xs,
    padding: `${+theme4.space.xs.value / 2}px ${+theme4.space.sm.value}px`,
    cursor: "default"
  };
  function text_1_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useSvelteUIThemeContext,
    useSvelteUITheme,
    Text: Text_default,
    element: element2,
    className,
    theme: theme4,
    classes
  });
  $$self.$inject_state = ($$new_props) => {
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    className,
    classes,
    $$restProps,
    slots,
    text_1_element_binding,
    $$scope
  ];
}
var MenuLabel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance76, create_fragment76, safe_not_equal, { element: 0, class: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenuLabel",
      options,
      id: create_fragment76.name
    });
  }
  get element() {
    throw new Error("<MenuLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<MenuLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MenuLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MenuLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenuLabel_default = MenuLabel;

// node_modules/@svelteuidev/core/dist/components/Menu/combinator.js
Menu_default.Item = MenuItem_default;
Menu_default.Label = MenuLabel_default;
var Menu2 = Menu_default;

// node_modules/@svelteuidev/core/dist/components/Menu/MenuIcon.svelte
var file33 = "node_modules/@svelteuidev/core/dist/components/Menu/MenuIcon.svelte";
function create_default_slot57(ctx8) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        fill: true,
        xmlns: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", {
        d: true,
        fill: true,
        "fill-rule": true,
        "clip-rule": true
      });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3.625 7.5C3.625 8.12132 3.12132 8.625 2.5 8.625C1.87868 8.625 1.375 8.12132 1.375 7.5C1.375 6.87868 1.87868 6.375 2.5 6.375C3.12132 6.375 3.625 6.87868 3.625 7.5ZM8.625 7.5C8.625 8.12132 8.12132 8.625 7.5 8.625C6.87868 8.625 6.375 8.12132 6.375 7.5C6.375 6.87868 6.87868 6.375 7.5 6.375C8.12132 6.375 8.625 6.87868 8.625 7.5ZM12.5 8.625C13.1213 8.625 13.625 8.12132 13.625 7.5C13.625 6.87868 13.1213 6.375 12.5 6.375C11.8787 6.375 11.375 6.87868 11.375 7.5C11.375 8.12132 11.8787 8.625 12.5 8.625Z");
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "clip-rule", "evenodd");
      add_location(path, file33, 23, 2, 603);
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx8[1]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx8[1]
      );
      attr_dev(svg, "viewBox", "0 0 15 15");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      add_location(svg, file33, 16, 1, 489);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*size*/
      2) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx9[1]
        );
      }
      if (dirty & /*size*/
      2) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx9[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot57.name,
    type: "slot",
    source: "(11:0) <ActionIcon  bind:element  use={[forwardEvents, [useActions, $$restProps?.use]]}  class={className}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment77(ctx8) {
  var _a;
  let actionicon;
  let updating_element;
  let current;
  const actionicon_spread_levels = [
    {
      use: [
        /*forwardEvents*/
        ctx8[3],
        [
          useActions,
          /*$$restProps*/
          (_a = ctx8[4]) == null ? void 0 : _a.use
        ]
      ]
    },
    { class: (
      /*className*/
      ctx8[2]
    ) },
    /*$$restProps*/
    ctx8[4]
  ];
  function actionicon_element_binding(value) {
    ctx8[5](value);
  }
  let actionicon_props = {
    $$slots: { default: [create_default_slot57] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < actionicon_spread_levels.length; i2 += 1) {
    actionicon_props = assign(actionicon_props, actionicon_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    actionicon_props.element = /*element*/
    ctx8[0];
  }
  actionicon = new ActionIcon_default({ props: actionicon_props, $$inline: true });
  binding_callbacks.push(() => bind(actionicon, "element", actionicon_element_binding));
  const block = {
    c: function create() {
      create_component(actionicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(actionicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(actionicon, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      var _a2;
      const actionicon_changes = dirty & /*forwardEvents, $$restProps, className*/
      28 ? get_spread_update(actionicon_spread_levels, [
        dirty & /*forwardEvents, $$restProps*/
        24 && {
          use: [
            /*forwardEvents*/
            ctx9[3],
            [
              useActions,
              /*$$restProps*/
              (_a2 = ctx9[4]) == null ? void 0 : _a2.use
            ]
          ]
        },
        dirty & /*className*/
        4 && { class: (
          /*className*/
          ctx9[2]
        ) },
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx9[4]
        )
      ]) : {};
      if (dirty & /*$$scope, size*/
      66) {
        actionicon_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        actionicon_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      actionicon.$set(actionicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(actionicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(actionicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(actionicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment77.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance77($$self, $$props, $$invalidate) {
  const omit_props_names = ["element", "size", "class"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenuIcon", slots, []);
  let { element: element2 = void 0 } = $$props;
  let { size: size3 = 15 } = $$props;
  let { class: className = "" } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  function actionicon_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("size" in $$new_props)
      $$invalidate(1, size3 = $$new_props.size);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
  };
  $$self.$capture_state = () => ({
    createEventForwarder,
    useActions,
    get_current_component,
    ActionIcon: ActionIcon_default,
    element: element2,
    size: size3,
    className,
    forwardEvents
  });
  $$self.$inject_state = ($$new_props) => {
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("size" in $$props)
      $$invalidate(1, size3 = $$new_props.size);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    size3,
    className,
    forwardEvents,
    $$restProps,
    actionicon_element_binding
  ];
}
var MenuIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance77, create_fragment77, safe_not_equal, { element: 0, size: 1, class: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenuIcon",
      options,
      id: create_fragment77.name
    });
  }
  get element() {
    throw new Error("<MenuIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<MenuIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<MenuIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<MenuIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MenuIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MenuIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenuIcon_default = MenuIcon;

// node_modules/@svelteuidev/core/dist/components/Overlay/Overlay.styles.js
var elevations = {
  app: 100,
  modal: 200,
  popover: 300,
  overlay: 400
};
function getDefaultZIndex(level) {
  return elevations[level];
}

// node_modules/@svelteuidev/core/dist/components/Overlay/Overlay.svelte
function create_else_block12(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    {
      use: [
        /*forwardEvents*/
        ctx8[10],
        [
          useActions,
          /*use*/
          ctx8[1]
        ]
      ]
    },
    {
      css: {
        .../*background*/
        ctx8[9],
        .../*baseStyles*/
        ctx8[8],
        opacity: (
          /*opacity*/
          ctx8[4]
        ),
        borderRadius: `${/*radius*/
        ctx8[6]}`,
        .../*override*/
        ctx8[3]
      }
    },
    /*$$restProps*/
    ctx8[11],
    { class: (
      /*className*/
      ctx8[2]
    ) }
  ];
  function box_element_binding_1(value) {
    ctx8[17](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot_113] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding_1));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const box_changes = dirty & /*forwardEvents, use, background, baseStyles, opacity, radius, override, $$restProps, className*/
      3934 ? get_spread_update(box_spread_levels, [
        dirty & /*forwardEvents, use*/
        1026 && {
          use: [
            /*forwardEvents*/
            ctx9[10],
            [
              useActions,
              /*use*/
              ctx9[1]
            ]
          ]
        },
        dirty & /*background, baseStyles, opacity, radius, override*/
        856 && {
          css: {
            .../*background*/
            ctx9[9],
            .../*baseStyles*/
            ctx9[8],
            opacity: (
              /*opacity*/
              ctx9[4]
            ),
            borderRadius: `${/*radius*/
            ctx9[6]}`,
            .../*override*/
            ctx9[3]
          }
        },
        dirty & /*$$restProps*/
        2048 && get_spread_object(
          /*$$restProps*/
          ctx9[11]
        ),
        dirty & /*className*/
        4 && { class: (
          /*className*/
          ctx9[2]
        ) }
      ]) : {};
      if (dirty & /*$$scope, center*/
      262272) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block12.name,
    type: "else",
    source: "(52:0) {:else}",
    ctx: ctx8
  });
  return block;
}
function create_if_block28(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    {
      use: [
        /*forwardEvents*/
        ctx8[10],
        [
          useActions,
          /*use*/
          ctx8[1]
        ]
      ]
    },
    {
      css: {
        .../*baseStyles*/
        ctx8[8],
        backdropFilter: `blur(${/*blur*/
        ctx8[5]}px)`
      }
    },
    { class: (
      /*className*/
      ctx8[2]
    ) },
    /*$$restProps*/
    ctx8[11]
  ];
  function box_element_binding(value) {
    ctx8[16](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot58] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const box_changes = dirty & /*forwardEvents, use, baseStyles, blur, className, $$restProps*/
      3366 ? get_spread_update(box_spread_levels, [
        dirty & /*forwardEvents, use*/
        1026 && {
          use: [
            /*forwardEvents*/
            ctx9[10],
            [
              useActions,
              /*use*/
              ctx9[1]
            ]
          ]
        },
        dirty & /*baseStyles, blur*/
        288 && {
          css: {
            .../*baseStyles*/
            ctx9[8],
            backdropFilter: `blur(${/*blur*/
            ctx9[5]}px)`
          }
        },
        dirty & /*className*/
        4 && { class: (
          /*className*/
          ctx9[2]
        ) },
        dirty & /*$$restProps*/
        2048 && get_spread_object(
          /*$$restProps*/
          ctx9[11]
        )
      ]) : {};
      if (dirty & /*$$scope, background, baseStyles, opacity, radius, override*/
      263e3) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block28.name,
    type: "if",
    source: "(42:0) {#if blur}",
    ctx: ctx8
  });
  return block;
}
function create_else_block_12(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[18],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[18],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_12.name,
    type: "else",
    source: "(64:2) {:else}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_116(ctx8) {
  let center_1;
  let current;
  center_1 = new Center_default({
    props: {
      $$slots: { default: [create_default_slot_26] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(center_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(center_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(center_1, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const center_1_changes = {};
      if (dirty & /*$$scope*/
      262144) {
        center_1_changes.$$scope = { dirty, ctx: ctx9 };
      }
      center_1.$set(center_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(center_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(center_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(center_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_116.name,
    type: "if",
    source: "(60:2) {#if center}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_26(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[18],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[18],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_26.name,
    type: "slot",
    source: "(61:3) <Center>",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_113(ctx8) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_116, create_else_block_12];
  const if_blocks = [];
  function select_block_type_1(ctx9, dirty) {
    if (
      /*center*/
      ctx9[7]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx8, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx8);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx9, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx9, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx9);
          if_block.c();
        } else {
          if_block.p(ctx9, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_113.name,
    type: "slot",
    source: "(53:1) <Box   use={[forwardEvents, [useActions, use]]}   bind:element   css={{ ...background, ...baseStyles, opacity, borderRadius: `${radius}`, ...override }}   {...$$restProps}   class={className}  >",
    ctx: ctx8
  });
  return block;
}
function create_default_slot58(ctx8) {
  let box;
  let current;
  box = new Box_default({
    props: {
      css: {
        .../*background*/
        ctx8[9],
        .../*baseStyles*/
        ctx8[8],
        opacity: (
          /*opacity*/
          ctx8[4]
        ),
        borderRadius: `${/*radius*/
        ctx8[6]}`,
        .../*override*/
        ctx8[3]
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const box_changes = {};
      if (dirty & /*background, baseStyles, opacity, radius, override*/
      856)
        box_changes.css = {
          .../*background*/
          ctx9[9],
          .../*baseStyles*/
          ctx9[8],
          opacity: (
            /*opacity*/
            ctx9[4]
          ),
          borderRadius: `${/*radius*/
          ctx9[6]}`,
          .../*override*/
          ctx9[3]
        };
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot58.name,
    type: "slot",
    source: "(43:1) <Box   use={[forwardEvents, [useActions, use]]}   bind:element   css={{ ...baseStyles, backdropFilter: `blur(${blur}px)` }}   class={className}   {...$$restProps}  >",
    ctx: ctx8
  });
  return block;
}
function create_fragment78(ctx8) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block28, create_else_block12];
  const if_blocks = [];
  function select_block_type(ctx9, dirty) {
    if (
      /*blur*/
      ctx9[5]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx8, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx8);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx9, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx9, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx9);
          if_block.c();
        } else {
          if_block.p(ctx9, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment78.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance78($$self, $$props, $$invalidate) {
  let background;
  let baseStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "opacity",
    "color",
    "blur",
    "gradient",
    "zIndex",
    "radius",
    "center"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Overlay", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, opacity: opacity2 = 0.6, color = "#fff", blur: blur2 = 0, gradient = "", zIndex = getDefaultZIndex("modal"), radius: radius2 = 0, center = false } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  function box_element_binding_1(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("opacity" in $$new_props)
      $$invalidate(4, opacity2 = $$new_props.opacity);
    if ("color" in $$new_props)
      $$invalidate(12, color = $$new_props.color);
    if ("blur" in $$new_props)
      $$invalidate(5, blur2 = $$new_props.blur);
    if ("gradient" in $$new_props)
      $$invalidate(13, gradient = $$new_props.gradient);
    if ("zIndex" in $$new_props)
      $$invalidate(14, zIndex = $$new_props.zIndex);
    if ("radius" in $$new_props)
      $$invalidate(6, radius2 = $$new_props.radius);
    if ("center" in $$new_props)
      $$invalidate(7, center = $$new_props.center);
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    get_current_component,
    createEventForwarder,
    useActions,
    Box: Box_default,
    Center: Center_default,
    getDefaultZIndex,
    use,
    element: element2,
    className,
    override,
    opacity: opacity2,
    color,
    blur: blur2,
    gradient,
    zIndex,
    radius: radius2,
    center,
    forwardEvents,
    baseStyles,
    background
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("opacity" in $$props)
      $$invalidate(4, opacity2 = $$new_props.opacity);
    if ("color" in $$props)
      $$invalidate(12, color = $$new_props.color);
    if ("blur" in $$props)
      $$invalidate(5, blur2 = $$new_props.blur);
    if ("gradient" in $$props)
      $$invalidate(13, gradient = $$new_props.gradient);
    if ("zIndex" in $$props)
      $$invalidate(14, zIndex = $$new_props.zIndex);
    if ("radius" in $$props)
      $$invalidate(6, radius2 = $$new_props.radius);
    if ("center" in $$props)
      $$invalidate(7, center = $$new_props.center);
    if ("baseStyles" in $$props)
      $$invalidate(8, baseStyles = $$new_props.baseStyles);
    if ("background" in $$props)
      $$invalidate(9, background = $$new_props.background);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*gradient, color*/
    12288) {
      $:
        $$invalidate(9, background = gradient ? { backgroundImage: gradient } : { backgroundColor: color });
    }
    if ($$self.$$.dirty & /*zIndex*/
    16384) {
      $:
        $$invalidate(8, baseStyles = {
          position: "absolute",
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
          zIndex
        });
    }
  };
  return [
    element2,
    use,
    className,
    override,
    opacity2,
    blur2,
    radius2,
    center,
    baseStyles,
    background,
    forwardEvents,
    $$restProps,
    color,
    gradient,
    zIndex,
    slots,
    box_element_binding,
    box_element_binding_1,
    $$scope
  ];
}
var Overlay = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance78, create_fragment78, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      opacity: 4,
      color: 12,
      blur: 5,
      gradient: 13,
      zIndex: 14,
      radius: 6,
      center: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Overlay",
      options,
      id: create_fragment78.name
    });
  }
  get use() {
    throw new Error("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blur() {
    throw new Error("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blur(value) {
    throw new Error("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gradient() {
    throw new Error("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gradient(value) {
    throw new Error("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get center() {
    throw new Error("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set center(value) {
    throw new Error("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Overlay_default = Overlay;

// node_modules/@svelteuidev/core/dist/components/Modal/Modal.styles.js
var sizes11 = {
  xs: 320,
  sm: 380,
  md: 440,
  lg: 620,
  xl: 780,
  full: "100%"
};
var Modal_styles_default = createStyles((theme4, { centered, overflow, size: size3, zIndex }) => {
  const customSize = size3 in sizes11 === false;
  return {
    close: {},
    overlay: {},
    root: {
      position: "fixed",
      zIndex,
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    },
    inner: {
      position: "absolute",
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      overflowY: "auto",
      padding: `${+theme4.space.xl.value * 2}px ${+theme4.space.md.value}px`,
      display: "flex",
      justifyContent: "center",
      alignItems: centered ? "center" : "flex-start"
    },
    transition: {
      display: "flex",
      justifyContent: "center",
      width: "100%",
      maxWidth: "100%"
    },
    title: {
      marginRight: +theme4.space.md.value,
      textOverflow: "ellipsis",
      display: "block",
      wordBreak: "break-word",
      fontFamily: theme4.fonts.standard.value
    },
    modal: {
      [`${theme4.dark} &`]: {
        backgroundColor: theme4.fn.themeColor("dark", 7)
      },
      position: "relative",
      width: typeof size3 === "string" && customSize ? size3 : theme4.fn.size({ sizes: sizes11, size: size3 }),
      outline: 0,
      backgroundColor: "white",
      marginTop: centered ? "auto" : void 0,
      marginBottom: centered ? "auto" : void 0,
      zIndex: 1
    },
    header: {
      display: "flex",
      alignItems: "center",
      justifyContent: "space-between",
      marginBottom: parseInt(theme4.space.md.value),
      marginRight: -9
    },
    body: {
      maxHeight: overflow === "inside" ? "calc(100vh - 185px)" : null,
      overflowY: overflow === "inside" ? "auto" : null,
      wordBreak: "break-word"
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Modal/Modal.svelte
var { Error: Error_17 } = globals;
var file34 = "node_modules/@svelteuidev/core/dist/components/Modal/Modal.svelte";
var get_title_slot_changes = (dirty) => ({});
var get_title_slot_context = (ctx8) => ({});
function create_if_block29(ctx8) {
  let optionalportal;
  let current;
  optionalportal = new OptionalPortal_default({
    props: {
      class: (
        /*zIndexStyles*/
        ctx8[32]()
      ),
      withinPortal: (
        /*withinPortal*/
        ctx8[19]
      ),
      target: (
        /*target*/
        ctx8[18]
      ),
      $$slots: { default: [create_default_slot59] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(optionalportal.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(optionalportal.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(optionalportal, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const optionalportal_changes = {};
      if (dirty[0] & /*withinPortal*/
      524288)
        optionalportal_changes.withinPortal = /*withinPortal*/
        ctx9[19];
      if (dirty[0] & /*target*/
      262144)
        optionalportal_changes.target = /*target*/
        ctx9[18];
      if (dirty[0] & /*use, cx, className, classes, getStyles, override, element, overlayTransitionOptions, overlayBlur, overlayColor, closeOnClickOutside, lockScroll, closeOnEscape, transitionOptions, shadow, padding, radius, trapFocus, closeButtonLabel, withCloseButton, title*/
      41156591 | dirty[1] & /*$$scope, $$restProps*/
      32772) {
        optionalportal_changes.$$scope = { dirty, ctx: ctx9 };
      }
      optionalportal.$set(optionalportal_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(optionalportal.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(optionalportal.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(optionalportal, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block29.name,
    type: "if",
    source: "(52:0) {#if opened}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_117(ctx8) {
  let div;
  let t;
  let div_class_value;
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx8[42].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[46],
    get_title_slot_context
  );
  const title_slot_or_fallback = title_slot || fallback_block_14(ctx8);
  let if_block = (
    /*withCloseButton*/
    ctx8[6] && create_if_block_210(ctx8)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (title_slot_or_fallback)
        title_slot_or_fallback.c();
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (title_slot_or_fallback)
        title_slot_or_fallback.l(div_nodes);
      t = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*classes*/
      ctx8[21].header);
      add_location(div, file34, 84, 7, 3526);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (title_slot_or_fallback) {
        title_slot_or_fallback.m(div, null);
      }
      append_hydration_dev(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty[1] & /*$$scope*/
        32768)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[46],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[46]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx9[46],
              dirty,
              get_title_slot_changes
            ),
            get_title_slot_context
          );
        }
      } else {
        if (title_slot_or_fallback && title_slot_or_fallback.p && (!current || dirty[0] & /*classes, title*/
        2097184)) {
          title_slot_or_fallback.p(ctx9, !current ? [-1, -1] : dirty);
        }
      }
      if (
        /*withCloseButton*/
        ctx9[6]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
          if (dirty[0] & /*withCloseButton*/
          64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_210(ctx9);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*classes*/
      2097152 && div_class_value !== (div_class_value = /*classes*/
      ctx9[21].header)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(title_slot_or_fallback, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(title_slot_or_fallback, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (title_slot_or_fallback)
        title_slot_or_fallback.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_117.name,
    type: "if",
    source: "(84:6) {#if title || withCloseButton}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_33(ctx8) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*title*/
        ctx8[5]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*title*/
        ctx8[5]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*title*/
      32)
        set_data_dev(
          t,
          /*title*/
          ctx9[5]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_33.name,
    type: "slot",
    source: "(87:9) <Text id={titleId} class={classes.title}>",
    ctx: ctx8
  });
  return block;
}
function fallback_block_14(ctx8) {
  let text_1;
  let current;
  text_1 = new Text_default({
    props: {
      id: (
        /*titleId*/
        ctx8[28]
      ),
      class: (
        /*classes*/
        ctx8[21].title
      ),
      $$slots: { default: [create_default_slot_33] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(text_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(text_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(text_1, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const text_1_changes = {};
      if (dirty[0] & /*classes*/
      2097152)
        text_1_changes.class = /*classes*/
        ctx9[21].title;
      if (dirty[0] & /*title*/
      32 | dirty[1] & /*$$scope*/
      32768) {
        text_1_changes.$$scope = { dirty, ctx: ctx9 };
      }
      text_1.$set(text_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(text_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_14.name,
    type: "fallback",
    source: "(86:27)           ",
    ctx: ctx8
  });
  return block;
}
function create_if_block_210(ctx8) {
  let closebutton;
  let current;
  closebutton = new CloseButton_default({
    props: {
      iconSize: 16,
      "aria-label": (
        /*closeButtonLabel*/
        ctx8[12]
      ),
      class: (
        /*classes*/
        ctx8[21].close
      )
    },
    $$inline: true
  });
  closebutton.$on(
    "click",
    /*onClose*/
    ctx8[31]
  );
  const block = {
    c: function create() {
      create_component(closebutton.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(closebutton.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(closebutton, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const closebutton_changes = {};
      if (dirty[0] & /*closeButtonLabel*/
      4096)
        closebutton_changes["aria-label"] = /*closeButtonLabel*/
        ctx9[12];
      if (dirty[0] & /*classes*/
      2097152)
        closebutton_changes.class = /*classes*/
        ctx9[21].close;
      closebutton.$set(closebutton_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(closebutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(closebutton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(closebutton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_210.name,
    type: "if",
    source: "(92:8) {#if withCloseButton}",
    ctx: ctx8
  });
  return block;
}
function fallback_block17(ctx8) {
  let t;
  const block = {
    c: function create() {
      t = text("Place some content");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Place some content");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block17.name,
    type: "fallback",
    source: "(103:13) Place some content",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_27(ctx8) {
  let t;
  let div;
  let div_class_value;
  let current;
  let if_block = (
    /*title*/
    (ctx8[5] || /*withCloseButton*/
    ctx8[6]) && create_if_block_117(ctx8)
  );
  const default_slot_template = (
    /*#slots*/
    ctx8[42].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[46],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block17(ctx8);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      div = element("div");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t = claim_space(nodes);
      div = claim_element(nodes, "DIV", { id: true, class: true });
      var div_nodes = children(div);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "id",
        /*bodyId*/
        ctx8[29]
      );
      attr_dev(div, "class", div_class_value = /*classes*/
      ctx8[21].body);
      add_location(div, file34, 101, 6, 3921);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, div, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (
        /*title*/
        ctx9[5] || /*withCloseButton*/
        ctx9[6]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
          if (dirty[0] & /*title, withCloseButton*/
          96) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_117(ctx9);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[46],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[46]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[46],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*classes*/
      2097152 && div_class_value !== (div_class_value = /*classes*/
      ctx9[21].body)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(div);
      }
      if (if_block)
        if_block.d(detaching);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_27.name,
    type: "slot",
    source: '(72:5) <Paper       class={classes.modal}       {shadow}       {padding}       {radius}       role=\\"dialog\\"       aria-labelledby={titleId}       aria-describedby={bodyId}       aria-modal       tabindex={-1}       use={[[focustrap, trapFocus]]}      >',
    ctx: ctx8
  });
  return block;
}
function create_default_slot_114(ctx8) {
  let div1;
  let div0;
  let paper;
  let div0_class_value;
  let div0_transition;
  let div1_class_value;
  let lockscroll_action;
  let t;
  let div2;
  let overlay;
  let div2_transition;
  let current;
  let mounted;
  let dispose;
  paper = new Paper_default({
    props: {
      class: (
        /*classes*/
        ctx8[21].modal
      ),
      shadow: (
        /*shadow*/
        ctx8[13]
      ),
      padding: (
        /*padding*/
        ctx8[14]
      ),
      radius: (
        /*radius*/
        ctx8[9]
      ),
      role: "dialog",
      "aria-labelledby": (
        /*titleId*/
        ctx8[28]
      ),
      "aria-describedby": (
        /*bodyId*/
        ctx8[29]
      ),
      "aria-modal": true,
      tabindex: -1,
      use: [[
        focustrap,
        /*trapFocus*/
        ctx8[17]
      ]],
      $$slots: { default: [create_default_slot_27] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  overlay = new Overlay_default({
    props: {
      class: (
        /*classes*/
        ctx8[21].overlay
      ),
      override: { position: "fixed" },
      zIndex: 0,
      blur: (
        /*overlayBlur*/
        ctx8[8]
      ),
      color: (
        /*overlayColor*/
        ctx8[7] || "black"
      ),
      opacity: (
        /*_overlayOpacity*/
        ctx8[30]
      )
    },
    $$inline: true
  });
  overlay.$on(
    "mousedown",
    /*mousedown_handler*/
    ctx8[44]
  );
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      create_component(paper.$$.fragment);
      t = space();
      div2 = element("div");
      create_component(overlay.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { role: true, class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(paper.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t = claim_space(nodes);
      div2 = claim_element(nodes, "DIV", {});
      var div2_nodes = children(div2);
      claim_component(overlay.$$.fragment, div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = /*classes*/
      ctx8[21].transition);
      add_location(div0, file34, 70, 4, 3155);
      attr_dev(div1, "role", "presentation");
      attr_dev(div1, "class", div1_class_value = /*classes*/
      ctx8[21].inner);
      add_location(div1, file34, 60, 3, 2823);
      add_location(div2, file34, 107, 3, 4050);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      mount_component(paper, div0, null);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, div2, anchor);
      mount_component(overlay, div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(lockscroll_action = lockscroll.call(
            null,
            div1,
            /*lockScroll*/
            ctx8[25]
          )),
          listen_dev(
            div1,
            "keydown",
            /*keydown_handler*/
            ctx8[43],
            true,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx8 = new_ctx;
      const paper_changes = {};
      if (dirty[0] & /*classes*/
      2097152)
        paper_changes.class = /*classes*/
        ctx8[21].modal;
      if (dirty[0] & /*shadow*/
      8192)
        paper_changes.shadow = /*shadow*/
        ctx8[13];
      if (dirty[0] & /*padding*/
      16384)
        paper_changes.padding = /*padding*/
        ctx8[14];
      if (dirty[0] & /*radius*/
      512)
        paper_changes.radius = /*radius*/
        ctx8[9];
      if (dirty[0] & /*trapFocus*/
      131072)
        paper_changes.use = [[
          focustrap,
          /*trapFocus*/
          ctx8[17]
        ]];
      if (dirty[0] & /*classes, closeButtonLabel, withCloseButton, title*/
      2101344 | dirty[1] & /*$$scope*/
      32768) {
        paper_changes.$$scope = { dirty, ctx: ctx8 };
      }
      paper.$set(paper_changes);
      if (!current || dirty[0] & /*classes*/
      2097152 && div0_class_value !== (div0_class_value = /*classes*/
      ctx8[21].transition)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty[0] & /*classes*/
      2097152 && div1_class_value !== (div1_class_value = /*classes*/
      ctx8[21].inner)) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (lockscroll_action && is_function(lockscroll_action.update) && dirty[0] & /*lockScroll*/
      33554432)
        lockscroll_action.update.call(
          null,
          /*lockScroll*/
          ctx8[25]
        );
      const overlay_changes = {};
      if (dirty[0] & /*classes*/
      2097152)
        overlay_changes.class = /*classes*/
        ctx8[21].overlay;
      if (dirty[0] & /*overlayBlur*/
      256)
        overlay_changes.blur = /*overlayBlur*/
        ctx8[8];
      if (dirty[0] & /*overlayColor*/
      128)
        overlay_changes.color = /*overlayColor*/
        ctx8[7] || "black";
      overlay.$set(overlay_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(paper.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div0_transition)
            div0_transition = create_bidirectional_transition(
              div0,
              /*_transition*/
              ctx8[24],
              /*transitionOptions*/
              ctx8[10],
              true
            );
          div0_transition.run(1);
        });
      }
      transition_in(overlay.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div2_transition)
            div2_transition = create_bidirectional_transition(
              div2,
              /*_overlayTransition*/
              ctx8[23],
              /*overlayTransitionOptions*/
              ctx8[11],
              true
            );
          div2_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(paper.$$.fragment, local);
      if (local) {
        if (!div0_transition)
          div0_transition = create_bidirectional_transition(
            div0,
            /*_transition*/
            ctx8[24],
            /*transitionOptions*/
            ctx8[10],
            false
          );
        div0_transition.run(0);
      }
      transition_out(overlay.$$.fragment, local);
      if (local) {
        if (!div2_transition)
          div2_transition = create_bidirectional_transition(
            div2,
            /*_overlayTransition*/
            ctx8[23],
            /*overlayTransitionOptions*/
            ctx8[11],
            false
          );
        div2_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
        detach_dev(t);
        detach_dev(div2);
      }
      destroy_component(paper);
      if (detaching && div0_transition)
        div0_transition.end();
      destroy_component(overlay);
      if (detaching && div2_transition)
        div2_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_114.name,
    type: "slot",
    source: "(54:2) <Box    id={baseId}    bind:element    {use}    {...$$restProps}    class={cx(className, classes.root, getStyles({ css: override }))}   >",
    ctx: ctx8
  });
  return block;
}
function create_default_slot59(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { id: (
      /*baseId*/
      ctx8[27]
    ) },
    { use: (
      /*use*/
      ctx8[1]
    ) },
    /*$$restProps*/
    ctx8[33],
    {
      class: (
        /*cx*/
        ctx8[22](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[21].root,
          /*getStyles*/
          ctx8[20]({ css: (
            /*override*/
            ctx8[3]
          ) })
        )
      )
    }
  ];
  function box_element_binding(value) {
    ctx8[45](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot_114] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const box_changes = dirty[0] & /*baseId, use, cx, className, classes, getStyles, override*/
      141557774 | dirty[1] & /*$$restProps*/
      4 ? get_spread_update(box_spread_levels, [
        dirty[0] & /*baseId*/
        134217728 && { id: (
          /*baseId*/
          ctx9[27]
        ) },
        dirty[0] & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty[1] & /*$$restProps*/
        4 && get_spread_object(
          /*$$restProps*/
          ctx9[33]
        ),
        dirty[0] & /*cx, className, classes, getStyles, override*/
        7340044 && {
          class: (
            /*cx*/
            ctx9[22](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[21].root,
              /*getStyles*/
              ctx9[20]({ css: (
                /*override*/
                ctx9[3]
              ) })
            )
          )
        }
      ]) : {};
      if (dirty[0] & /*overlayTransitionOptions, classes, overlayBlur, overlayColor, closeOnClickOutside, lockScroll, closeOnEscape, transitionOptions, shadow, padding, radius, trapFocus, closeButtonLabel, withCloseButton, title*/
      35913696 | dirty[1] & /*$$scope*/
      32768) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty[0] & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot59.name,
    type: "slot",
    source: "(53:1) <OptionalPortal class={zIndexStyles()} {withinPortal} {target}>",
    ctx: ctx8
  });
  return block;
}
function create_fragment79(ctx8) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*opened*/
    ctx8[4] && create_if_block29(ctx8)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (
        /*opened*/
        ctx9[4]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
          if (dirty[0] & /*opened*/
          16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block29(ctx9);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment79.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance79($$self, $$props, $$invalidate) {
  let lockScroll;
  let _transition;
  let _overlayTransition;
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "opened",
    "title",
    "zIndex",
    "overflow",
    "withCloseButton",
    "overlayOpacity",
    "overlayColor",
    "overlayBlur",
    "radius",
    "size",
    "transition",
    "transitionOptions",
    "overlayTransition",
    "overlayTransitionOptions",
    "closeButtonLabel",
    "id",
    "shadow",
    "padding",
    "closeOnClickOutside",
    "closeOnEscape",
    "trapFocus",
    "centered",
    "target",
    "withinPortal"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $colorScheme;
  validate_store(colorScheme, "colorScheme");
  component_subscribe($$self, colorScheme, ($$value) => $$invalidate(47, $colorScheme = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Modal", slots, ["title", "default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, opened = false, title = "", zIndex = 200, overflow = "outside", withCloseButton = true, overlayOpacity = null, overlayColor = null, overlayBlur = 0, radius: radius2 = "sm", size: size3 = "md", transition = "scale", transitionOptions = { duration: 100, easing: sineInOut }, overlayTransition = "fade", overlayTransitionOptions = { duration: 200, easing: sineInOut }, closeButtonLabel = "svelteui-close-button", id = "svelteui", shadow = "lg", padding: padding3 = "lg", closeOnClickOutside = true, closeOnEscape = true, trapFocus = true, centered = null, target = "#SVELTEUI_PROVIDER", withinPortal = true } = $$props;
  const dispatch = createEventDispatcher();
  const castAny = (self) => self;
  const baseId = randomID(id);
  const titleId = `${baseId}-title`;
  const bodyId = `${baseId}-body`;
  const _overlayOpacity = typeof overlayOpacity === "number" ? overlayOpacity : $colorScheme === "dark" ? 0.85 : 0.75;
  const { handleFocusReturn } = useFocusReturn();
  const closeOnEscapePress = (event) => {
    if (!trapFocus && event.code === "Escape" && closeOnEscape) {
      onClose();
    }
  };
  function onClose() {
    dispatch("close");
  }
  const zIndexStyles = css({ zIndex });
  const keydown_handler = (event) => {
    var _a;
    const shouldTrigger = ((_a = castAny(event.target)) == null ? void 0 : _a.getAttribute("data-svelteui-stop-propagation")) !== "true";
    shouldTrigger && event.code === "Escape" && closeOnEscape && onClose();
  };
  const mousedown_handler = () => closeOnClickOutside && onClose();
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(33, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("opened" in $$new_props)
      $$invalidate(4, opened = $$new_props.opened);
    if ("title" in $$new_props)
      $$invalidate(5, title = $$new_props.title);
    if ("zIndex" in $$new_props)
      $$invalidate(34, zIndex = $$new_props.zIndex);
    if ("overflow" in $$new_props)
      $$invalidate(35, overflow = $$new_props.overflow);
    if ("withCloseButton" in $$new_props)
      $$invalidate(6, withCloseButton = $$new_props.withCloseButton);
    if ("overlayOpacity" in $$new_props)
      $$invalidate(36, overlayOpacity = $$new_props.overlayOpacity);
    if ("overlayColor" in $$new_props)
      $$invalidate(7, overlayColor = $$new_props.overlayColor);
    if ("overlayBlur" in $$new_props)
      $$invalidate(8, overlayBlur = $$new_props.overlayBlur);
    if ("radius" in $$new_props)
      $$invalidate(9, radius2 = $$new_props.radius);
    if ("size" in $$new_props)
      $$invalidate(37, size3 = $$new_props.size);
    if ("transition" in $$new_props)
      $$invalidate(38, transition = $$new_props.transition);
    if ("transitionOptions" in $$new_props)
      $$invalidate(10, transitionOptions = $$new_props.transitionOptions);
    if ("overlayTransition" in $$new_props)
      $$invalidate(39, overlayTransition = $$new_props.overlayTransition);
    if ("overlayTransitionOptions" in $$new_props)
      $$invalidate(11, overlayTransitionOptions = $$new_props.overlayTransitionOptions);
    if ("closeButtonLabel" in $$new_props)
      $$invalidate(12, closeButtonLabel = $$new_props.closeButtonLabel);
    if ("id" in $$new_props)
      $$invalidate(40, id = $$new_props.id);
    if ("shadow" in $$new_props)
      $$invalidate(13, shadow = $$new_props.shadow);
    if ("padding" in $$new_props)
      $$invalidate(14, padding3 = $$new_props.padding);
    if ("closeOnClickOutside" in $$new_props)
      $$invalidate(15, closeOnClickOutside = $$new_props.closeOnClickOutside);
    if ("closeOnEscape" in $$new_props)
      $$invalidate(16, closeOnEscape = $$new_props.closeOnEscape);
    if ("trapFocus" in $$new_props)
      $$invalidate(17, trapFocus = $$new_props.trapFocus);
    if ("centered" in $$new_props)
      $$invalidate(41, centered = $$new_props.centered);
    if ("target" in $$new_props)
      $$invalidate(18, target = $$new_props.target);
    if ("withinPortal" in $$new_props)
      $$invalidate(19, withinPortal = $$new_props.withinPortal);
    if ("$$scope" in $$new_props)
      $$invalidate(46, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    fade,
    scale,
    sineInOut,
    focustrap,
    lockscroll,
    useFocusReturn,
    getTransition,
    randomID,
    colorScheme,
    css,
    CloseButton: CloseButton_default,
    Box: Box_default,
    Overlay: Overlay_default,
    Paper: Paper_default,
    OptionalPortal: OptionalPortal_default,
    Text: Text_default,
    useStyles: Modal_styles_default,
    use,
    element: element2,
    className,
    override,
    opened,
    title,
    zIndex,
    overflow,
    withCloseButton,
    overlayOpacity,
    overlayColor,
    overlayBlur,
    radius: radius2,
    size: size3,
    transition,
    transitionOptions,
    overlayTransition,
    overlayTransitionOptions,
    closeButtonLabel,
    id,
    shadow,
    padding: padding3,
    closeOnClickOutside,
    closeOnEscape,
    trapFocus,
    centered,
    target,
    withinPortal,
    dispatch,
    castAny,
    baseId,
    titleId,
    bodyId,
    _overlayOpacity,
    handleFocusReturn,
    closeOnEscapePress,
    onClose,
    zIndexStyles,
    getStyles,
    classes,
    cx: cx2,
    _overlayTransition,
    _transition,
    lockScroll,
    $colorScheme
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("opened" in $$props)
      $$invalidate(4, opened = $$new_props.opened);
    if ("title" in $$props)
      $$invalidate(5, title = $$new_props.title);
    if ("zIndex" in $$props)
      $$invalidate(34, zIndex = $$new_props.zIndex);
    if ("overflow" in $$props)
      $$invalidate(35, overflow = $$new_props.overflow);
    if ("withCloseButton" in $$props)
      $$invalidate(6, withCloseButton = $$new_props.withCloseButton);
    if ("overlayOpacity" in $$props)
      $$invalidate(36, overlayOpacity = $$new_props.overlayOpacity);
    if ("overlayColor" in $$props)
      $$invalidate(7, overlayColor = $$new_props.overlayColor);
    if ("overlayBlur" in $$props)
      $$invalidate(8, overlayBlur = $$new_props.overlayBlur);
    if ("radius" in $$props)
      $$invalidate(9, radius2 = $$new_props.radius);
    if ("size" in $$props)
      $$invalidate(37, size3 = $$new_props.size);
    if ("transition" in $$props)
      $$invalidate(38, transition = $$new_props.transition);
    if ("transitionOptions" in $$props)
      $$invalidate(10, transitionOptions = $$new_props.transitionOptions);
    if ("overlayTransition" in $$props)
      $$invalidate(39, overlayTransition = $$new_props.overlayTransition);
    if ("overlayTransitionOptions" in $$props)
      $$invalidate(11, overlayTransitionOptions = $$new_props.overlayTransitionOptions);
    if ("closeButtonLabel" in $$props)
      $$invalidate(12, closeButtonLabel = $$new_props.closeButtonLabel);
    if ("id" in $$props)
      $$invalidate(40, id = $$new_props.id);
    if ("shadow" in $$props)
      $$invalidate(13, shadow = $$new_props.shadow);
    if ("padding" in $$props)
      $$invalidate(14, padding3 = $$new_props.padding);
    if ("closeOnClickOutside" in $$props)
      $$invalidate(15, closeOnClickOutside = $$new_props.closeOnClickOutside);
    if ("closeOnEscape" in $$props)
      $$invalidate(16, closeOnEscape = $$new_props.closeOnEscape);
    if ("trapFocus" in $$props)
      $$invalidate(17, trapFocus = $$new_props.trapFocus);
    if ("centered" in $$props)
      $$invalidate(41, centered = $$new_props.centered);
    if ("target" in $$props)
      $$invalidate(18, target = $$new_props.target);
    if ("withinPortal" in $$props)
      $$invalidate(19, withinPortal = $$new_props.withinPortal);
    if ("getStyles" in $$props)
      $$invalidate(20, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(21, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(22, cx2 = $$new_props.cx);
    if ("_overlayTransition" in $$props)
      $$invalidate(23, _overlayTransition = $$new_props._overlayTransition);
    if ("_transition" in $$props)
      $$invalidate(24, _transition = $$new_props._transition);
    if ("lockScroll" in $$props)
      $$invalidate(25, lockScroll = $$new_props.lockScroll);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*opened*/
    16) {
      $:
        handleFocusReturn(opened);
    }
    if ($$self.$$.dirty[0] & /*trapFocus*/
    131072) {
      $: {
        onMount(() => {
          if (!trapFocus) {
            typeof window !== "undefined" ? window.addEventListener("keydown", closeOnEscapePress) : null;
          }
        });
      }
    }
    if ($$self.$$.dirty[0] & /*opened, target*/
    262160) {
      $:
        if (opened && (typeof target === "string" && !document.querySelector(target) || !target)) {
          throw new Error(`Wrap your app in the SvelteUIProvider, or provide a sufficent target throught the "target={''}" prop `);
        }
    }
    if ($$self.$$.dirty[0] & /*opened*/
    16) {
      $:
        $$invalidate(25, lockScroll = opened);
    }
    if ($$self.$$.dirty[1] & /*transition*/
    128) {
      $:
        $$invalidate(24, _transition = getTransition(transition));
    }
    if ($$self.$$.dirty[1] & /*overlayTransition*/
    256) {
      $:
        $$invalidate(23, _overlayTransition = getTransition(overlayTransition));
    }
    if ($$self.$$.dirty[1] & /*centered, overflow, size, zIndex*/
    1112) {
      $:
        $$invalidate(22, { cx: cx2, classes, getStyles } = Modal_styles_default({ centered, overflow, size: size3, zIndex }, { name: "Modal" }), cx2, ($$invalidate(21, classes), $$invalidate(41, centered), $$invalidate(35, overflow), $$invalidate(37, size3), $$invalidate(34, zIndex)), ($$invalidate(20, getStyles), $$invalidate(41, centered), $$invalidate(35, overflow), $$invalidate(37, size3), $$invalidate(34, zIndex)));
    }
  };
  return [
    element2,
    use,
    className,
    override,
    opened,
    title,
    withCloseButton,
    overlayColor,
    overlayBlur,
    radius2,
    transitionOptions,
    overlayTransitionOptions,
    closeButtonLabel,
    shadow,
    padding3,
    closeOnClickOutside,
    closeOnEscape,
    trapFocus,
    target,
    withinPortal,
    getStyles,
    classes,
    cx2,
    _overlayTransition,
    _transition,
    lockScroll,
    castAny,
    baseId,
    titleId,
    bodyId,
    _overlayOpacity,
    onClose,
    zIndexStyles,
    $$restProps,
    zIndex,
    overflow,
    overlayOpacity,
    size3,
    transition,
    overlayTransition,
    id,
    centered,
    slots,
    keydown_handler,
    mousedown_handler,
    box_element_binding,
    $$scope
  ];
}
var Modal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance79,
      create_fragment79,
      safe_not_equal,
      {
        use: 1,
        element: 0,
        class: 2,
        override: 3,
        opened: 4,
        title: 5,
        zIndex: 34,
        overflow: 35,
        withCloseButton: 6,
        overlayOpacity: 36,
        overlayColor: 7,
        overlayBlur: 8,
        radius: 9,
        size: 37,
        transition: 38,
        transitionOptions: 10,
        overlayTransition: 39,
        overlayTransitionOptions: 11,
        closeButtonLabel: 12,
        id: 40,
        shadow: 13,
        padding: 14,
        closeOnClickOutside: 15,
        closeOnEscape: 16,
        trapFocus: 17,
        centered: 41,
        target: 18,
        withinPortal: 19
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Modal",
      options,
      id: create_fragment79.name
    });
  }
  get use() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opened() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opened(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get overflow() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set overflow(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withCloseButton() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withCloseButton(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get overlayOpacity() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set overlayOpacity(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get overlayColor() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set overlayColor(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get overlayBlur() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set overlayBlur(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transition() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionOptions() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionOptions(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get overlayTransition() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set overlayTransition(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get overlayTransitionOptions() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set overlayTransitionOptions(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeButtonLabel() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeButtonLabel(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnClickOutside() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnClickOutside(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnEscape() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnEscape(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get trapFocus() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set trapFocus(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get centered() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set centered(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get target() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set target(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withinPortal() {
    throw new Error_17("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withinPortal(value) {
    throw new Error_17("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Modal_default = Modal;

// node_modules/@svelteuidev/core/dist/components/NativeSelect/ChevronUpDown.svelte
var file35 = "node_modules/@svelteuidev/core/dist/components/NativeSelect/ChevronUpDown.svelte";
function create_fragment80(ctx8) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        fill: true,
        xmlns: true,
        style: true,
        "data-chevron": true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", {
        d: true,
        fill: true,
        "fill-rule": true,
        "clip-rule": true
      });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4.93179 5.43179C4.75605 5.60753 4.75605 5.89245 4.93179 6.06819C5.10753 6.24392 5.39245 6.24392 5.56819 6.06819L7.49999 4.13638L9.43179 6.06819C9.60753 6.24392 9.89245 6.24392 10.0682 6.06819C10.2439 5.89245 10.2439 5.60753 10.0682 5.43179L7.81819 3.18179C7.73379 3.0974 7.61933 3.04999 7.49999 3.04999C7.38064 3.04999 7.26618 3.0974 7.18179 3.18179L4.93179 5.43179ZM10.0682 9.56819C10.2439 9.39245 10.2439 9.10753 10.0682 8.93179C9.89245 8.75606 9.60753 8.75606 9.43179 8.93179L7.49999 10.8636L5.56819 8.93179C5.39245 8.75606 5.10753 8.75606 4.93179 8.93179C4.75605 9.10753 4.75605 9.39245 4.93179 9.56819L7.18179 11.8182C7.35753 11.9939 7.64245 11.9939 7.81819 11.8182L10.0682 9.56819Z");
      attr_dev(
        path,
        "fill",
        /*color*/
        ctx8[0]
      );
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "clip-rule", "evenodd");
      add_location(path, file35, 13, 2, 229);
      attr_dev(
        svg,
        "width",
        /*size*/
        ctx8[1]
      );
      attr_dev(
        svg,
        "height",
        /*size*/
        ctx8[1]
      );
      attr_dev(svg, "viewBox", "0 0 15 15");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      set_style(svg, "color", "#868e96");
      attr_dev(svg, "data-chevron", "true");
      add_location(svg, file35, 5, 0, 79);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx9, [dirty]) {
      if (dirty & /*color*/
      1) {
        attr_dev(
          path,
          "fill",
          /*color*/
          ctx9[0]
        );
      }
      if (dirty & /*size*/
      2) {
        attr_dev(
          svg,
          "width",
          /*size*/
          ctx9[1]
        );
      }
      if (dirty & /*size*/
      2) {
        attr_dev(
          svg,
          "height",
          /*size*/
          ctx9[1]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment80.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance80($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ChevronUpDown", slots, []);
  let { color = "currentColor" } = $$props;
  let { size: size3 = 15 } = $$props;
  const writable_props = ["color", "size"];
  Object.keys($$props).forEach((key3) => {
    if (!~writable_props.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<ChevronUpDown> was created with unknown prop '${key3}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(0, color = $$props2.color);
    if ("size" in $$props2)
      $$invalidate(1, size3 = $$props2.size);
  };
  $$self.$capture_state = () => ({ color, size: size3 });
  $$self.$inject_state = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(0, color = $$props2.color);
    if ("size" in $$props2)
      $$invalidate(1, size3 = $$props2.size);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [color, size3];
}
var ChevronUpDown = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance80, create_fragment80, safe_not_equal, { color: 0, size: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChevronUpDown",
      options,
      id: create_fragment80.name
    });
  }
  get color() {
    throw new Error("<ChevronUpDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<ChevronUpDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<ChevronUpDown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<ChevronUpDown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ChevronUpDown_default = ChevronUpDown;

// node_modules/@svelteuidev/core/dist/components/NativeSelect/NativeSelect.svelte
var file36 = "node_modules/@svelteuidev/core/dist/components/NativeSelect/NativeSelect.svelte";
function get_each_context4(ctx8, list, i2) {
  const child_ctx = ctx8.slice();
  child_ctx[35] = list[i2];
  return child_ctx;
}
var get_icon_slot_changes6 = (dirty) => ({});
var get_icon_slot_context6 = (ctx8) => ({ slot: "icon" });
var get_rightSection_slot_changes6 = (dirty) => ({
  size: dirty[0] & /*iconProps*/
  2048,
  color: dirty[0] & /*iconProps*/
  2048
});
var get_rightSection_slot_context6 = (ctx8) => ({
  size: (
    /*iconProps*/
    ctx8[11].size
  ),
  color: (
    /*iconProps*/
    ctx8[11].color
  )
});
function create_if_block30(ctx8) {
  let option;
  let t;
  let option_selected_value;
  const block = {
    c: function create() {
      option = element("option");
      t = text(
        /*placeholder*/
        ctx8[5]
      );
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", {});
      var option_nodes = children(option);
      t = claim_text(
        option_nodes,
        /*placeholder*/
        ctx8[5]
      );
      option_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = "";
      set_input_value(option, option.__value);
      option.disabled = true;
      option.hidden = true;
      option.selected = option_selected_value = !/*value*/
      ctx8[1];
      add_location(option, file36, 75, 3, 2376);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
      append_hydration_dev(option, t);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*placeholder*/
      32)
        set_data_dev(
          t,
          /*placeholder*/
          ctx9[5]
        );
      if (dirty[0] & /*value*/
      2 && option_selected_value !== (option_selected_value = !/*value*/
      ctx9[1])) {
        prop_dev(option, "selected", option_selected_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(option);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block30.name,
    type: "if",
    source: "(75:2) {#if placeholder}",
    ctx: ctx8
  });
  return block;
}
function create_else_block13(ctx8) {
  let option;
  let textContent = "Add Some Options";
  const block = {
    c: function create() {
      option = element("option");
      option.textContent = textContent;
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(option) !== "svelte-1worzvr")
        option.textContent = textContent;
      this.h();
    },
    h: function hydrate() {
      option.__value = "";
      set_input_value(option, option.__value);
      option.disabled = true;
      option.hidden = true;
      add_location(option, file36, 85, 3, 2679);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(option);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block13.name,
    type: "else",
    source: "(85:2) {:else}",
    ctx: ctx8
  });
  return block;
}
function create_each_block4(ctx8) {
  let option;
  let t0_value = (
    /*item*/
    (ctx8[35].label ?? /*item*/
    ctx8[35].value) + ""
  );
  let t0;
  let t1;
  let option_value_value;
  let option_disabled_value;
  let option_selected_value;
  const block = {
    c: function create() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", {});
      var option_nodes = children(option);
      t0 = claim_text(option_nodes, t0_value);
      t1 = claim_space(option_nodes);
      option_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = option_value_value = /*item*/
      ctx8[35].value;
      set_input_value(option, option.__value);
      option.disabled = option_disabled_value = /*item*/
      ctx8[35].disabled;
      option.selected = option_selected_value = /*item*/
      ctx8[35].value === /*value*/
      ctx8[1];
      add_location(option, file36, 81, 3, 2537);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
      append_hydration_dev(option, t0);
      append_hydration_dev(option, t1);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*formattedData*/
      16777216 && t0_value !== (t0_value = /*item*/
      (ctx9[35].label ?? /*item*/
      ctx9[35].value) + ""))
        set_data_dev(t0, t0_value);
      if (dirty[0] & /*formattedData*/
      16777216 && option_value_value !== (option_value_value = /*item*/
      ctx9[35].value)) {
        prop_dev(option, "__value", option_value_value);
        set_input_value(option, option.__value);
      }
      if (dirty[0] & /*formattedData*/
      16777216 && option_disabled_value !== (option_disabled_value = /*item*/
      ctx9[35].disabled)) {
        prop_dev(option, "disabled", option_disabled_value);
      }
      if (dirty[0] & /*formattedData, value*/
      16777218 && option_selected_value !== (option_selected_value = /*item*/
      ctx9[35].value === /*value*/
      ctx9[1])) {
        prop_dev(option, "selected", option_selected_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(option);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(81:2) {#each formattedData as item}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_115(ctx8) {
  let t;
  let each_1_anchor;
  let if_block = (
    /*placeholder*/
    ctx8[5] && create_if_block30(ctx8)
  );
  let each_value = ensure_array_like_dev(
    /*formattedData*/
    ctx8[24]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block4(get_each_context4(ctx8, each_value, i2));
  }
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block13(ctx8);
  }
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      if (each_1_else) {
        each_1_else.c();
      }
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t = claim_space(nodes);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
      if (each_1_else) {
        each_1_else.l(nodes);
      }
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      if (each_1_else) {
        each_1_else.m(target, anchor);
      }
    },
    p: function update(ctx9, dirty) {
      if (
        /*placeholder*/
        ctx9[5]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
        } else {
          if_block = create_if_block30(ctx9);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & /*formattedData, value*/
      16777218) {
        each_value = ensure_array_like_dev(
          /*formattedData*/
          ctx9[24]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context4(ctx9, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block4(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx9, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block13(ctx9);
          each_1_else.c();
          each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(each_1_anchor);
      }
      if (if_block)
        if_block.d(detaching);
      destroy_each(each_blocks, detaching);
      if (each_1_else)
        each_1_else.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_115.name,
    type: "slot",
    source: '(52:1) <Input   bind:element   use={[forwardEvents, [useActions, use]]}   bind:value   root=\\"select\\"   id={uuid}   autocomplete=\\"off\\"   invalid={Boolean(error)}   override={{ ...base, ...inputStyle }}   noPointerEventsRightSection   {size}   {icon}   {radius}   {variant}   {required}   {disabled}   {iconWidth}   {iconProps}   {placeholder}   {rightSectionWidth}   {rightSectionProps}   {...$$restProps}  >',
    ctx: ctx8
  });
  return block;
}
function create_icon_slot(ctx8) {
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx8[31].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[34],
    get_icon_slot_context6
  );
  const block = {
    c: function create() {
      if (icon_slot)
        icon_slot.c();
    },
    l: function claim(nodes) {
      if (icon_slot)
        icon_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty[1] & /*$$scope*/
        8)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[34],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[34]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx9[34],
              dirty,
              get_icon_slot_changes6
            ),
            get_icon_slot_context6
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_icon_slot.name,
    type: "slot",
    source: "(80:2) ",
    ctx: ctx8
  });
  return block;
}
function fallback_block18(ctx8) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ChevronUpDown_default;
  function switch_props(ctx9, dirty) {
    return {
      props: {
        size: (
          /*iconProps*/
          ctx9[11].size
        ),
        color: (
          /*iconProps*/
          ctx9[11].color
        )
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx8));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (switch_value !== (switch_value = ChevronUpDown_default)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx9, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty[0] & /*iconProps*/
        2048)
          switch_instance_changes.size = /*iconProps*/
          ctx9[11].size;
        if (dirty[0] & /*iconProps*/
        2048)
          switch_instance_changes.color = /*iconProps*/
          ctx9[11].color;
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block18.name,
    type: "fallback",
    source: "(89:75)      ",
    ctx: ctx8
  });
  return block;
}
function create_rightSection_slot3(ctx8) {
  let current;
  const rightSection_slot_template = (
    /*#slots*/
    ctx8[31].rightSection
  );
  const rightSection_slot = create_slot(
    rightSection_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[34],
    get_rightSection_slot_context6
  );
  const rightSection_slot_or_fallback = rightSection_slot || fallback_block18(ctx8);
  const block = {
    c: function create() {
      if (rightSection_slot_or_fallback)
        rightSection_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (rightSection_slot_or_fallback)
        rightSection_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (rightSection_slot_or_fallback) {
        rightSection_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (rightSection_slot) {
        if (rightSection_slot.p && (!current || dirty[0] & /*iconProps*/
        2048 | dirty[1] & /*$$scope*/
        8)) {
          update_slot_base(
            rightSection_slot,
            rightSection_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[34],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[34]
            ) : get_slot_changes(
              rightSection_slot_template,
              /*$$scope*/
              ctx9[34],
              dirty,
              get_rightSection_slot_changes6
            ),
            get_rightSection_slot_context6
          );
        }
      } else {
        if (rightSection_slot_or_fallback && rightSection_slot_or_fallback.p && (!current || dirty[0] & /*iconProps*/
        2048)) {
          rightSection_slot_or_fallback.p(ctx9, !current ? [-1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rightSection_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rightSection_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (rightSection_slot_or_fallback)
        rightSection_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_rightSection_slot3.name,
    type: "slot",
    source: '(88:2) <svelte:fragment slot=\\"rightSection\\">',
    ctx: ctx8
  });
  return block;
}
function create_default_slot60(ctx8) {
  let input;
  let updating_element;
  let updating_value;
  let current;
  const input_spread_levels = [
    {
      use: [
        /*forwardEvents*/
        ctx8[26],
        [
          useActions,
          /*use*/
          ctx8[2]
        ]
      ]
    },
    { root: "select" },
    { id: (
      /*uuid*/
      ctx8[25]
    ) },
    { autocomplete: "off" },
    { invalid: Boolean(
      /*error*/
      ctx8[20]
    ) },
    {
      override: {
        .../*base*/
        ctx8[27],
        .../*inputStyle*/
        ctx8[6]
      }
    },
    { noPointerEventsRightSection: true },
    { size: (
      /*size*/
      ctx8[8]
    ) },
    { icon: (
      /*icon*/
      ctx8[9]
    ) },
    { radius: (
      /*radius*/
      ctx8[15]
    ) },
    { variant: (
      /*variant*/
      ctx8[16]
    ) },
    { required: (
      /*required*/
      ctx8[14]
    ) },
    { disabled: (
      /*disabled*/
      ctx8[17]
    ) },
    { iconWidth: (
      /*iconWidth*/
      ctx8[10]
    ) },
    { iconProps: (
      /*iconProps*/
      ctx8[11]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx8[5]
    ) },
    {
      rightSectionWidth: (
        /*rightSectionWidth*/
        ctx8[12]
      )
    },
    {
      rightSectionProps: (
        /*rightSectionProps*/
        ctx8[13]
      )
    },
    /*$$restProps*/
    ctx8[28]
  ];
  function input_element_binding(value) {
    ctx8[32](value);
  }
  function input_value_binding(value) {
    ctx8[33](value);
  }
  let input_props = {
    $$slots: {
      rightSection: [create_rightSection_slot3],
      icon: [create_icon_slot],
      default: [create_default_slot_115]
    },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < input_spread_levels.length; i2 += 1) {
    input_props = assign(input_props, input_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    input_props.element = /*element*/
    ctx8[0];
  }
  if (
    /*value*/
    ctx8[1] !== void 0
  ) {
    input_props.value = /*value*/
    ctx8[1];
  }
  input = new Input_default({ props: input_props, $$inline: true });
  binding_callbacks.push(() => bind(input, "element", input_element_binding));
  binding_callbacks.push(() => bind(input, "value", input_value_binding));
  const block = {
    c: function create() {
      create_component(input.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(input.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(input, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const input_changes = dirty[0] & /*forwardEvents, use, uuid, error, base, inputStyle, size, icon, radius, variant, required, disabled, iconWidth, iconProps, placeholder, rightSectionWidth, rightSectionProps, $$restProps*/
      504627044 ? get_spread_update(input_spread_levels, [
        dirty[0] & /*forwardEvents, use*/
        67108868 && {
          use: [
            /*forwardEvents*/
            ctx9[26],
            [
              useActions,
              /*use*/
              ctx9[2]
            ]
          ]
        },
        input_spread_levels[1],
        dirty[0] & /*uuid*/
        33554432 && { id: (
          /*uuid*/
          ctx9[25]
        ) },
        input_spread_levels[3],
        dirty[0] & /*error*/
        1048576 && { invalid: Boolean(
          /*error*/
          ctx9[20]
        ) },
        dirty[0] & /*base, inputStyle*/
        134217792 && {
          override: {
            .../*base*/
            ctx9[27],
            .../*inputStyle*/
            ctx9[6]
          }
        },
        input_spread_levels[6],
        dirty[0] & /*size*/
        256 && { size: (
          /*size*/
          ctx9[8]
        ) },
        dirty[0] & /*icon*/
        512 && { icon: (
          /*icon*/
          ctx9[9]
        ) },
        dirty[0] & /*radius*/
        32768 && { radius: (
          /*radius*/
          ctx9[15]
        ) },
        dirty[0] & /*variant*/
        65536 && { variant: (
          /*variant*/
          ctx9[16]
        ) },
        dirty[0] & /*required*/
        16384 && { required: (
          /*required*/
          ctx9[14]
        ) },
        dirty[0] & /*disabled*/
        131072 && { disabled: (
          /*disabled*/
          ctx9[17]
        ) },
        dirty[0] & /*iconWidth*/
        1024 && { iconWidth: (
          /*iconWidth*/
          ctx9[10]
        ) },
        dirty[0] & /*iconProps*/
        2048 && { iconProps: (
          /*iconProps*/
          ctx9[11]
        ) },
        dirty[0] & /*placeholder*/
        32 && { placeholder: (
          /*placeholder*/
          ctx9[5]
        ) },
        dirty[0] & /*rightSectionWidth*/
        4096 && {
          rightSectionWidth: (
            /*rightSectionWidth*/
            ctx9[12]
          )
        },
        dirty[0] & /*rightSectionProps*/
        8192 && {
          rightSectionProps: (
            /*rightSectionProps*/
            ctx9[13]
          )
        },
        dirty[0] & /*$$restProps*/
        268435456 && get_spread_object(
          /*$$restProps*/
          ctx9[28]
        )
      ]) : {};
      if (dirty[0] & /*iconProps, formattedData, value, placeholder*/
      16779298 | dirty[1] & /*$$scope*/
      8) {
        input_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty[0] & /*element*/
      1) {
        updating_element = true;
        input_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      if (!updating_value && dirty[0] & /*value*/
      2) {
        updating_value = true;
        input_changes.value = /*value*/
        ctx9[1];
        add_flush_callback(() => updating_value = false);
      }
      input.$set(input_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(input.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(input.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(input, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot60.name,
    type: "slot",
    source: '(38:0) <InputWrapper  id={uuid}  class=\\"{className} svelteui-NativeSelect-root\\"  {size}  {label}  {error}  {override}  {required}  {labelProps}  {errorProps}  {description}  {descriptionProps}  {...wrapperProps} >',
    ctx: ctx8
  });
  return block;
}
function create_fragment81(ctx8) {
  let inputwrapper;
  let current;
  const inputwrapper_spread_levels = [
    { id: (
      /*uuid*/
      ctx8[25]
    ) },
    {
      class: (
        /*className*/
        ctx8[3] + " svelteui-NativeSelect-root"
      )
    },
    { size: (
      /*size*/
      ctx8[8]
    ) },
    { label: (
      /*label*/
      ctx8[18]
    ) },
    { error: (
      /*error*/
      ctx8[20]
    ) },
    { override: (
      /*override*/
      ctx8[4]
    ) },
    { required: (
      /*required*/
      ctx8[14]
    ) },
    { labelProps: (
      /*labelProps*/
      ctx8[21]
    ) },
    { errorProps: (
      /*errorProps*/
      ctx8[23]
    ) },
    { description: (
      /*description*/
      ctx8[19]
    ) },
    {
      descriptionProps: (
        /*descriptionProps*/
        ctx8[22]
      )
    },
    /*wrapperProps*/
    ctx8[7]
  ];
  let inputwrapper_props = {
    $$slots: { default: [create_default_slot60] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < inputwrapper_spread_levels.length; i2 += 1) {
    inputwrapper_props = assign(inputwrapper_props, inputwrapper_spread_levels[i2]);
  }
  inputwrapper = new InputWrapper_default({
    props: inputwrapper_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(inputwrapper.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(inputwrapper.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(inputwrapper, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const inputwrapper_changes = dirty[0] & /*uuid, className, size, label, error, override, required, labelProps, errorProps, description, descriptionProps, wrapperProps*/
      50086296 ? get_spread_update(inputwrapper_spread_levels, [
        dirty[0] & /*uuid*/
        33554432 && { id: (
          /*uuid*/
          ctx9[25]
        ) },
        dirty[0] & /*className*/
        8 && {
          class: (
            /*className*/
            ctx9[3] + " svelteui-NativeSelect-root"
          )
        },
        dirty[0] & /*size*/
        256 && { size: (
          /*size*/
          ctx9[8]
        ) },
        dirty[0] & /*label*/
        262144 && { label: (
          /*label*/
          ctx9[18]
        ) },
        dirty[0] & /*error*/
        1048576 && { error: (
          /*error*/
          ctx9[20]
        ) },
        dirty[0] & /*override*/
        16 && { override: (
          /*override*/
          ctx9[4]
        ) },
        dirty[0] & /*required*/
        16384 && { required: (
          /*required*/
          ctx9[14]
        ) },
        dirty[0] & /*labelProps*/
        2097152 && { labelProps: (
          /*labelProps*/
          ctx9[21]
        ) },
        dirty[0] & /*errorProps*/
        8388608 && { errorProps: (
          /*errorProps*/
          ctx9[23]
        ) },
        dirty[0] & /*description*/
        524288 && { description: (
          /*description*/
          ctx9[19]
        ) },
        dirty[0] & /*descriptionProps*/
        4194304 && {
          descriptionProps: (
            /*descriptionProps*/
            ctx9[22]
          )
        },
        dirty[0] & /*wrapperProps*/
        128 && get_spread_object(
          /*wrapperProps*/
          ctx9[7]
        )
      ]) : {};
      if (dirty[0] & /*use, error, inputStyle, size, icon, radius, variant, required, disabled, iconWidth, iconProps, placeholder, rightSectionWidth, rightSectionProps, $$restProps, element, value, formattedData*/
      286523239 | dirty[1] & /*$$scope*/
      8) {
        inputwrapper_changes.$$scope = { dirty, ctx: ctx9 };
      }
      inputwrapper.$set(inputwrapper_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(inputwrapper.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(inputwrapper.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(inputwrapper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment81.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance81($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "id",
    "placeholder",
    "data",
    "inputStyle",
    "wrapperProps",
    "size",
    "icon",
    "iconWidth",
    "iconProps",
    "rightSectionWidth",
    "rightSectionProps",
    "required",
    "radius",
    "variant",
    "disabled",
    "value",
    "label",
    "description",
    "error",
    "labelProps",
    "descriptionProps",
    "errorProps"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NativeSelect", slots, ["rightSection", "icon"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, id = "NativeSelect", placeholder = "", data = [], inputStyle = {}, wrapperProps = {}, size: size3 = "sm", icon = null, iconWidth = 36, iconProps = { size: 20, color: "currentColor" }, rightSectionWidth = 36, rightSectionProps = {}, required = false, radius: radius2 = "sm", variant: variant2 = "default", disabled = false, value = "", label = "", description = "", error = "", labelProps = {}, descriptionProps = {}, errorProps = {} } = $$props;
  const uuid = randomID(id);
  let formattedData = [];
  const forwardEvents = createEventForwarder(get_current_component());
  const base = { "& .input": { paddingLeft: 12 } };
  function input_element_binding(value2) {
    element2 = value2;
    $$invalidate(0, element2);
  }
  function input_value_binding(value$1) {
    value = value$1;
    $$invalidate(1, value);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(28, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(4, override = $$new_props.override);
    if ("id" in $$new_props)
      $$invalidate(29, id = $$new_props.id);
    if ("placeholder" in $$new_props)
      $$invalidate(5, placeholder = $$new_props.placeholder);
    if ("data" in $$new_props)
      $$invalidate(30, data = $$new_props.data);
    if ("inputStyle" in $$new_props)
      $$invalidate(6, inputStyle = $$new_props.inputStyle);
    if ("wrapperProps" in $$new_props)
      $$invalidate(7, wrapperProps = $$new_props.wrapperProps);
    if ("size" in $$new_props)
      $$invalidate(8, size3 = $$new_props.size);
    if ("icon" in $$new_props)
      $$invalidate(9, icon = $$new_props.icon);
    if ("iconWidth" in $$new_props)
      $$invalidate(10, iconWidth = $$new_props.iconWidth);
    if ("iconProps" in $$new_props)
      $$invalidate(11, iconProps = $$new_props.iconProps);
    if ("rightSectionWidth" in $$new_props)
      $$invalidate(12, rightSectionWidth = $$new_props.rightSectionWidth);
    if ("rightSectionProps" in $$new_props)
      $$invalidate(13, rightSectionProps = $$new_props.rightSectionProps);
    if ("required" in $$new_props)
      $$invalidate(14, required = $$new_props.required);
    if ("radius" in $$new_props)
      $$invalidate(15, radius2 = $$new_props.radius);
    if ("variant" in $$new_props)
      $$invalidate(16, variant2 = $$new_props.variant);
    if ("disabled" in $$new_props)
      $$invalidate(17, disabled = $$new_props.disabled);
    if ("value" in $$new_props)
      $$invalidate(1, value = $$new_props.value);
    if ("label" in $$new_props)
      $$invalidate(18, label = $$new_props.label);
    if ("description" in $$new_props)
      $$invalidate(19, description = $$new_props.description);
    if ("error" in $$new_props)
      $$invalidate(20, error = $$new_props.error);
    if ("labelProps" in $$new_props)
      $$invalidate(21, labelProps = $$new_props.labelProps);
    if ("descriptionProps" in $$new_props)
      $$invalidate(22, descriptionProps = $$new_props.descriptionProps);
    if ("errorProps" in $$new_props)
      $$invalidate(23, errorProps = $$new_props.errorProps);
    if ("$$scope" in $$new_props)
      $$invalidate(34, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    randomID,
    createEventForwarder,
    useActions,
    get_current_component,
    Input: Input_default,
    InputWrapper: InputWrapper_default,
    ChevronUpDown: ChevronUpDown_default,
    use,
    element: element2,
    className,
    override,
    id,
    placeholder,
    data,
    inputStyle,
    wrapperProps,
    size: size3,
    icon,
    iconWidth,
    iconProps,
    rightSectionWidth,
    rightSectionProps,
    required,
    radius: radius2,
    variant: variant2,
    disabled,
    value,
    label,
    description,
    error,
    labelProps,
    descriptionProps,
    errorProps,
    uuid,
    formattedData,
    forwardEvents,
    base
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(4, override = $$new_props.override);
    if ("id" in $$props)
      $$invalidate(29, id = $$new_props.id);
    if ("placeholder" in $$props)
      $$invalidate(5, placeholder = $$new_props.placeholder);
    if ("data" in $$props)
      $$invalidate(30, data = $$new_props.data);
    if ("inputStyle" in $$props)
      $$invalidate(6, inputStyle = $$new_props.inputStyle);
    if ("wrapperProps" in $$props)
      $$invalidate(7, wrapperProps = $$new_props.wrapperProps);
    if ("size" in $$props)
      $$invalidate(8, size3 = $$new_props.size);
    if ("icon" in $$props)
      $$invalidate(9, icon = $$new_props.icon);
    if ("iconWidth" in $$props)
      $$invalidate(10, iconWidth = $$new_props.iconWidth);
    if ("iconProps" in $$props)
      $$invalidate(11, iconProps = $$new_props.iconProps);
    if ("rightSectionWidth" in $$props)
      $$invalidate(12, rightSectionWidth = $$new_props.rightSectionWidth);
    if ("rightSectionProps" in $$props)
      $$invalidate(13, rightSectionProps = $$new_props.rightSectionProps);
    if ("required" in $$props)
      $$invalidate(14, required = $$new_props.required);
    if ("radius" in $$props)
      $$invalidate(15, radius2 = $$new_props.radius);
    if ("variant" in $$props)
      $$invalidate(16, variant2 = $$new_props.variant);
    if ("disabled" in $$props)
      $$invalidate(17, disabled = $$new_props.disabled);
    if ("value" in $$props)
      $$invalidate(1, value = $$new_props.value);
    if ("label" in $$props)
      $$invalidate(18, label = $$new_props.label);
    if ("description" in $$props)
      $$invalidate(19, description = $$new_props.description);
    if ("error" in $$props)
      $$invalidate(20, error = $$new_props.error);
    if ("labelProps" in $$props)
      $$invalidate(21, labelProps = $$new_props.labelProps);
    if ("descriptionProps" in $$props)
      $$invalidate(22, descriptionProps = $$new_props.descriptionProps);
    if ("errorProps" in $$props)
      $$invalidate(23, errorProps = $$new_props.errorProps);
    if ("formattedData" in $$props)
      $$invalidate(24, formattedData = $$new_props.formattedData);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*data*/
    1073741824) {
      $:
        data && $$invalidate(24, formattedData = data.map((item) => typeof item === "string" ? { label: item, value: item } : item));
    }
  };
  return [
    element2,
    value,
    use,
    className,
    override,
    placeholder,
    inputStyle,
    wrapperProps,
    size3,
    icon,
    iconWidth,
    iconProps,
    rightSectionWidth,
    rightSectionProps,
    required,
    radius2,
    variant2,
    disabled,
    label,
    description,
    error,
    labelProps,
    descriptionProps,
    errorProps,
    formattedData,
    uuid,
    forwardEvents,
    base,
    $$restProps,
    id,
    data,
    slots,
    input_element_binding,
    input_value_binding,
    $$scope
  ];
}
var NativeSelect = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance81,
      create_fragment81,
      safe_not_equal,
      {
        use: 2,
        element: 0,
        class: 3,
        override: 4,
        id: 29,
        placeholder: 5,
        data: 30,
        inputStyle: 6,
        wrapperProps: 7,
        size: 8,
        icon: 9,
        iconWidth: 10,
        iconProps: 11,
        rightSectionWidth: 12,
        rightSectionProps: 13,
        required: 14,
        radius: 15,
        variant: 16,
        disabled: 17,
        value: 1,
        label: 18,
        description: 19,
        error: 20,
        labelProps: 21,
        descriptionProps: 22,
        errorProps: 23
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NativeSelect",
      options,
      id: create_fragment81.name
    });
  }
  get use() {
    throw new Error("<NativeSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<NativeSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<NativeSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<NativeSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<NativeSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<NativeSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<NativeSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<NativeSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<NativeSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<NativeSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<NativeSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<NativeSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<NativeSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<NativeSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputStyle() {
    throw new Error("<NativeSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputStyle(value) {
    throw new Error("<NativeSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrapperProps() {
    throw new Error("<NativeSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrapperProps(value) {
    throw new Error("<NativeSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<NativeSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<NativeSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<NativeSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<NativeSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconWidth() {
    throw new Error("<NativeSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconWidth(value) {
    throw new Error("<NativeSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconProps() {
    throw new Error("<NativeSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconProps(value) {
    throw new Error("<NativeSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rightSectionWidth() {
    throw new Error("<NativeSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rightSectionWidth(value) {
    throw new Error("<NativeSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rightSectionProps() {
    throw new Error("<NativeSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rightSectionProps(value) {
    throw new Error("<NativeSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<NativeSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<NativeSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<NativeSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<NativeSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<NativeSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<NativeSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<NativeSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<NativeSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<NativeSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<NativeSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<NativeSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<NativeSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get description() {
    throw new Error("<NativeSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set description(value) {
    throw new Error("<NativeSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<NativeSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value) {
    throw new Error("<NativeSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelProps() {
    throw new Error("<NativeSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelProps(value) {
    throw new Error("<NativeSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get descriptionProps() {
    throw new Error("<NativeSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set descriptionProps(value) {
    throw new Error("<NativeSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get errorProps() {
    throw new Error("<NativeSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set errorProps(value) {
    throw new Error("<NativeSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NativeSelect_default = NativeSelect;

// node_modules/@svelteuidev/core/dist/components/Notification/Notification.styles.js
var Notification_styles_default = createStyles((theme4, { color, radius: radius2 }, getRef) => {
  const _radiusPx = theme4.fn.radius(radius2);
  const _radius = parseInt(_radiusPx.toString().split("px")[0]);
  const topBottom = Math.min(Math.max(_radius / 1.2, 4), 30);
  const colors2 = vFunc(color).filled;
  return {
    root: {
      darkMode: {
        backgroundColor: theme4.fn.themeColor("dark", 6),
        border: `1px solid ${theme4.fn.themeColor("dark", 6)}`
      },
      fontFamily: theme4.fonts.standard.value,
      boxSizing: "border-box",
      position: "relative",
      display: "flex",
      alignItems: "center",
      paddingLeft: 22,
      paddingRight: 5,
      paddingTop: theme4.space.xsPX.value,
      paddingBottom: theme4.space.xsPX.value,
      borderRadius: _radius,
      backgroundColor: theme4.colors.white.value,
      boxShadow: theme4.shadows.lg,
      border: `1px solid ${theme4.fn.themeColor("gray", 2)}`,
      "&::before": {
        content: "''",
        display: "block",
        position: "absolute",
        width: 6,
        top: topBottom,
        bottom: topBottom,
        left: 4,
        borderRadius: _radius,
        backgroundColor: colors2.backgroundColor
      },
      "&.withLoader": {
        paddingLeft: theme4.space.xsPX.value,
        "&::before": {
          display: "none"
        }
      },
      "&.withIcon": {
        paddingLeft: theme4.space.xsPX.value,
        "&::before": {
          display: "none"
        },
        [`& .${getRef("icon")}`]: {
          backgroundColor: colors2.backgroundColor,
          color: theme4.colors.white.value
        }
      }
    },
    icon: {
      ref: getRef("icon"),
      boxSizing: "border-box",
      marginRight: theme4.space.mdPX.value,
      width: 28,
      height: 28,
      borderRadius: 28,
      display: "flex",
      flex: "none",
      alignItems: "center",
      justifyContent: "center",
      color: theme4.colors.white.value
    },
    loader: {
      marginRight: theme4.space.mdPX.value
    },
    content: {
      flex: 1,
      overflow: "hidden",
      marginRight: 10
    },
    title: {
      darkMode: {
        color: theme4.colors.white.value
      },
      lineHeight: 1.4,
      marginBottom: 2,
      overflow: "hidden",
      textOverflow: "ellipsis",
      color: theme4.fn.themeColor("gray", 9)
    },
    description: {
      darkMode: {
        color: theme4.fn.themeColor("dark", 2)
      },
      color: theme4.fn.themeColor("gray", 6),
      lineHeight: 1.4,
      overflow: "hidden",
      textOverflow: "ellipsis",
      "&:only-child": {
        darkMode: {
          color: theme4.fn.themeColor("dark", 0)
        },
        color: theme4.colors.black.value
      }
    },
    closeButton: {
      darkMode: {
        color: theme4.colors.white.value
      },
      color: theme4.colors.black.value
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Notification/Notification.svelte
var file37 = "node_modules/@svelteuidev/core/dist/components/Notification/Notification.svelte";
var get_icon_slot_changes7 = (dirty) => ({});
var get_icon_slot_context7 = (ctx8) => ({});
function create_if_block_34(ctx8) {
  let iconrenderer;
  let current;
  const iconrenderer_spread_levels = [
    { icon: (
      /*icon*/
      ctx8[6]
    ) },
    { className: (
      /*classes*/
      ctx8[12].icon
    ) },
    /*iconProps*/
    ctx8[8]
  ];
  let iconrenderer_props = {};
  for (let i2 = 0; i2 < iconrenderer_spread_levels.length; i2 += 1) {
    iconrenderer_props = assign(iconrenderer_props, iconrenderer_spread_levels[i2]);
  }
  iconrenderer = new IconRenderer_default({
    props: iconrenderer_props,
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(iconrenderer.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconrenderer.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconrenderer, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const iconrenderer_changes = dirty & /*icon, classes, iconProps*/
      4416 ? get_spread_update(iconrenderer_spread_levels, [
        dirty & /*icon*/
        64 && { icon: (
          /*icon*/
          ctx9[6]
        ) },
        dirty & /*classes*/
        4096 && { className: (
          /*classes*/
          ctx9[12].icon
        ) },
        dirty & /*iconProps*/
        256 && get_spread_object(
          /*iconProps*/
          ctx9[8]
        )
      ]) : {};
      iconrenderer.$set(iconrenderer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconrenderer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconrenderer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconrenderer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_34.name,
    type: "if",
    source: "(28:2) {#if icon && !loading}",
    ctx: ctx8
  });
  return block;
}
function fallback_block19(ctx8) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*icon*/
    ctx8[6] && !/*loading*/
    ctx8[5] && create_if_block_34(ctx8)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (
        /*icon*/
        ctx9[6] && !/*loading*/
        ctx9[5]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
          if (dirty & /*icon, loading*/
          96) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_34(ctx9);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block19.name,
    type: "fallback",
    source: "(27:19)    ",
    ctx: ctx8
  });
  return block;
}
function create_if_block_211(ctx8) {
  let loader;
  let current;
  loader = new Loader_default({
    props: {
      class: (
        /*classes*/
        ctx8[12].loader
      ),
      size: 28,
      color: (
        /*color*/
        ctx8[4]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(loader.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(loader.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(loader, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const loader_changes = {};
      if (dirty & /*classes*/
      4096)
        loader_changes.class = /*classes*/
        ctx9[12].loader;
      if (dirty & /*color*/
      16)
        loader_changes.color = /*color*/
        ctx9[4];
      loader.$set(loader_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(loader.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(loader, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_211.name,
    type: "if",
    source: "(32:1) {#if loading}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_118(ctx8) {
  let text_1;
  let current;
  text_1 = new Text_default({
    props: {
      class: (
        /*classes*/
        ctx8[12].title
      ),
      size: "sm",
      weight: 500,
      $$slots: { default: [create_default_slot_28] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(text_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(text_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(text_1, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const text_1_changes = {};
      if (dirty & /*classes*/
      4096)
        text_1_changes.class = /*classes*/
        ctx9[12].title;
      if (dirty & /*$$scope, title*/
      1048584) {
        text_1_changes.$$scope = { dirty, ctx: ctx9 };
      }
      text_1.$set(text_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(text_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_118.name,
    type: "if",
    source: "(36:2) {#if title}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_28(ctx8) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*title*/
        ctx8[3]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*title*/
        ctx8[3]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*title*/
      8)
        set_data_dev(
          t,
          /*title*/
          ctx9[3]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_28.name,
    type: "slot",
    source: '(37:3) <Text class={classes.title} size=\\"sm\\" weight={500}>',
    ctx: ctx8
  });
  return block;
}
function create_default_slot_116(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[20],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[20],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_116.name,
    type: "slot",
    source: '(41:2) <Text class={classes.description} size=\\"sm\\" color=\\"dimmed\\">',
    ctx: ctx8
  });
  return block;
}
function create_if_block31(ctx8) {
  let closebutton;
  let current;
  const closebutton_spread_levels = [
    { class: (
      /*classes*/
      ctx8[12].closeButton
    ) },
    {
      "aria-label": (
        /*closeButtonLabel*/
        ctx8[10]
      )
    },
    { variant: "hover" },
    { size: 28 },
    { iconSize: (
      /*iconSize*/
      ctx8[7]
    ) },
    /*closeButtonProps*/
    ctx8[11]
  ];
  let closebutton_props = {};
  for (let i2 = 0; i2 < closebutton_spread_levels.length; i2 += 1) {
    closebutton_props = assign(closebutton_props, closebutton_spread_levels[i2]);
  }
  closebutton = new CloseButton_default({ props: closebutton_props, $$inline: true });
  closebutton.$on(
    "click",
    /*onClose*/
    ctx8[14]
  );
  const block = {
    c: function create() {
      create_component(closebutton.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(closebutton.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(closebutton, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const closebutton_changes = dirty & /*classes, closeButtonLabel, iconSize, closeButtonProps*/
      7296 ? get_spread_update(closebutton_spread_levels, [
        dirty & /*classes*/
        4096 && { class: (
          /*classes*/
          ctx9[12].closeButton
        ) },
        dirty & /*closeButtonLabel*/
        1024 && {
          "aria-label": (
            /*closeButtonLabel*/
            ctx9[10]
          )
        },
        closebutton_spread_levels[2],
        closebutton_spread_levels[3],
        dirty & /*iconSize*/
        128 && { iconSize: (
          /*iconSize*/
          ctx9[7]
        ) },
        dirty & /*closeButtonProps*/
        2048 && get_spread_object(
          /*closeButtonProps*/
          ctx9[11]
        )
      ]) : {};
      closebutton.$set(closebutton_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(closebutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(closebutton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(closebutton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block31.name,
    type: "if",
    source: "(45:1) {#if withCloseButton}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot61(ctx8) {
  let t0;
  let t1;
  let div;
  let t2;
  let text_1;
  let div_class_value;
  let t3;
  let if_block2_anchor;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx8[18].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[20],
    get_icon_slot_context7
  );
  const icon_slot_or_fallback = icon_slot || fallback_block19(ctx8);
  let if_block0 = (
    /*loading*/
    ctx8[5] && create_if_block_211(ctx8)
  );
  let if_block1 = (
    /*title*/
    ctx8[3] && create_if_block_118(ctx8)
  );
  text_1 = new Text_default({
    props: {
      class: (
        /*classes*/
        ctx8[12].description
      ),
      size: "sm",
      color: "dimmed",
      $$slots: { default: [create_default_slot_116] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  let if_block2 = (
    /*withCloseButton*/
    ctx8[9] && create_if_block31(ctx8)
  );
  const block = {
    c: function create() {
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      div = element("div");
      if (if_block1)
        if_block1.c();
      t2 = space();
      create_component(text_1.$$.fragment);
      t3 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.l(nodes);
      t0 = claim_space(nodes);
      if (if_block0)
        if_block0.l(nodes);
      t1 = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block1)
        if_block1.l(div_nodes);
      t2 = claim_space(div_nodes);
      claim_component(text_1.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      t3 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      if_block2_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*classes*/
      ctx8[12].content);
      add_location(div, file37, 34, 1, 1148);
    },
    m: function mount(target, anchor) {
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(target, anchor);
      }
      insert_hydration_dev(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, div, anchor);
      if (if_block1)
        if_block1.m(div, null);
      append_hydration_dev(div, t2);
      mount_component(text_1, div, null);
      insert_hydration_dev(target, t3, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        1048576)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[20]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx9[20],
              dirty,
              get_icon_slot_changes7
            ),
            get_icon_slot_context7
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty & /*icon, classes, iconProps, loading*/
        4448)) {
          icon_slot_or_fallback.p(ctx9, !current ? -1 : dirty);
        }
      }
      if (
        /*loading*/
        ctx9[5]
      ) {
        if (if_block0) {
          if_block0.p(ctx9, dirty);
          if (dirty & /*loading*/
          32) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_211(ctx9);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*title*/
        ctx9[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx9, dirty);
          if (dirty & /*title*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_118(ctx9);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const text_1_changes = {};
      if (dirty & /*classes*/
      4096)
        text_1_changes.class = /*classes*/
        ctx9[12].description;
      if (dirty & /*$$scope*/
      1048576) {
        text_1_changes.$$scope = { dirty, ctx: ctx9 };
      }
      text_1.$set(text_1_changes);
      if (!current || dirty & /*classes*/
      4096 && div_class_value !== (div_class_value = /*classes*/
      ctx9[12].content)) {
        attr_dev(div, "class", div_class_value);
      }
      if (
        /*withCloseButton*/
        ctx9[9]
      ) {
        if (if_block2) {
          if_block2.p(ctx9, dirty);
          if (dirty & /*withCloseButton*/
          512) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block31(ctx9);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot_or_fallback, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(text_1.$$.fragment, local);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot_or_fallback, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(text_1.$$.fragment, local);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(div);
        detach_dev(t3);
        detach_dev(if_block2_anchor);
      }
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.d(detaching);
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d();
      destroy_component(text_1);
      if (if_block2)
        if_block2.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot61.name,
    type: "slot",
    source: '(17:0) <Box  {use}  bind:element  role=\\"alert\\"  class={cx(className, classes.root, {   withIcon: icon,   withLoader: loading  })}  {...$$restProps} >',
    ctx: ctx8
  });
  return block;
}
function create_fragment82(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { use: (
      /*use*/
      ctx8[1]
    ) },
    { role: "alert" },
    {
      class: (
        /*cx*/
        ctx8[13](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[12].root,
          {
            withIcon: (
              /*icon*/
              ctx8[6]
            ),
            withLoader: (
              /*loading*/
              ctx8[5]
            )
          }
        )
      )
    },
    /*$$restProps*/
    ctx8[15]
  ];
  function box_element_binding(value) {
    ctx8[19](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot61] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*use, cx, className, classes, icon, loading, $$restProps*/
      45158 ? get_spread_update(box_spread_levels, [
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        box_spread_levels[1],
        dirty & /*cx, className, classes, icon, loading*/
        12388 && {
          class: (
            /*cx*/
            ctx9[13](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[12].root,
              {
                withIcon: (
                  /*icon*/
                  ctx9[6]
                ),
                withLoader: (
                  /*loading*/
                  ctx9[5]
                )
              }
            )
          )
        },
        dirty & /*$$restProps*/
        32768 && get_spread_object(
          /*$$restProps*/
          ctx9[15]
        )
      ]) : {};
      if (dirty & /*$$scope, classes, closeButtonLabel, iconSize, closeButtonProps, withCloseButton, title, color, loading, icon, iconProps*/
      1056760) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment82.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance82($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "title",
    "color",
    "radius",
    "loading",
    "icon",
    "iconSize",
    "iconProps",
    "withCloseButton",
    "closeButtonLabel",
    "closeButtonProps"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Notification", slots, ["icon", "default"]);
  let { use = [], element: element2 = void 0, class: className = "blue", override = {}, title = void 0, color = "blue", radius: radius2 = "sm", loading = false, icon = void 0, iconSize = 16, iconProps = {}, withCloseButton = true, closeButtonLabel = void 0, closeButtonProps = {} } = $$props;
  const dispatch = createEventDispatcher();
  function onClose() {
    dispatch("close");
  }
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(16, override = $$new_props.override);
    if ("title" in $$new_props)
      $$invalidate(3, title = $$new_props.title);
    if ("color" in $$new_props)
      $$invalidate(4, color = $$new_props.color);
    if ("radius" in $$new_props)
      $$invalidate(17, radius2 = $$new_props.radius);
    if ("loading" in $$new_props)
      $$invalidate(5, loading = $$new_props.loading);
    if ("icon" in $$new_props)
      $$invalidate(6, icon = $$new_props.icon);
    if ("iconSize" in $$new_props)
      $$invalidate(7, iconSize = $$new_props.iconSize);
    if ("iconProps" in $$new_props)
      $$invalidate(8, iconProps = $$new_props.iconProps);
    if ("withCloseButton" in $$new_props)
      $$invalidate(9, withCloseButton = $$new_props.withCloseButton);
    if ("closeButtonLabel" in $$new_props)
      $$invalidate(10, closeButtonLabel = $$new_props.closeButtonLabel);
    if ("closeButtonProps" in $$new_props)
      $$invalidate(11, closeButtonProps = $$new_props.closeButtonProps);
    if ("$$scope" in $$new_props)
      $$invalidate(20, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    CloseButton: CloseButton_default,
    Box: Box_default,
    IconRenderer: IconRenderer_default,
    Loader: Loader_default,
    Text: Text_default,
    useStyles: Notification_styles_default,
    use,
    element: element2,
    className,
    override,
    title,
    color,
    radius: radius2,
    loading,
    icon,
    iconSize,
    iconProps,
    withCloseButton,
    closeButtonLabel,
    closeButtonProps,
    dispatch,
    onClose,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(16, override = $$new_props.override);
    if ("title" in $$props)
      $$invalidate(3, title = $$new_props.title);
    if ("color" in $$props)
      $$invalidate(4, color = $$new_props.color);
    if ("radius" in $$props)
      $$invalidate(17, radius2 = $$new_props.radius);
    if ("loading" in $$props)
      $$invalidate(5, loading = $$new_props.loading);
    if ("icon" in $$props)
      $$invalidate(6, icon = $$new_props.icon);
    if ("iconSize" in $$props)
      $$invalidate(7, iconSize = $$new_props.iconSize);
    if ("iconProps" in $$props)
      $$invalidate(8, iconProps = $$new_props.iconProps);
    if ("withCloseButton" in $$props)
      $$invalidate(9, withCloseButton = $$new_props.withCloseButton);
    if ("closeButtonLabel" in $$props)
      $$invalidate(10, closeButtonLabel = $$new_props.closeButtonLabel);
    if ("closeButtonProps" in $$props)
      $$invalidate(11, closeButtonProps = $$new_props.closeButtonProps);
    if ("classes" in $$props)
      $$invalidate(12, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(13, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*color, radius, override*/
    196624) {
      $:
        $$invalidate(13, { cx: cx2, classes } = Notification_styles_default({ color, radius: radius2 }, { override, name: "Notification" }), cx2, ($$invalidate(12, classes), $$invalidate(4, color), $$invalidate(17, radius2), $$invalidate(16, override)));
    }
  };
  return [
    element2,
    use,
    className,
    title,
    color,
    loading,
    icon,
    iconSize,
    iconProps,
    withCloseButton,
    closeButtonLabel,
    closeButtonProps,
    classes,
    cx2,
    onClose,
    $$restProps,
    override,
    radius2,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Notification = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance82, create_fragment82, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 16,
      title: 3,
      color: 4,
      radius: 17,
      loading: 5,
      icon: 6,
      iconSize: 7,
      iconProps: 8,
      withCloseButton: 9,
      closeButtonLabel: 10,
      closeButtonProps: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Notification",
      options,
      id: create_fragment82.name
    });
  }
  get use() {
    throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loading() {
    throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loading(value) {
    throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconSize() {
    throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconSize(value) {
    throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconProps() {
    throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconProps(value) {
    throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withCloseButton() {
    throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withCloseButton(value) {
    throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeButtonLabel() {
    throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeButtonLabel(value) {
    throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeButtonProps() {
    throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeButtonProps(value) {
    throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Notification_default = Notification;

// node_modules/@svelteuidev/core/dist/components/TextInput/TextInput.svelte
var get_rightSection_slot_changes7 = (dirty) => ({});
var get_rightSection_slot_context7 = (ctx8) => ({ slot: "rightSection" });
var get_icon_slot_changes8 = (dirty) => ({});
var get_icon_slot_context8 = (ctx8) => ({ slot: "icon" });
function create_rightSection_slot4(ctx8) {
  let current;
  const rightSection_slot_template = (
    /*#slots*/
    ctx8[22].rightSection
  );
  const rightSection_slot = create_slot(
    rightSection_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[25],
    get_rightSection_slot_context7
  );
  const block = {
    c: function create() {
      if (rightSection_slot)
        rightSection_slot.c();
    },
    l: function claim(nodes) {
      if (rightSection_slot)
        rightSection_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (rightSection_slot) {
        rightSection_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (rightSection_slot) {
        if (rightSection_slot.p && (!current || dirty & /*$$scope*/
        33554432)) {
          update_slot_base(
            rightSection_slot,
            rightSection_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[25]
            ) : get_slot_changes(
              rightSection_slot_template,
              /*$$scope*/
              ctx9[25],
              dirty,
              get_rightSection_slot_changes7
            ),
            get_rightSection_slot_context7
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rightSection_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rightSection_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (rightSection_slot)
        rightSection_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_rightSection_slot4.name,
    type: "slot",
    source: "(65:2) ",
    ctx: ctx8
  });
  return block;
}
function create_icon_slot2(ctx8) {
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx8[22].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[25],
    get_icon_slot_context8
  );
  const block = {
    c: function create() {
      if (icon_slot)
        icon_slot.c();
    },
    l: function claim(nodes) {
      if (icon_slot)
        icon_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        33554432)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[25]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx9[25],
              dirty,
              get_icon_slot_changes8
            ),
            get_icon_slot_context8
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_icon_slot2.name,
    type: "slot",
    source: "(66:2) ",
    ctx: ctx8
  });
  return block;
}
function create_default_slot62(ctx8) {
  let input;
  let updating_value;
  let current;
  const input_spread_levels = [
    { required: (
      /*required*/
      ctx8[8]
    ) },
    { size: (
      /*size*/
      ctx8[14]
    ) },
    { id: (
      /*id*/
      ctx8[12]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx8[15]
    ) },
    /*$$restProps*/
    ctx8[19],
    {
      use: [
        /*forwardEvents*/
        ctx8[17],
        [
          useActions,
          /*use*/
          ctx8[2]
        ]
      ]
    },
    { invalid: (
      /*_invalid*/
      ctx8[16]
    ) },
    {
      showRightSection: (
        /*_showRightSection*/
        ctx8[18]
      )
    }
  ];
  function input_value_binding(value) {
    ctx8[23](value);
  }
  let input_props = {
    $$slots: {
      icon: [create_icon_slot2],
      rightSection: [create_rightSection_slot4]
    },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < input_spread_levels.length; i2 += 1) {
    input_props = assign(input_props, input_spread_levels[i2]);
  }
  if (
    /*value*/
    ctx8[1] !== void 0
  ) {
    input_props.value = /*value*/
    ctx8[1];
  }
  input = new Input_default({ props: input_props, $$inline: true });
  binding_callbacks.push(() => bind(input, "value", input_value_binding));
  const block = {
    c: function create() {
      create_component(input.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(input.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(input, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const input_changes = dirty & /*required, size, id, placeholder, $$restProps, forwardEvents, use, _invalid, _showRightSection*/
      1036548 ? get_spread_update(input_spread_levels, [
        dirty & /*required*/
        256 && { required: (
          /*required*/
          ctx9[8]
        ) },
        dirty & /*size*/
        16384 && { size: (
          /*size*/
          ctx9[14]
        ) },
        dirty & /*id*/
        4096 && { id: (
          /*id*/
          ctx9[12]
        ) },
        dirty & /*placeholder*/
        32768 && { placeholder: (
          /*placeholder*/
          ctx9[15]
        ) },
        dirty & /*$$restProps*/
        524288 && get_spread_object(
          /*$$restProps*/
          ctx9[19]
        ),
        dirty & /*forwardEvents, use*/
        131076 && {
          use: [
            /*forwardEvents*/
            ctx9[17],
            [
              useActions,
              /*use*/
              ctx9[2]
            ]
          ]
        },
        dirty & /*_invalid*/
        65536 && { invalid: (
          /*_invalid*/
          ctx9[16]
        ) },
        dirty & /*_showRightSection*/
        262144 && {
          showRightSection: (
            /*_showRightSection*/
            ctx9[18]
          )
        }
      ]) : {};
      if (dirty & /*$$scope*/
      33554432) {
        input_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_value && dirty & /*value*/
      2) {
        updating_value = true;
        input_changes.value = /*value*/
        ctx9[1];
        add_flush_callback(() => updating_value = false);
      }
      input.$set(input_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(input.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(input.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(input, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot62.name,
    type: "slot",
    source: "(39:0) <InputWrapper  bind:element  class={className}  {override}  {label}  {description}  {error}  {required}  {labelProps}  {descriptionProps}  {errorProps}  {id}  {labelElement}  {size} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment83(ctx8) {
  let inputwrapper;
  let updating_element;
  let current;
  function inputwrapper_element_binding(value) {
    ctx8[24](value);
  }
  let inputwrapper_props = {
    class: (
      /*className*/
      ctx8[3]
    ),
    override: (
      /*override*/
      ctx8[4]
    ),
    label: (
      /*label*/
      ctx8[5]
    ),
    description: (
      /*description*/
      ctx8[6]
    ),
    error: (
      /*error*/
      ctx8[7]
    ),
    required: (
      /*required*/
      ctx8[8]
    ),
    labelProps: (
      /*labelProps*/
      ctx8[9]
    ),
    descriptionProps: (
      /*descriptionProps*/
      ctx8[10]
    ),
    errorProps: (
      /*errorProps*/
      ctx8[11]
    ),
    id: (
      /*id*/
      ctx8[12]
    ),
    labelElement: (
      /*labelElement*/
      ctx8[13]
    ),
    size: (
      /*size*/
      ctx8[14]
    ),
    $$slots: { default: [create_default_slot62] },
    $$scope: { ctx: ctx8 }
  };
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    inputwrapper_props.element = /*element*/
    ctx8[0];
  }
  inputwrapper = new InputWrapper_default({
    props: inputwrapper_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(inputwrapper, "element", inputwrapper_element_binding));
  const block = {
    c: function create() {
      create_component(inputwrapper.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(inputwrapper.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(inputwrapper, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const inputwrapper_changes = {};
      if (dirty & /*className*/
      8)
        inputwrapper_changes.class = /*className*/
        ctx9[3];
      if (dirty & /*override*/
      16)
        inputwrapper_changes.override = /*override*/
        ctx9[4];
      if (dirty & /*label*/
      32)
        inputwrapper_changes.label = /*label*/
        ctx9[5];
      if (dirty & /*description*/
      64)
        inputwrapper_changes.description = /*description*/
        ctx9[6];
      if (dirty & /*error*/
      128)
        inputwrapper_changes.error = /*error*/
        ctx9[7];
      if (dirty & /*required*/
      256)
        inputwrapper_changes.required = /*required*/
        ctx9[8];
      if (dirty & /*labelProps*/
      512)
        inputwrapper_changes.labelProps = /*labelProps*/
        ctx9[9];
      if (dirty & /*descriptionProps*/
      1024)
        inputwrapper_changes.descriptionProps = /*descriptionProps*/
        ctx9[10];
      if (dirty & /*errorProps*/
      2048)
        inputwrapper_changes.errorProps = /*errorProps*/
        ctx9[11];
      if (dirty & /*id*/
      4096)
        inputwrapper_changes.id = /*id*/
        ctx9[12];
      if (dirty & /*labelElement*/
      8192)
        inputwrapper_changes.labelElement = /*labelElement*/
        ctx9[13];
      if (dirty & /*size*/
      16384)
        inputwrapper_changes.size = /*size*/
        ctx9[14];
      if (dirty & /*$$scope, required, size, id, placeholder, $$restProps, use, _invalid, value*/
      34197766) {
        inputwrapper_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        inputwrapper_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      inputwrapper.$set(inputwrapper_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(inputwrapper.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(inputwrapper.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(inputwrapper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment83.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance83($$self, $$props, $$invalidate) {
  let _invalid;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "label",
    "description",
    "error",
    "required",
    "labelProps",
    "descriptionProps",
    "errorProps",
    "invalid",
    "id",
    "labelElement",
    "size",
    "showRightSection",
    "value",
    "placeholder"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TextInput", slots, ["icon", "rightSection"]);
  const $$slots = compute_slots(slots);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, label = "", description = null, error = null, required = false, labelProps = {}, descriptionProps = {}, errorProps = {}, invalid = false, id = randomID("text-input"), labelElement = "label", size: size3 = "sm", showRightSection = void 0, value = "", placeholder = "" } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  const _showRightSection = showRightSection === void 0 ? !!$$slots.rightSection : showRightSection;
  function input_value_binding(value$1) {
    value = value$1;
    $$invalidate(1, value);
  }
  function inputwrapper_element_binding(value2) {
    element2 = value2;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(19, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(4, override = $$new_props.override);
    if ("label" in $$new_props)
      $$invalidate(5, label = $$new_props.label);
    if ("description" in $$new_props)
      $$invalidate(6, description = $$new_props.description);
    if ("error" in $$new_props)
      $$invalidate(7, error = $$new_props.error);
    if ("required" in $$new_props)
      $$invalidate(8, required = $$new_props.required);
    if ("labelProps" in $$new_props)
      $$invalidate(9, labelProps = $$new_props.labelProps);
    if ("descriptionProps" in $$new_props)
      $$invalidate(10, descriptionProps = $$new_props.descriptionProps);
    if ("errorProps" in $$new_props)
      $$invalidate(11, errorProps = $$new_props.errorProps);
    if ("invalid" in $$new_props)
      $$invalidate(20, invalid = $$new_props.invalid);
    if ("id" in $$new_props)
      $$invalidate(12, id = $$new_props.id);
    if ("labelElement" in $$new_props)
      $$invalidate(13, labelElement = $$new_props.labelElement);
    if ("size" in $$new_props)
      $$invalidate(14, size3 = $$new_props.size);
    if ("showRightSection" in $$new_props)
      $$invalidate(21, showRightSection = $$new_props.showRightSection);
    if ("value" in $$new_props)
      $$invalidate(1, value = $$new_props.value);
    if ("placeholder" in $$new_props)
      $$invalidate(15, placeholder = $$new_props.placeholder);
    if ("$$scope" in $$new_props)
      $$invalidate(25, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    get_current_component,
    createEventForwarder,
    useActions,
    randomID,
    Input: Input_default,
    InputWrapper: InputWrapper_default,
    use,
    element: element2,
    className,
    override,
    label,
    description,
    error,
    required,
    labelProps,
    descriptionProps,
    errorProps,
    invalid,
    id,
    labelElement,
    size: size3,
    showRightSection,
    value,
    placeholder,
    forwardEvents,
    _showRightSection,
    _invalid
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(4, override = $$new_props.override);
    if ("label" in $$props)
      $$invalidate(5, label = $$new_props.label);
    if ("description" in $$props)
      $$invalidate(6, description = $$new_props.description);
    if ("error" in $$props)
      $$invalidate(7, error = $$new_props.error);
    if ("required" in $$props)
      $$invalidate(8, required = $$new_props.required);
    if ("labelProps" in $$props)
      $$invalidate(9, labelProps = $$new_props.labelProps);
    if ("descriptionProps" in $$props)
      $$invalidate(10, descriptionProps = $$new_props.descriptionProps);
    if ("errorProps" in $$props)
      $$invalidate(11, errorProps = $$new_props.errorProps);
    if ("invalid" in $$props)
      $$invalidate(20, invalid = $$new_props.invalid);
    if ("id" in $$props)
      $$invalidate(12, id = $$new_props.id);
    if ("labelElement" in $$props)
      $$invalidate(13, labelElement = $$new_props.labelElement);
    if ("size" in $$props)
      $$invalidate(14, size3 = $$new_props.size);
    if ("showRightSection" in $$props)
      $$invalidate(21, showRightSection = $$new_props.showRightSection);
    if ("value" in $$props)
      $$invalidate(1, value = $$new_props.value);
    if ("placeholder" in $$props)
      $$invalidate(15, placeholder = $$new_props.placeholder);
    if ("_invalid" in $$props)
      $$invalidate(16, _invalid = $$new_props._invalid);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*invalid, error*/
    1048704) {
      $:
        $$invalidate(16, _invalid = invalid || !!error);
    }
  };
  return [
    element2,
    value,
    use,
    className,
    override,
    label,
    description,
    error,
    required,
    labelProps,
    descriptionProps,
    errorProps,
    id,
    labelElement,
    size3,
    placeholder,
    _invalid,
    forwardEvents,
    _showRightSection,
    $$restProps,
    invalid,
    showRightSection,
    slots,
    input_value_binding,
    inputwrapper_element_binding,
    $$scope
  ];
}
var TextInput = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance83, create_fragment83, safe_not_equal, {
      use: 2,
      element: 0,
      class: 3,
      override: 4,
      label: 5,
      description: 6,
      error: 7,
      required: 8,
      labelProps: 9,
      descriptionProps: 10,
      errorProps: 11,
      invalid: 20,
      id: 12,
      labelElement: 13,
      size: 14,
      showRightSection: 21,
      value: 1,
      placeholder: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TextInput",
      options,
      id: create_fragment83.name
    });
  }
  get use() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get description() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set description(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelProps() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelProps(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get descriptionProps() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set descriptionProps(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get errorProps() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set errorProps(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelElement() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelElement(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showRightSection() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showRightSection(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<TextInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<TextInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TextInput_default = TextInput;

// node_modules/@svelteuidev/core/dist/components/NumberInput/NumberInput.styles.js
var CONTROL_SIZES = {
  xs: 20,
  sm: 24,
  md: 30,
  lg: 34,
  xl: 36
};
var NumberInput_styles_default = createStyles((theme4, { size: size3, radius: radius2 }) => {
  return {
    root: {
      display: "flex",
      flexDirection: "column",
      height: "calc(100% - 2px)",
      margin: 1,
      marginRight: 1
    },
    controls: {
      width: "calc(100% - 22px)"
    },
    control: {
      margin: 0,
      position: "relative",
      flex: "0 0 50%",
      boxSizing: "border-box",
      width: CONTROL_SIZES[size3],
      padding: 0,
      WebkitTapHighlightColor: "transparent",
      borderBottom: "1px solid $gray400",
      borderLeft: "1px solid $gray400",
      borderTop: 0,
      borderRight: 0,
      backgroundColor: "transparent",
      marginRight: 1,
      darkMode: {
        borderBottom: "1px solid $dark400",
        borderLeft: "1px solid $dark400"
      },
      "&:not(:disabled):hover": {
        backgroundColor: "$gray50",
        darkMode: {
          backgroundColor: "$dark600"
        }
      },
      "&::after": {
        position: "absolute",
        top: "calc(50% - 2.5px)",
        left: "calc(50% - 4.5px)",
        content: '""',
        display: "block",
        width: 0,
        height: 0,
        borderStyle: "solid"
      }
    },
    controlUp: {
      borderTopRightRadius: `$${radius2}`,
      "&::after": {
        borderWidth: "0px 5px 5px 5px",
        borderColor: "transparent transparent $black transparent",
        darkMode: {
          borderColor: "transparent transparent $dark50 transparent"
        }
      },
      "&:disabled::after": {
        borderBottomColor: "$gray500",
        darkMode: {
          borderBottomColor: "$dark200"
        }
      }
    },
    controlDown: {
      borderTopRightRadius: `$${radius2}`,
      borderBottom: 0,
      "&::after": {
        borderWidth: "5px 5px 0px 5px",
        borderColor: "$black transparent transparent transparent",
        darkMode: {
          borderColor: "$dark50 transparent transparent transparent"
        }
      },
      "&:disabled::after": {
        borderTopColor: "$gray500",
        darkMode: {
          borderTopColor: "$dark200"
        }
      }
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/NumberInput/utils.js
var defaultFormatter = (value) => value || "";
var defaultParser = (num) => {
  if (num === "-")
    return num;
  const parsedNum = parseFloat(num);
  return Number.isNaN(parsedNum) ? void 0 : num;
};

// node_modules/@svelteuidev/core/dist/components/NumberInput/NumberInput.svelte
var file38 = "node_modules/@svelteuidev/core/dist/components/NumberInput/NumberInput.svelte";
var get_icon_slot_changes9 = (dirty) => ({});
var get_icon_slot_context9 = (ctx8) => ({ slot: "icon" });
function create_icon_slot3(ctx8) {
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx8[44].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[48],
    get_icon_slot_context9
  );
  const block = {
    c: function create() {
      if (icon_slot)
        icon_slot.c();
    },
    l: function claim(nodes) {
      if (icon_slot)
        icon_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty[1] & /*$$scope*/
        131072)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[48],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[48]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx9[48],
              dirty,
              get_icon_slot_changes9
            ),
            get_icon_slot_context9
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_icon_slot3.name,
    type: "slot",
    source: "(164:1) ",
    ctx: ctx8
  });
  return block;
}
function create_if_block32(ctx8) {
  let button0;
  let button0_class_value;
  let button0_tabindex_value;
  let button0_disabled_value;
  let t;
  let button1;
  let button1_class_value;
  let button1_tabindex_value;
  let button1_disabled_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button0 = element("button");
      t = space();
      button1 = element("button");
      this.h();
    },
    l: function claim(nodes) {
      button0 = claim_element(nodes, "BUTTON", {
        class: true,
        type: true,
        tabindex: true,
        "aria-hidden": true
      });
      children(button0).forEach(detach_dev);
      t = claim_space(nodes);
      button1 = claim_element(nodes, "BUTTON", {
        class: true,
        type: true,
        tabindex: true,
        "aria-hidden": true
      });
      children(button1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button0, "class", button0_class_value = /*cx*/
      ctx8[21](
        /*classes*/
        ctx8[20].control,
        /*classes*/
        ctx8[20].controlUp
      ));
      attr_dev(button0, "type", "button");
      attr_dev(button0, "tabindex", button0_tabindex_value = -1);
      attr_dev(button0, "aria-hidden", "");
      button0.disabled = button0_disabled_value = /*value*/
      ctx8[0] >= /*max*/
      ctx8[18];
      add_location(button0, file38, 169, 3, 5647);
      attr_dev(button1, "class", button1_class_value = /*cx*/
      ctx8[21](
        /*classes*/
        ctx8[20].control,
        /*classes*/
        ctx8[20].controlDown
      ));
      attr_dev(button1, "type", "button");
      attr_dev(button1, "tabindex", button1_tabindex_value = -1);
      attr_dev(button1, "aria-hidden", "");
      button1.disabled = button1_disabled_value = /*value*/
      ctx8[0] <= /*min*/
      ctx8[17];
      add_location(button1, file38, 179, 3, 5892);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button0, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, button1, anchor);
      if (!mounted) {
        dispose = [
          listen_dev(
            button0,
            "mousedown",
            /*mousedown_handler*/
            ctx8[45],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button0,
            "mouseup",
            /*onStepDone*/
            ctx8[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button0,
            "mouseleave",
            /*onStepDone*/
            ctx8[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "mousedown",
            /*mousedown_handler_1*/
            ctx8[46],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "mouseup",
            /*onStepDone*/
            ctx8[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "mouseleave",
            /*onStepDone*/
            ctx8[27],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*cx, classes*/
      3145728 && button0_class_value !== (button0_class_value = /*cx*/
      ctx9[21](
        /*classes*/
        ctx9[20].control,
        /*classes*/
        ctx9[20].controlUp
      ))) {
        attr_dev(button0, "class", button0_class_value);
      }
      if (dirty[0] & /*value, max*/
      262145 && button0_disabled_value !== (button0_disabled_value = /*value*/
      ctx9[0] >= /*max*/
      ctx9[18])) {
        prop_dev(button0, "disabled", button0_disabled_value);
      }
      if (dirty[0] & /*cx, classes*/
      3145728 && button1_class_value !== (button1_class_value = /*cx*/
      ctx9[21](
        /*classes*/
        ctx9[20].control,
        /*classes*/
        ctx9[20].controlDown
      ))) {
        attr_dev(button1, "class", button1_class_value);
      }
      if (dirty[0] & /*value, min*/
      131073 && button1_disabled_value !== (button1_disabled_value = /*value*/
      ctx9[0] <= /*min*/
      ctx9[17])) {
        prop_dev(button1, "disabled", button1_disabled_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button0);
        detach_dev(t);
        detach_dev(button1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block32.name,
    type: "if",
    source: "(169:2) {#if showControls}",
    ctx: ctx8
  });
  return block;
}
function create_rightSection_slot5(ctx8) {
  let div;
  let div_class_value;
  let if_block = (
    /*showControls*/
    ctx8[22] && create_if_block32(ctx8)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { slot: true, class: true });
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "slot", "rightSection");
      attr_dev(div, "class", div_class_value = /*cx*/
      ctx8[21](
        /*className*/
        ctx8[3],
        /*classes*/
        ctx8[20].controls,
        /*getStyles*/
        ctx8[19]({ css: (
          /*overrideControls*/
          ctx8[5]
        ) })
      ));
      add_location(div, file38, 164, 1, 5513);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
    },
    p: function update(ctx9, dirty) {
      if (
        /*showControls*/
        ctx9[22]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
        } else {
          if_block = create_if_block32(ctx9);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & /*cx, className, classes, getStyles, overrideControls*/
      3670056 && div_class_value !== (div_class_value = /*cx*/
      ctx9[21](
        /*className*/
        ctx9[3],
        /*classes*/
        ctx9[20].controls,
        /*getStyles*/
        ctx9[19]({ css: (
          /*overrideControls*/
          ctx9[5]
        ) })
      ))) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_rightSection_slot5.name,
    type: "slot",
    source: "(165:1) ",
    ctx: ctx8
  });
  return block;
}
function create_fragment84(ctx8) {
  let textinput;
  let updating_element;
  let current;
  const textinput_spread_levels = [
    { root: (
      /*root*/
      ctx8[6]
    ) },
    { icon: (
      /*icon*/
      ctx8[8]
    ) },
    { iconWidth: (
      /*iconWidth*/
      ctx8[9]
    ) },
    { iconProps: (
      /*iconProps*/
      ctx8[10]
    ) },
    { wrapperProps: (
      /*wrapperProps*/
      ctx8[11]
    ) },
    { required: (
      /*required*/
      ctx8[12]
    ) },
    { size: (
      /*size*/
      ctx8[16]
    ) },
    { radius: (
      /*radius*/
      ctx8[13]
    ) },
    { variant: (
      /*variant*/
      ctx8[14]
    ) },
    { disabled: (
      /*disabled*/
      ctx8[15]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx8[7]
    ) },
    {
      class: (
        /*cx*/
        ctx8[21](
          /*className*/
          ctx8[3],
          /*classes*/
          ctx8[20].root
        )
      )
    },
    {
      override: {
        "& .rightSection": { width: "auto" },
        .../*override*/
        ctx8[4]
      }
    },
    {
      value: (
        /*formatNumber*/
        ctx8[24](
          /*value*/
          ctx8[0]
        )
      )
    },
    {
      showRightSection: (
        /*showControls*/
        ctx8[22]
      )
    },
    /*$$restProps*/
    ctx8[31],
    {
      use: [
        /*forwardEvents*/
        ctx8[23],
        [
          useActions,
          /*use*/
          ctx8[2]
        ]
      ]
    }
  ];
  function textinput_element_binding(value) {
    ctx8[47](value);
  }
  let textinput_props = {
    $$slots: {
      rightSection: [create_rightSection_slot5],
      icon: [create_icon_slot3]
    },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < textinput_spread_levels.length; i2 += 1) {
    textinput_props = assign(textinput_props, textinput_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[1] !== void 0
  ) {
    textinput_props.element = /*element*/
    ctx8[1];
  }
  textinput = new TextInput_default({ props: textinput_props, $$inline: true });
  binding_callbacks.push(() => bind(textinput, "element", textinput_element_binding));
  textinput.$on(
    "input",
    /*onInput*/
    ctx8[25]
  );
  textinput.$on(
    "keyup",
    /*onKeyUp*/
    ctx8[29]
  );
  textinput.$on(
    "keydown",
    /*onKeyDown*/
    ctx8[28]
  );
  textinput.$on(
    "blur",
    /*onBlur*/
    ctx8[30]
  );
  const block = {
    c: function create() {
      create_component(textinput.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(textinput.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(textinput, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const textinput_changes = dirty[0] & /*root, icon, iconWidth, iconProps, wrapperProps, required, size, radius, variant, disabled, placeholder, cx, className, classes, override, formatNumber, value, showControls, forwardEvents, use*/
      32636893 | dirty[1] & /*$$restProps*/
      1 ? get_spread_update(textinput_spread_levels, [
        dirty[0] & /*root*/
        64 && { root: (
          /*root*/
          ctx9[6]
        ) },
        dirty[0] & /*icon*/
        256 && { icon: (
          /*icon*/
          ctx9[8]
        ) },
        dirty[0] & /*iconWidth*/
        512 && { iconWidth: (
          /*iconWidth*/
          ctx9[9]
        ) },
        dirty[0] & /*iconProps*/
        1024 && { iconProps: (
          /*iconProps*/
          ctx9[10]
        ) },
        dirty[0] & /*wrapperProps*/
        2048 && { wrapperProps: (
          /*wrapperProps*/
          ctx9[11]
        ) },
        dirty[0] & /*required*/
        4096 && { required: (
          /*required*/
          ctx9[12]
        ) },
        dirty[0] & /*size*/
        65536 && { size: (
          /*size*/
          ctx9[16]
        ) },
        dirty[0] & /*radius*/
        8192 && { radius: (
          /*radius*/
          ctx9[13]
        ) },
        dirty[0] & /*variant*/
        16384 && { variant: (
          /*variant*/
          ctx9[14]
        ) },
        dirty[0] & /*disabled*/
        32768 && { disabled: (
          /*disabled*/
          ctx9[15]
        ) },
        dirty[0] & /*placeholder*/
        128 && { placeholder: (
          /*placeholder*/
          ctx9[7]
        ) },
        dirty[0] & /*cx, className, classes*/
        3145736 && {
          class: (
            /*cx*/
            ctx9[21](
              /*className*/
              ctx9[3],
              /*classes*/
              ctx9[20].root
            )
          )
        },
        dirty[0] & /*override*/
        16 && {
          override: {
            "& .rightSection": { width: "auto" },
            .../*override*/
            ctx9[4]
          }
        },
        dirty[0] & /*formatNumber, value*/
        16777217 && {
          value: (
            /*formatNumber*/
            ctx9[24](
              /*value*/
              ctx9[0]
            )
          )
        },
        dirty[0] & /*showControls*/
        4194304 && {
          showRightSection: (
            /*showControls*/
            ctx9[22]
          )
        },
        dirty[1] & /*$$restProps*/
        1 && get_spread_object(
          /*$$restProps*/
          ctx9[31]
        ),
        dirty[0] & /*forwardEvents, use*/
        8388612 && {
          use: [
            /*forwardEvents*/
            ctx9[23],
            [
              useActions,
              /*use*/
              ctx9[2]
            ]
          ]
        }
      ]) : {};
      if (dirty[0] & /*cx, className, classes, getStyles, overrideControls, value, min, max, showControls*/
      8257577 | dirty[1] & /*$$scope*/
      131072) {
        textinput_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty[0] & /*element*/
      2) {
        updating_element = true;
        textinput_changes.element = /*element*/
        ctx9[1];
        add_flush_callback(() => updating_element = false);
      }
      textinput.$set(textinput_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(textinput.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(textinput.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(textinput, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment84.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance84($$self, $$props, $$invalidate) {
  let showControls;
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "overrideControls",
    "root",
    "placeholder",
    "icon",
    "iconWidth",
    "iconProps",
    "wrapperProps",
    "required",
    "radius",
    "variant",
    "disabled",
    "size",
    "value",
    "defaultValue",
    "decimalSeparator",
    "min",
    "max",
    "step",
    "stepHoldDelay",
    "stepHoldInterval",
    "hideControls",
    "precision",
    "noClampOnBlur",
    "formatter",
    "parser",
    "increment",
    "decrement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NumberInput", slots, ["icon"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, overrideControls = {}, root = "input", placeholder = void 0, icon = null, iconWidth = 36, iconProps = { size: 20, color: "currentColor" }, wrapperProps = {}, required = false, radius: radius2 = "sm", variant: variant2 = "default", disabled = false, size: size3 = "sm", value = void 0, defaultValue = void 0, decimalSeparator = ".", min = -Infinity, max = Infinity, step = 1, stepHoldDelay = 250, stepHoldInterval = 150, hideControls = false, precision = 0, noClampOnBlur = false, formatter = defaultFormatter, parser = defaultParser } = $$props;
  function increment() {
    onStep(true, false);
  }
  function decrement() {
    onStep(false, false);
  }
  const dispatch = createEventDispatcher();
  const forwardEvents = createEventForwarder(get_current_component(), ["change"]);
  let isKeyDown = false;
  let stepCount = 0;
  let holdTimeout = null;
  let holdDelayTimeout = null;
  function formatNumber(val = "") {
    let parsedStr = typeof val === "number" ? String(val) : val;
    if (decimalSeparator) {
      parsedStr = parsedStr.replace(/\./g, decimalSeparator);
    }
    return formatter(parsedStr);
  }
  function parseNumber(val) {
    let number = val;
    if (decimalSeparator) {
      number = number.replace(new RegExp(`\\${decimalSeparator}`, "g"), ".");
    }
    return parser(number);
  }
  function onInput() {
    if (this.value === "" || this.value === "-") {
      $$invalidate(0, value = void 0);
    } else {
      const parsedNumber = parseNumber(this.value);
      if (parsedNumber === void 0 || Number.isNaN(parseNumber))
        return;
      $$invalidate(0, value = parseFloat(parsedNumber));
    }
    dispatch("change", value);
  }
  function stepInterval(up) {
    const interval = typeof stepHoldInterval === "number" ? stepHoldInterval : stepHoldInterval(stepCount);
    holdTimeout = setTimeout(
      () => {
        onStep(up, true, false);
      },
      interval
    );
  }
  function onStep(up, hold = true, first = true) {
    const _value = value === void 0 ? 0 : value;
    const tmpValue = up ? _value + step : _value - step;
    const clamped = _clamp(tmpValue);
    $$invalidate(0, value = parseFloat(clamped.toFixed(precision)));
    stepCount += 1;
    dispatch("change", value);
    if (!hold)
      return;
    if (first) {
      holdDelayTimeout = setTimeout(() => stepInterval(up), stepHoldDelay);
    } else {
      stepInterval(up);
    }
  }
  function onStepDone() {
    if (holdDelayTimeout)
      clearTimeout(holdDelayTimeout);
    if (holdTimeout)
      clearTimeout(holdTimeout);
    holdDelayTimeout = null;
    holdTimeout = null;
    stepCount = 0;
  }
  function onKeyDown(event) {
    if (event.key !== "ArrowUp" && event.key !== "ArrowDown")
      return;
    if (isKeyDown)
      return;
    isKeyDown = true;
    onStep(event.key === "ArrowUp");
  }
  function onKeyUp(event) {
    if (event.key !== "ArrowUp" && event.key !== "ArrowDown")
      return;
    isKeyDown = false;
    onStepDone();
  }
  function onBlur() {
    if (noClampOnBlur || value === void 0)
      return;
    const clamped = _clamp(value);
    $$invalidate(0, value = parseFloat(clamped.toFixed(precision)));
    dispatch("change", value);
    $$invalidate(1, element2.value = formatNumber(value), element2);
  }
  function _clamp(value2) {
    return Math.min(Math.max(value2, min), max);
  }
  function _valueC(val) {
    if (val === void 0 && typeof defaultValue === "number") {
      return defaultValue;
    }
    if (typeof val !== "number") {
      return void 0;
    }
    return val;
  }
  const mousedown_handler = () => onStep(true);
  const mousedown_handler_1 = () => onStep(false);
  function textinput_element_binding(value2) {
    element2 = value2;
    $$invalidate(1, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(31, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(1, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(4, override = $$new_props.override);
    if ("overrideControls" in $$new_props)
      $$invalidate(5, overrideControls = $$new_props.overrideControls);
    if ("root" in $$new_props)
      $$invalidate(6, root = $$new_props.root);
    if ("placeholder" in $$new_props)
      $$invalidate(7, placeholder = $$new_props.placeholder);
    if ("icon" in $$new_props)
      $$invalidate(8, icon = $$new_props.icon);
    if ("iconWidth" in $$new_props)
      $$invalidate(9, iconWidth = $$new_props.iconWidth);
    if ("iconProps" in $$new_props)
      $$invalidate(10, iconProps = $$new_props.iconProps);
    if ("wrapperProps" in $$new_props)
      $$invalidate(11, wrapperProps = $$new_props.wrapperProps);
    if ("required" in $$new_props)
      $$invalidate(12, required = $$new_props.required);
    if ("radius" in $$new_props)
      $$invalidate(13, radius2 = $$new_props.radius);
    if ("variant" in $$new_props)
      $$invalidate(14, variant2 = $$new_props.variant);
    if ("disabled" in $$new_props)
      $$invalidate(15, disabled = $$new_props.disabled);
    if ("size" in $$new_props)
      $$invalidate(16, size3 = $$new_props.size);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("defaultValue" in $$new_props)
      $$invalidate(32, defaultValue = $$new_props.defaultValue);
    if ("decimalSeparator" in $$new_props)
      $$invalidate(33, decimalSeparator = $$new_props.decimalSeparator);
    if ("min" in $$new_props)
      $$invalidate(17, min = $$new_props.min);
    if ("max" in $$new_props)
      $$invalidate(18, max = $$new_props.max);
    if ("step" in $$new_props)
      $$invalidate(34, step = $$new_props.step);
    if ("stepHoldDelay" in $$new_props)
      $$invalidate(35, stepHoldDelay = $$new_props.stepHoldDelay);
    if ("stepHoldInterval" in $$new_props)
      $$invalidate(36, stepHoldInterval = $$new_props.stepHoldInterval);
    if ("hideControls" in $$new_props)
      $$invalidate(37, hideControls = $$new_props.hideControls);
    if ("precision" in $$new_props)
      $$invalidate(38, precision = $$new_props.precision);
    if ("noClampOnBlur" in $$new_props)
      $$invalidate(39, noClampOnBlur = $$new_props.noClampOnBlur);
    if ("formatter" in $$new_props)
      $$invalidate(40, formatter = $$new_props.formatter);
    if ("parser" in $$new_props)
      $$invalidate(41, parser = $$new_props.parser);
    if ("$$scope" in $$new_props)
      $$invalidate(48, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    get_current_component,
    createEventForwarder,
    useActions,
    TextInput: TextInput_default,
    useStyles: NumberInput_styles_default,
    defaultFormatter,
    defaultParser,
    use,
    element: element2,
    className,
    override,
    overrideControls,
    root,
    placeholder,
    icon,
    iconWidth,
    iconProps,
    wrapperProps,
    required,
    radius: radius2,
    variant: variant2,
    disabled,
    size: size3,
    value,
    defaultValue,
    decimalSeparator,
    min,
    max,
    step,
    stepHoldDelay,
    stepHoldInterval,
    hideControls,
    precision,
    noClampOnBlur,
    formatter,
    parser,
    increment,
    decrement,
    dispatch,
    forwardEvents,
    isKeyDown,
    stepCount,
    holdTimeout,
    holdDelayTimeout,
    formatNumber,
    parseNumber,
    onInput,
    stepInterval,
    onStep,
    onStepDone,
    onKeyDown,
    onKeyUp,
    onBlur,
    _clamp,
    _valueC,
    getStyles,
    classes,
    cx: cx2,
    showControls
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(1, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(4, override = $$new_props.override);
    if ("overrideControls" in $$props)
      $$invalidate(5, overrideControls = $$new_props.overrideControls);
    if ("root" in $$props)
      $$invalidate(6, root = $$new_props.root);
    if ("placeholder" in $$props)
      $$invalidate(7, placeholder = $$new_props.placeholder);
    if ("icon" in $$props)
      $$invalidate(8, icon = $$new_props.icon);
    if ("iconWidth" in $$props)
      $$invalidate(9, iconWidth = $$new_props.iconWidth);
    if ("iconProps" in $$props)
      $$invalidate(10, iconProps = $$new_props.iconProps);
    if ("wrapperProps" in $$props)
      $$invalidate(11, wrapperProps = $$new_props.wrapperProps);
    if ("required" in $$props)
      $$invalidate(12, required = $$new_props.required);
    if ("radius" in $$props)
      $$invalidate(13, radius2 = $$new_props.radius);
    if ("variant" in $$props)
      $$invalidate(14, variant2 = $$new_props.variant);
    if ("disabled" in $$props)
      $$invalidate(15, disabled = $$new_props.disabled);
    if ("size" in $$props)
      $$invalidate(16, size3 = $$new_props.size);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("defaultValue" in $$props)
      $$invalidate(32, defaultValue = $$new_props.defaultValue);
    if ("decimalSeparator" in $$props)
      $$invalidate(33, decimalSeparator = $$new_props.decimalSeparator);
    if ("min" in $$props)
      $$invalidate(17, min = $$new_props.min);
    if ("max" in $$props)
      $$invalidate(18, max = $$new_props.max);
    if ("step" in $$props)
      $$invalidate(34, step = $$new_props.step);
    if ("stepHoldDelay" in $$props)
      $$invalidate(35, stepHoldDelay = $$new_props.stepHoldDelay);
    if ("stepHoldInterval" in $$props)
      $$invalidate(36, stepHoldInterval = $$new_props.stepHoldInterval);
    if ("hideControls" in $$props)
      $$invalidate(37, hideControls = $$new_props.hideControls);
    if ("precision" in $$props)
      $$invalidate(38, precision = $$new_props.precision);
    if ("noClampOnBlur" in $$props)
      $$invalidate(39, noClampOnBlur = $$new_props.noClampOnBlur);
    if ("formatter" in $$props)
      $$invalidate(40, formatter = $$new_props.formatter);
    if ("parser" in $$props)
      $$invalidate(41, parser = $$new_props.parser);
    if ("isKeyDown" in $$props)
      isKeyDown = $$new_props.isKeyDown;
    if ("stepCount" in $$props)
      stepCount = $$new_props.stepCount;
    if ("holdTimeout" in $$props)
      holdTimeout = $$new_props.holdTimeout;
    if ("holdDelayTimeout" in $$props)
      holdDelayTimeout = $$new_props.holdDelayTimeout;
    if ("getStyles" in $$props)
      $$invalidate(19, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(20, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(21, cx2 = $$new_props.cx);
    if ("showControls" in $$props)
      $$invalidate(22, showControls = $$new_props.showControls);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*value*/
    1) {
      $:
        $$invalidate(0, value = _valueC(value));
    }
    if ($$self.$$.dirty[0] & /*variant, disabled*/
    49152 | $$self.$$.dirty[1] & /*hideControls*/
    64) {
      $:
        $$invalidate(22, showControls = !hideControls && variant2 !== "unstyled" && !disabled);
    }
    if ($$self.$$.dirty[0] & /*radius, size*/
    73728) {
      $:
        $$invalidate(21, { cx: cx2, classes, getStyles } = NumberInput_styles_default({ radius: radius2, size: size3 }, { name: "NumberInput" }), cx2, ($$invalidate(20, classes), $$invalidate(13, radius2), $$invalidate(16, size3)), ($$invalidate(19, getStyles), $$invalidate(13, radius2), $$invalidate(16, size3)));
    }
  };
  return [
    value,
    element2,
    use,
    className,
    override,
    overrideControls,
    root,
    placeholder,
    icon,
    iconWidth,
    iconProps,
    wrapperProps,
    required,
    radius2,
    variant2,
    disabled,
    size3,
    min,
    max,
    getStyles,
    classes,
    cx2,
    showControls,
    forwardEvents,
    formatNumber,
    onInput,
    onStep,
    onStepDone,
    onKeyDown,
    onKeyUp,
    onBlur,
    $$restProps,
    defaultValue,
    decimalSeparator,
    step,
    stepHoldDelay,
    stepHoldInterval,
    hideControls,
    precision,
    noClampOnBlur,
    formatter,
    parser,
    increment,
    decrement,
    slots,
    mousedown_handler,
    mousedown_handler_1,
    textinput_element_binding,
    $$scope
  ];
}
var NumberInput = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance84,
      create_fragment84,
      safe_not_equal,
      {
        use: 2,
        element: 1,
        class: 3,
        override: 4,
        overrideControls: 5,
        root: 6,
        placeholder: 7,
        icon: 8,
        iconWidth: 9,
        iconProps: 10,
        wrapperProps: 11,
        required: 12,
        radius: 13,
        variant: 14,
        disabled: 15,
        size: 16,
        value: 0,
        defaultValue: 32,
        decimalSeparator: 33,
        min: 17,
        max: 18,
        step: 34,
        stepHoldDelay: 35,
        stepHoldInterval: 36,
        hideControls: 37,
        precision: 38,
        noClampOnBlur: 39,
        formatter: 40,
        parser: 41,
        increment: 42,
        decrement: 43
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NumberInput",
      options,
      id: create_fragment84.name
    });
  }
  get use() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get overrideControls() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set overrideControls(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get root() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set root(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconWidth() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconWidth(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconProps() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconProps(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrapperProps() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrapperProps(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get defaultValue() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultValue(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get decimalSeparator() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set decimalSeparator(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stepHoldDelay() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stepHoldDelay(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stepHoldInterval() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stepHoldInterval(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideControls() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideControls(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get precision() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set precision(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noClampOnBlur() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noClampOnBlur(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get formatter() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set formatter(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parser() {
    throw new Error("<NumberInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parser(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get increment() {
    return this.$$.ctx[42];
  }
  set increment(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get decrement() {
    return this.$$.ctx[43];
  }
  set decrement(value) {
    throw new Error("<NumberInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NumberInput_default = NumberInput;

// node_modules/@svelteuidev/core/dist/components/ObserverRender/ObserverRender.svelte
var get_default_slot_changes2 = (dirty) => ({
  visible: dirty & /*visible*/
  32,
  entry: dirty & /*entry*/
  64,
  scrollDirection: dirty & /*scrollDirection*/
  128,
  observer: dirty & /*observer*/
  256,
  node: dirty & /*node*/
  512
});
var get_default_slot_context2 = (ctx8) => ({
  visible: (
    /*visible*/
    ctx8[5]
  ),
  entry: (
    /*entry*/
    ctx8[6]
  ),
  scrollDirection: (
    /*scrollDirection*/
    ctx8[7]
  ),
  observer: (
    /*observer*/
    ctx8[8]
  ),
  node: (
    /*node*/
    ctx8[9]
  )
});
function create_default_slot63(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[17],
    get_default_slot_context2
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, visible, entry, scrollDirection, observer, node*/
        132064)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[17],
              dirty,
              get_default_slot_changes2
            ),
            get_default_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot63.name,
    type: "slot",
    source: "(12:0) <Box  bind:element  use={[[io, options], ...use]}  class={className}  css={{ ...override }}  {...$$restProps}  on:change={(event) => {   const {    inView,    entry: _entry,    scrollDirection: _scrollDirection,    observer: _observer,    node: _node   } = event.detail;   visible = inView;   entry = _entry;   scrollDirection = _scrollDirection;   observer = _observer;   node = _node;  }}  on:enter={(event) => {   const {    inView,    entry: _entry,    scrollDirection: _scrollDirection,    observer: _observer,    node: _node   } = event.detail;   visible = inView;   entry = _entry;   scrollDirection = _scrollDirection;   observer = _observer;   node = _node;  }}  on:leave={(event) => {   const {    inView,    entry: _entry,    scrollDirection: _scrollDirection,    observer: _observer,    node: _node   } = event.detail;   visible = inView;   entry = _entry;   scrollDirection = _scrollDirection;   observer = _observer;   node = _node;  }}  on:init={(event) => {   const { observer: _observer, node: _node } = event.detail;   observer = _observer;   node = _node;  }} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment85(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    {
      use: [[
        io,
        /*options*/
        ctx8[4]
      ], .../*use*/
      ctx8[1]]
    },
    { class: (
      /*className*/
      ctx8[2]
    ) },
    { css: { .../*override*/
    ctx8[3] } },
    /*$$restProps*/
    ctx8[10]
  ];
  function box_element_binding(value) {
    ctx8[12](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot63] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  box.$on(
    "change",
    /*change_handler*/
    ctx8[13]
  );
  box.$on(
    "enter",
    /*enter_handler*/
    ctx8[14]
  );
  box.$on(
    "leave",
    /*leave_handler*/
    ctx8[15]
  );
  box.$on(
    "init",
    /*init_handler*/
    ctx8[16]
  );
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*options, use, className, override, $$restProps*/
      1054 ? get_spread_update(box_spread_levels, [
        dirty & /*options, use*/
        18 && {
          use: [[
            io,
            /*options*/
            ctx9[4]
          ], .../*use*/
          ctx9[1]]
        },
        dirty & /*className*/
        4 && { class: (
          /*className*/
          ctx9[2]
        ) },
        dirty & /*override*/
        8 && { css: { .../*override*/
        ctx9[3] } },
        dirty & /*$$restProps*/
        1024 && get_spread_object(
          /*$$restProps*/
          ctx9[10]
        )
      ]) : {};
      if (dirty & /*$$scope, visible, entry, scrollDirection, observer, node*/
      132064) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment85.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance85($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "element", "class", "override", "options"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ObserverRender", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, options = {} } = $$props;
  let visible2 = null;
  let entry = null;
  let scrollDirection = null;
  let observer = null;
  let node = null;
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  const change_handler = (event) => {
    const { inView, entry: _entry, scrollDirection: _scrollDirection, observer: _observer, node: _node } = event.detail;
    $$invalidate(5, visible2 = inView);
    $$invalidate(6, entry = _entry);
    $$invalidate(7, scrollDirection = _scrollDirection);
    $$invalidate(8, observer = _observer);
    $$invalidate(9, node = _node);
  };
  const enter_handler = (event) => {
    const { inView, entry: _entry, scrollDirection: _scrollDirection, observer: _observer, node: _node } = event.detail;
    $$invalidate(5, visible2 = inView);
    $$invalidate(6, entry = _entry);
    $$invalidate(7, scrollDirection = _scrollDirection);
    $$invalidate(8, observer = _observer);
    $$invalidate(9, node = _node);
  };
  const leave_handler = (event) => {
    const { inView, entry: _entry, scrollDirection: _scrollDirection, observer: _observer, node: _node } = event.detail;
    $$invalidate(5, visible2 = inView);
    $$invalidate(6, entry = _entry);
    $$invalidate(7, scrollDirection = _scrollDirection);
    $$invalidate(8, observer = _observer);
    $$invalidate(9, node = _node);
  };
  const init_handler = (event) => {
    const { observer: _observer, node: _node } = event.detail;
    $$invalidate(8, observer = _observer);
    $$invalidate(9, node = _node);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("options" in $$new_props)
      $$invalidate(4, options = $$new_props.options);
    if ("$$scope" in $$new_props)
      $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    io,
    Box: Box_default,
    use,
    element: element2,
    className,
    override,
    options,
    visible: visible2,
    entry,
    scrollDirection,
    observer,
    node
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("options" in $$props)
      $$invalidate(4, options = $$new_props.options);
    if ("visible" in $$props)
      $$invalidate(5, visible2 = $$new_props.visible);
    if ("entry" in $$props)
      $$invalidate(6, entry = $$new_props.entry);
    if ("scrollDirection" in $$props)
      $$invalidate(7, scrollDirection = $$new_props.scrollDirection);
    if ("observer" in $$props)
      $$invalidate(8, observer = $$new_props.observer);
    if ("node" in $$props)
      $$invalidate(9, node = $$new_props.node);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    element2,
    use,
    className,
    override,
    options,
    visible2,
    entry,
    scrollDirection,
    observer,
    node,
    $$restProps,
    slots,
    box_element_binding,
    change_handler,
    enter_handler,
    leave_handler,
    init_handler,
    $$scope
  ];
}
var ObserverRender = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance85, create_fragment85, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      options: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ObserverRender",
      options,
      id: create_fragment85.name
    });
  }
  get use() {
    throw new Error("<ObserverRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<ObserverRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<ObserverRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<ObserverRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<ObserverRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<ObserverRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<ObserverRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<ObserverRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<ObserverRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<ObserverRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ObserverRender_default = ObserverRender;

// node_modules/@svelteuidev/core/dist/components/PasswordInput/PasswordToggleIcon.svelte
var file39 = "node_modules/@svelteuidev/core/dist/components/PasswordInput/PasswordToggleIcon.svelte";
function create_fragment86(ctx8) {
  let svg;
  let path;
  let path_d_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        viewBox: true,
        fill: true,
        xmlns: true,
        style: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", {
        d: true,
        fill: true,
        "fill-rule": true,
        "clip-rule": true
      });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", path_d_value = /*reveal*/
      ctx8[1] ? "M13.3536 2.35355C13.5488 2.15829 13.5488 1.84171 13.3536 1.64645C13.1583 1.45118 12.8417 1.45118 12.6464 1.64645L10.6828 3.61012C9.70652 3.21671 8.63759 3 7.5 3C4.30786 3 1.65639 4.70638 0.0760002 7.23501C-0.0253338 7.39715 -0.0253334 7.60288 0.0760014 7.76501C0.902945 9.08812 2.02314 10.1861 3.36061 10.9323L1.64645 12.6464C1.45118 12.8417 1.45118 13.1583 1.64645 13.3536C1.84171 13.5488 2.15829 13.5488 2.35355 13.3536L4.31723 11.3899C5.29348 11.7833 6.36241 12 7.5 12C10.6921 12 13.3436 10.2936 14.924 7.76501C15.0253 7.60288 15.0253 7.39715 14.924 7.23501C14.0971 5.9119 12.9769 4.81391 11.6394 4.06771L13.3536 2.35355ZM9.90428 4.38861C9.15332 4.1361 8.34759 4 7.5 4C4.80285 4 2.52952 5.37816 1.09622 7.50001C1.87284 8.6497 2.89609 9.58106 4.09974 10.1931L9.90428 4.38861ZM5.09572 10.6114L10.9003 4.80685C12.1039 5.41894 13.1272 6.35031 13.9038 7.50001C12.4705 9.62183 10.1971 11 7.5 11C6.65241 11 5.84668 10.8639 5.09572 10.6114Z" : "M7.5 11C4.80285 11 2.52952 9.62184 1.09622 7.50001C2.52952 5.37816 4.80285 4 7.5 4C10.1971 4 12.4705 5.37816 13.9038 7.50001C12.4705 9.62183 10.1971 11 7.5 11ZM7.5 3C4.30786 3 1.65639 4.70638 0.0760002 7.23501C-0.0253338 7.39715 -0.0253334 7.60288 0.0760014 7.76501C1.65639 10.2936 4.30786 12 7.5 12C10.6921 12 13.3436 10.2936 14.924 7.76501C15.0253 7.60288 15.0253 7.39715 14.924 7.23501C13.3436 4.70638 10.6921 3 7.5 3ZM7.5 9.5C8.60457 9.5 9.5 8.60457 9.5 7.5C9.5 6.39543 8.60457 5.5 7.5 5.5C6.39543 5.5 5.5 6.39543 5.5 7.5C5.5 8.60457 6.39543 9.5 7.5 9.5Z");
      attr_dev(path, "fill", "currentColor");
      attr_dev(path, "fill-rule", "evenodd");
      attr_dev(path, "clip-rule", "evenodd");
      add_location(path, file39, 10, 1, 173);
      attr_dev(svg, "viewBox", "0 0 15 15");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      set_style(
        svg,
        "width",
        /*size*/
        ctx8[0]
      );
      set_style(
        svg,
        "height",
        /*size*/
        ctx8[0]
      );
      add_location(svg, file39, 4, 0, 55);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx9, [dirty]) {
      if (dirty & /*reveal*/
      2 && path_d_value !== (path_d_value = /*reveal*/
      ctx9[1] ? "M13.3536 2.35355C13.5488 2.15829 13.5488 1.84171 13.3536 1.64645C13.1583 1.45118 12.8417 1.45118 12.6464 1.64645L10.6828 3.61012C9.70652 3.21671 8.63759 3 7.5 3C4.30786 3 1.65639 4.70638 0.0760002 7.23501C-0.0253338 7.39715 -0.0253334 7.60288 0.0760014 7.76501C0.902945 9.08812 2.02314 10.1861 3.36061 10.9323L1.64645 12.6464C1.45118 12.8417 1.45118 13.1583 1.64645 13.3536C1.84171 13.5488 2.15829 13.5488 2.35355 13.3536L4.31723 11.3899C5.29348 11.7833 6.36241 12 7.5 12C10.6921 12 13.3436 10.2936 14.924 7.76501C15.0253 7.60288 15.0253 7.39715 14.924 7.23501C14.0971 5.9119 12.9769 4.81391 11.6394 4.06771L13.3536 2.35355ZM9.90428 4.38861C9.15332 4.1361 8.34759 4 7.5 4C4.80285 4 2.52952 5.37816 1.09622 7.50001C1.87284 8.6497 2.89609 9.58106 4.09974 10.1931L9.90428 4.38861ZM5.09572 10.6114L10.9003 4.80685C12.1039 5.41894 13.1272 6.35031 13.9038 7.50001C12.4705 9.62183 10.1971 11 7.5 11C6.65241 11 5.84668 10.8639 5.09572 10.6114Z" : "M7.5 11C4.80285 11 2.52952 9.62184 1.09622 7.50001C2.52952 5.37816 4.80285 4 7.5 4C10.1971 4 12.4705 5.37816 13.9038 7.50001C12.4705 9.62183 10.1971 11 7.5 11ZM7.5 3C4.30786 3 1.65639 4.70638 0.0760002 7.23501C-0.0253338 7.39715 -0.0253334 7.60288 0.0760014 7.76501C1.65639 10.2936 4.30786 12 7.5 12C10.6921 12 13.3436 10.2936 14.924 7.76501C15.0253 7.60288 15.0253 7.39715 14.924 7.23501C13.3436 4.70638 10.6921 3 7.5 3ZM7.5 9.5C8.60457 9.5 9.5 8.60457 9.5 7.5C9.5 6.39543 8.60457 5.5 7.5 5.5C6.39543 5.5 5.5 6.39543 5.5 7.5C5.5 8.60457 6.39543 9.5 7.5 9.5Z")) {
        attr_dev(path, "d", path_d_value);
      }
      if (dirty & /*size*/
      1) {
        set_style(
          svg,
          "width",
          /*size*/
          ctx9[0]
        );
      }
      if (dirty & /*size*/
      1) {
        set_style(
          svg,
          "height",
          /*size*/
          ctx9[0]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment86.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance86($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PasswordToggleIcon", slots, []);
  let { size: size3 } = $$props;
  let { reveal } = $$props;
  $$self.$$.on_mount.push(function() {
    if (size3 === void 0 && !("size" in $$props || $$self.$$.bound[$$self.$$.props["size"]])) {
      console.warn("<PasswordToggleIcon> was created without expected prop 'size'");
    }
    if (reveal === void 0 && !("reveal" in $$props || $$self.$$.bound[$$self.$$.props["reveal"]])) {
      console.warn("<PasswordToggleIcon> was created without expected prop 'reveal'");
    }
  });
  const writable_props = ["size", "reveal"];
  Object.keys($$props).forEach((key3) => {
    if (!~writable_props.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<PasswordToggleIcon> was created with unknown prop '${key3}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size3 = $$props2.size);
    if ("reveal" in $$props2)
      $$invalidate(1, reveal = $$props2.reveal);
  };
  $$self.$capture_state = () => ({ size: size3, reveal });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size3 = $$props2.size);
    if ("reveal" in $$props2)
      $$invalidate(1, reveal = $$props2.reveal);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size3, reveal];
}
var PasswordToggleIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance86, create_fragment86, safe_not_equal, { size: 0, reveal: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PasswordToggleIcon",
      options,
      id: create_fragment86.name
    });
  }
  get size() {
    throw new Error("<PasswordToggleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PasswordToggleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get reveal() {
    throw new Error("<PasswordToggleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set reveal(value) {
    throw new Error("<PasswordToggleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PasswordToggleIcon_default = PasswordToggleIcon;

// node_modules/@svelteuidev/core/dist/components/PasswordInput/PasswordInput.styles.js
function getButtonSize(size3) {
  const sizes15 = {
    xs: rem(22),
    sm: rem(26),
    md: rem(28),
    lg: rem(32),
    xl: rem(40)
  };
  return getSize({ size: size3, sizes: sizes15 });
}
function getIconSize(size3) {
  const sizes15 = {
    xs: rem(12),
    sm: rem(15),
    md: rem(17),
    lg: rem(19),
    xl: rem(21)
  };
  return getSize({ size: size3, sizes: sizes15 });
}
function getRightSectionWidth(size3) {
  const sizes15 = {
    xs: rem(28),
    sm: rem(32),
    md: rem(34),
    lg: rem(44),
    xl: rem(54)
  };
  return getSize({ size: size3, sizes: sizes15 });
}

// node_modules/@svelteuidev/core/dist/components/PasswordInput/PasswordInput.svelte
var get_visibilityToggleIcon_slot_changes = (dirty) => ({ visible: dirty[0] & /*_visible*/
1048576 });
var get_visibilityToggleIcon_slot_context = (ctx8) => ({ visible: (
  /*_visible*/
  ctx8[20]
) });
function create_if_block33(ctx8) {
  let actionicon;
  let current;
  actionicon = new ActionIcon_default({
    props: {
      tabindex: (
        /*toggleTabIndex*/
        ctx8[18]
      ),
      radius: (
        /*radius*/
        ctx8[16]
      ),
      size: getButtonSize(
        /*size*/
        ctx8[15]
      ),
      "aria-hidden": !/*visibilityToggleLabel*/
      ctx8[19],
      "aria-label": (
        /*visibilityToggleLabel*/
        ctx8[19]
      ),
      $$slots: { default: [create_default_slot_117] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  actionicon.$on(
    "click",
    /*toggleVisibility*/
    ctx8[23]
  );
  const block = {
    c: function create() {
      create_component(actionicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(actionicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(actionicon, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const actionicon_changes = {};
      if (dirty[0] & /*toggleTabIndex*/
      262144)
        actionicon_changes.tabindex = /*toggleTabIndex*/
        ctx9[18];
      if (dirty[0] & /*radius*/
      65536)
        actionicon_changes.radius = /*radius*/
        ctx9[16];
      if (dirty[0] & /*size*/
      32768)
        actionicon_changes.size = getButtonSize(
          /*size*/
          ctx9[15]
        );
      if (dirty[0] & /*visibilityToggleLabel*/
      524288)
        actionicon_changes["aria-hidden"] = !/*visibilityToggleLabel*/
        ctx9[19];
      if (dirty[0] & /*visibilityToggleLabel*/
      524288)
        actionicon_changes["aria-label"] = /*visibilityToggleLabel*/
        ctx9[19];
      if (dirty[0] & /*_visible, size*/
      1081344 | dirty[1] & /*$$scope*/
      4) {
        actionicon_changes.$$scope = { dirty, ctx: ctx9 };
      }
      actionicon.$set(actionicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(actionicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(actionicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(actionicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block33.name,
    type: "if",
    source: "(71:3) {#if !disabled}",
    ctx: ctx8
  });
  return block;
}
function fallback_block20(ctx8) {
  let passwordtoggleicon;
  let current;
  passwordtoggleicon = new PasswordToggleIcon_default({
    props: {
      reveal: (
        /*_visible*/
        ctx8[20]
      ),
      size: getIconSize(
        /*size*/
        ctx8[15]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(passwordtoggleicon.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(passwordtoggleicon.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(passwordtoggleicon, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const passwordtoggleicon_changes = {};
      if (dirty[0] & /*_visible*/
      1048576)
        passwordtoggleicon_changes.reveal = /*_visible*/
        ctx9[20];
      if (dirty[0] & /*size*/
      32768)
        passwordtoggleicon_changes.size = getIconSize(
          /*size*/
          ctx9[15]
        );
      passwordtoggleicon.$set(passwordtoggleicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(passwordtoggleicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(passwordtoggleicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(passwordtoggleicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block20.name,
    type: "fallback",
    source: "(80:58)        ",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_117(ctx8) {
  let current;
  const visibilityToggleIcon_slot_template = (
    /*#slots*/
    ctx8[30].visibilityToggleIcon
  );
  const visibilityToggleIcon_slot = create_slot(
    visibilityToggleIcon_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[33],
    get_visibilityToggleIcon_slot_context
  );
  const visibilityToggleIcon_slot_or_fallback = visibilityToggleIcon_slot || fallback_block20(ctx8);
  const block = {
    c: function create() {
      if (visibilityToggleIcon_slot_or_fallback)
        visibilityToggleIcon_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (visibilityToggleIcon_slot_or_fallback)
        visibilityToggleIcon_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (visibilityToggleIcon_slot_or_fallback) {
        visibilityToggleIcon_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (visibilityToggleIcon_slot) {
        if (visibilityToggleIcon_slot.p && (!current || dirty[0] & /*_visible*/
        1048576 | dirty[1] & /*$$scope*/
        4)) {
          update_slot_base(
            visibilityToggleIcon_slot,
            visibilityToggleIcon_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[33],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[33]
            ) : get_slot_changes(
              visibilityToggleIcon_slot_template,
              /*$$scope*/
              ctx9[33],
              dirty,
              get_visibilityToggleIcon_slot_changes
            ),
            get_visibilityToggleIcon_slot_context
          );
        }
      } else {
        if (visibilityToggleIcon_slot_or_fallback && visibilityToggleIcon_slot_or_fallback.p && (!current || dirty[0] & /*_visible, size*/
        1081344)) {
          visibilityToggleIcon_slot_or_fallback.p(ctx9, !current ? [-1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(visibilityToggleIcon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(visibilityToggleIcon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (visibilityToggleIcon_slot_or_fallback)
        visibilityToggleIcon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_117.name,
    type: "slot",
    source: "(72:4) <ActionIcon      tabindex={toggleTabIndex}      {radius}      size={getButtonSize(size)}      aria-hidden={!visibilityToggleLabel}      aria-label={visibilityToggleLabel}      on:click={toggleVisibility}     >",
    ctx: ctx8
  });
  return block;
}
function create_rightSection_slot6(ctx8) {
  let if_block_anchor;
  let current;
  let if_block = !/*disabled*/
  ctx8[9] && create_if_block33(ctx8);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (!/*disabled*/
      ctx9[9]) {
        if (if_block) {
          if_block.p(ctx9, dirty);
          if (dirty[0] & /*disabled*/
          512) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block33(ctx9);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_rightSection_slot6.name,
    type: "slot",
    source: '(70:2) <svelte:fragment slot=\\"rightSection\\">',
    ctx: ctx8
  });
  return block;
}
function create_default_slot64(ctx8) {
  let input;
  let updating_value;
  let current;
  const input_spread_levels = [
    { required: (
      /*required*/
      ctx8[8]
    ) },
    { size: (
      /*size*/
      ctx8[15]
    ) },
    { id: (
      /*id*/
      ctx8[13]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx8[17]
    ) },
    { radius: (
      /*radius*/
      ctx8[16]
    ) },
    {
      rightSectionWidth: getRightSectionWidth(
        /*size*/
        ctx8[15]
      )
    },
    { disabled: (
      /*disabled*/
      ctx8[9]
    ) },
    /*$$restProps*/
    ctx8[24],
    {
      use: [
        /*forwardEvents*/
        ctx8[22],
        [
          useActions,
          /*use*/
          ctx8[2]
        ]
      ]
    },
    { invalid: (
      /*_invalid*/
      ctx8[21]
    ) },
    { showRightSection: true },
    {
      type: (
        /*_visible*/
        ctx8[20] ? "text" : "password"
      )
    }
  ];
  function input_value_binding(value) {
    ctx8[31](value);
  }
  let input_props = {
    $$slots: { rightSection: [create_rightSection_slot6] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < input_spread_levels.length; i2 += 1) {
    input_props = assign(input_props, input_spread_levels[i2]);
  }
  if (
    /*value*/
    ctx8[1] !== void 0
  ) {
    input_props.value = /*value*/
    ctx8[1];
  }
  input = new Input_default({ props: input_props, $$inline: true });
  binding_callbacks.push(() => bind(input, "value", input_value_binding));
  const block = {
    c: function create() {
      create_component(input.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(input.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(input, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const input_changes = dirty[0] & /*required, size, id, placeholder, radius, disabled, $$restProps, forwardEvents, use, _invalid, _visible*/
      24355588 ? get_spread_update(input_spread_levels, [
        dirty[0] & /*required*/
        256 && { required: (
          /*required*/
          ctx9[8]
        ) },
        dirty[0] & /*size*/
        32768 && { size: (
          /*size*/
          ctx9[15]
        ) },
        dirty[0] & /*id*/
        8192 && { id: (
          /*id*/
          ctx9[13]
        ) },
        dirty[0] & /*placeholder*/
        131072 && { placeholder: (
          /*placeholder*/
          ctx9[17]
        ) },
        dirty[0] & /*radius*/
        65536 && { radius: (
          /*radius*/
          ctx9[16]
        ) },
        dirty[0] & /*size*/
        32768 && {
          rightSectionWidth: getRightSectionWidth(
            /*size*/
            ctx9[15]
          )
        },
        dirty[0] & /*disabled*/
        512 && { disabled: (
          /*disabled*/
          ctx9[9]
        ) },
        dirty[0] & /*$$restProps*/
        16777216 && get_spread_object(
          /*$$restProps*/
          ctx9[24]
        ),
        dirty[0] & /*forwardEvents, use*/
        4194308 && {
          use: [
            /*forwardEvents*/
            ctx9[22],
            [
              useActions,
              /*use*/
              ctx9[2]
            ]
          ]
        },
        dirty[0] & /*_invalid*/
        2097152 && { invalid: (
          /*_invalid*/
          ctx9[21]
        ) },
        input_spread_levels[10],
        dirty[0] & /*_visible*/
        1048576 && {
          type: (
            /*_visible*/
            ctx9[20] ? "text" : "password"
          )
        }
      ]) : {};
      if (dirty[0] & /*toggleTabIndex, radius, size, visibilityToggleLabel, _visible, disabled*/
      1933824 | dirty[1] & /*$$scope*/
      4) {
        input_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_value && dirty[0] & /*value*/
      2) {
        updating_value = true;
        input_changes.value = /*value*/
        ctx9[1];
        add_flush_callback(() => updating_value = false);
      }
      input.$set(input_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(input.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(input.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(input, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot64.name,
    type: "slot",
    source: "(40:0) <InputWrapper  bind:element  class={className}  {override}  {label}  {description}  {error}  {required}  {labelProps}  {descriptionProps}  {errorProps}  {id}  {labelElement}  {size} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment87(ctx8) {
  let inputwrapper;
  let updating_element;
  let current;
  function inputwrapper_element_binding(value) {
    ctx8[32](value);
  }
  let inputwrapper_props = {
    class: (
      /*className*/
      ctx8[3]
    ),
    override: (
      /*override*/
      ctx8[4]
    ),
    label: (
      /*label*/
      ctx8[5]
    ),
    description: (
      /*description*/
      ctx8[6]
    ),
    error: (
      /*error*/
      ctx8[7]
    ),
    required: (
      /*required*/
      ctx8[8]
    ),
    labelProps: (
      /*labelProps*/
      ctx8[10]
    ),
    descriptionProps: (
      /*descriptionProps*/
      ctx8[11]
    ),
    errorProps: (
      /*errorProps*/
      ctx8[12]
    ),
    id: (
      /*id*/
      ctx8[13]
    ),
    labelElement: (
      /*labelElement*/
      ctx8[14]
    ),
    size: (
      /*size*/
      ctx8[15]
    ),
    $$slots: { default: [create_default_slot64] },
    $$scope: { ctx: ctx8 }
  };
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    inputwrapper_props.element = /*element*/
    ctx8[0];
  }
  inputwrapper = new InputWrapper_default({
    props: inputwrapper_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(inputwrapper, "element", inputwrapper_element_binding));
  const block = {
    c: function create() {
      create_component(inputwrapper.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(inputwrapper.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(inputwrapper, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const inputwrapper_changes = {};
      if (dirty[0] & /*className*/
      8)
        inputwrapper_changes.class = /*className*/
        ctx9[3];
      if (dirty[0] & /*override*/
      16)
        inputwrapper_changes.override = /*override*/
        ctx9[4];
      if (dirty[0] & /*label*/
      32)
        inputwrapper_changes.label = /*label*/
        ctx9[5];
      if (dirty[0] & /*description*/
      64)
        inputwrapper_changes.description = /*description*/
        ctx9[6];
      if (dirty[0] & /*error*/
      128)
        inputwrapper_changes.error = /*error*/
        ctx9[7];
      if (dirty[0] & /*required*/
      256)
        inputwrapper_changes.required = /*required*/
        ctx9[8];
      if (dirty[0] & /*labelProps*/
      1024)
        inputwrapper_changes.labelProps = /*labelProps*/
        ctx9[10];
      if (dirty[0] & /*descriptionProps*/
      2048)
        inputwrapper_changes.descriptionProps = /*descriptionProps*/
        ctx9[11];
      if (dirty[0] & /*errorProps*/
      4096)
        inputwrapper_changes.errorProps = /*errorProps*/
        ctx9[12];
      if (dirty[0] & /*id*/
      8192)
        inputwrapper_changes.id = /*id*/
        ctx9[13];
      if (dirty[0] & /*labelElement*/
      16384)
        inputwrapper_changes.labelElement = /*labelElement*/
        ctx9[14];
      if (dirty[0] & /*size*/
      32768)
        inputwrapper_changes.size = /*size*/
        ctx9[15];
      if (dirty[0] & /*required, size, id, placeholder, radius, disabled, $$restProps, use, _invalid, _visible, value, toggleTabIndex, visibilityToggleLabel*/
      20947718 | dirty[1] & /*$$scope*/
      4) {
        inputwrapper_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty[0] & /*element*/
      1) {
        updating_element = true;
        inputwrapper_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      inputwrapper.$set(inputwrapper_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(inputwrapper.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(inputwrapper.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(inputwrapper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment87.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance87($$self, $$props, $$invalidate) {
  let _invalid;
  let _visible;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "label",
    "description",
    "error",
    "required",
    "disabled",
    "labelProps",
    "descriptionProps",
    "errorProps",
    "invalid",
    "id",
    "labelElement",
    "size",
    "radius",
    "value",
    "placeholder",
    "toggleTabIndex",
    "visibilityToggleLabel",
    "visible",
    "onVisibilityChange",
    "defaultVisible"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PasswordInput", slots, ["visibilityToggleIcon"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, label = "", description = null, error = null, required = false, disabled = false, labelProps = {}, descriptionProps = {}, errorProps = {}, invalid = false, id = randomID("password-input"), labelElement = "label", size: size3 = "sm", radius: radius2 = "sm", value = "", placeholder = "", toggleTabIndex = -1, visibilityToggleLabel = void 0, visible: visible2 = void 0, onVisibilityChange = void 0, defaultVisible = void 0 } = $$props;
  let uncontrolledVisible = defaultVisible !== void 0 ? defaultVisible : false;
  const forwardEvents = createEventForwarder(get_current_component());
  const toggleVisibility = () => {
    if (visible2 === void 0) {
      $$invalidate(29, uncontrolledVisible = !_visible);
    }
    onVisibilityChange == null ? void 0 : onVisibilityChange(!_visible);
  };
  function input_value_binding(value$1) {
    value = value$1;
    $$invalidate(1, value);
  }
  function inputwrapper_element_binding(value2) {
    element2 = value2;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(24, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(4, override = $$new_props.override);
    if ("label" in $$new_props)
      $$invalidate(5, label = $$new_props.label);
    if ("description" in $$new_props)
      $$invalidate(6, description = $$new_props.description);
    if ("error" in $$new_props)
      $$invalidate(7, error = $$new_props.error);
    if ("required" in $$new_props)
      $$invalidate(8, required = $$new_props.required);
    if ("disabled" in $$new_props)
      $$invalidate(9, disabled = $$new_props.disabled);
    if ("labelProps" in $$new_props)
      $$invalidate(10, labelProps = $$new_props.labelProps);
    if ("descriptionProps" in $$new_props)
      $$invalidate(11, descriptionProps = $$new_props.descriptionProps);
    if ("errorProps" in $$new_props)
      $$invalidate(12, errorProps = $$new_props.errorProps);
    if ("invalid" in $$new_props)
      $$invalidate(25, invalid = $$new_props.invalid);
    if ("id" in $$new_props)
      $$invalidate(13, id = $$new_props.id);
    if ("labelElement" in $$new_props)
      $$invalidate(14, labelElement = $$new_props.labelElement);
    if ("size" in $$new_props)
      $$invalidate(15, size3 = $$new_props.size);
    if ("radius" in $$new_props)
      $$invalidate(16, radius2 = $$new_props.radius);
    if ("value" in $$new_props)
      $$invalidate(1, value = $$new_props.value);
    if ("placeholder" in $$new_props)
      $$invalidate(17, placeholder = $$new_props.placeholder);
    if ("toggleTabIndex" in $$new_props)
      $$invalidate(18, toggleTabIndex = $$new_props.toggleTabIndex);
    if ("visibilityToggleLabel" in $$new_props)
      $$invalidate(19, visibilityToggleLabel = $$new_props.visibilityToggleLabel);
    if ("visible" in $$new_props)
      $$invalidate(26, visible2 = $$new_props.visible);
    if ("onVisibilityChange" in $$new_props)
      $$invalidate(27, onVisibilityChange = $$new_props.onVisibilityChange);
    if ("defaultVisible" in $$new_props)
      $$invalidate(28, defaultVisible = $$new_props.defaultVisible);
    if ("$$scope" in $$new_props)
      $$invalidate(33, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    get_current_component,
    createEventForwarder,
    useActions,
    randomID,
    Input: Input_default,
    InputWrapper: InputWrapper_default,
    ActionIcon: ActionIcon_default,
    PasswordToggleIcon: PasswordToggleIcon_default,
    getButtonSize,
    getIconSize,
    getRightSectionWidth,
    use,
    element: element2,
    className,
    override,
    label,
    description,
    error,
    required,
    disabled,
    labelProps,
    descriptionProps,
    errorProps,
    invalid,
    id,
    labelElement,
    size: size3,
    radius: radius2,
    value,
    placeholder,
    toggleTabIndex,
    visibilityToggleLabel,
    visible: visible2,
    onVisibilityChange,
    defaultVisible,
    uncontrolledVisible,
    forwardEvents,
    toggleVisibility,
    _visible,
    _invalid
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(4, override = $$new_props.override);
    if ("label" in $$props)
      $$invalidate(5, label = $$new_props.label);
    if ("description" in $$props)
      $$invalidate(6, description = $$new_props.description);
    if ("error" in $$props)
      $$invalidate(7, error = $$new_props.error);
    if ("required" in $$props)
      $$invalidate(8, required = $$new_props.required);
    if ("disabled" in $$props)
      $$invalidate(9, disabled = $$new_props.disabled);
    if ("labelProps" in $$props)
      $$invalidate(10, labelProps = $$new_props.labelProps);
    if ("descriptionProps" in $$props)
      $$invalidate(11, descriptionProps = $$new_props.descriptionProps);
    if ("errorProps" in $$props)
      $$invalidate(12, errorProps = $$new_props.errorProps);
    if ("invalid" in $$props)
      $$invalidate(25, invalid = $$new_props.invalid);
    if ("id" in $$props)
      $$invalidate(13, id = $$new_props.id);
    if ("labelElement" in $$props)
      $$invalidate(14, labelElement = $$new_props.labelElement);
    if ("size" in $$props)
      $$invalidate(15, size3 = $$new_props.size);
    if ("radius" in $$props)
      $$invalidate(16, radius2 = $$new_props.radius);
    if ("value" in $$props)
      $$invalidate(1, value = $$new_props.value);
    if ("placeholder" in $$props)
      $$invalidate(17, placeholder = $$new_props.placeholder);
    if ("toggleTabIndex" in $$props)
      $$invalidate(18, toggleTabIndex = $$new_props.toggleTabIndex);
    if ("visibilityToggleLabel" in $$props)
      $$invalidate(19, visibilityToggleLabel = $$new_props.visibilityToggleLabel);
    if ("visible" in $$props)
      $$invalidate(26, visible2 = $$new_props.visible);
    if ("onVisibilityChange" in $$props)
      $$invalidate(27, onVisibilityChange = $$new_props.onVisibilityChange);
    if ("defaultVisible" in $$props)
      $$invalidate(28, defaultVisible = $$new_props.defaultVisible);
    if ("uncontrolledVisible" in $$props)
      $$invalidate(29, uncontrolledVisible = $$new_props.uncontrolledVisible);
    if ("_visible" in $$props)
      $$invalidate(20, _visible = $$new_props._visible);
    if ("_invalid" in $$props)
      $$invalidate(21, _invalid = $$new_props._invalid);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*invalid, error*/
    33554560) {
      $:
        $$invalidate(21, _invalid = invalid || !!error);
    }
    if ($$self.$$.dirty[0] & /*visible, uncontrolledVisible*/
    603979776) {
      $:
        $$invalidate(20, _visible = visible2 === void 0 ? uncontrolledVisible : visible2);
    }
  };
  return [
    element2,
    value,
    use,
    className,
    override,
    label,
    description,
    error,
    required,
    disabled,
    labelProps,
    descriptionProps,
    errorProps,
    id,
    labelElement,
    size3,
    radius2,
    placeholder,
    toggleTabIndex,
    visibilityToggleLabel,
    _visible,
    _invalid,
    forwardEvents,
    toggleVisibility,
    $$restProps,
    invalid,
    visible2,
    onVisibilityChange,
    defaultVisible,
    uncontrolledVisible,
    slots,
    input_value_binding,
    inputwrapper_element_binding,
    $$scope
  ];
}
var PasswordInput = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance87,
      create_fragment87,
      safe_not_equal,
      {
        use: 2,
        element: 0,
        class: 3,
        override: 4,
        label: 5,
        description: 6,
        error: 7,
        required: 8,
        disabled: 9,
        labelProps: 10,
        descriptionProps: 11,
        errorProps: 12,
        invalid: 25,
        id: 13,
        labelElement: 14,
        size: 15,
        radius: 16,
        value: 1,
        placeholder: 17,
        toggleTabIndex: 18,
        visibilityToggleLabel: 19,
        visible: 26,
        onVisibilityChange: 27,
        defaultVisible: 28
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PasswordInput",
      options,
      id: create_fragment87.name
    });
  }
  get use() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get description() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set description(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelProps() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelProps(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get descriptionProps() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set descriptionProps(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get errorProps() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set errorProps(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelElement() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelElement(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toggleTabIndex() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toggleTabIndex(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visibilityToggleLabel() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visibilityToggleLabel(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onVisibilityChange() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onVisibilityChange(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get defaultVisible() {
    throw new Error("<PasswordInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultVisible(value) {
    throw new Error("<PasswordInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PasswordInput_default = PasswordInput;

// node_modules/@svelteuidev/core/dist/components/Progress/Progress.styles.js
function getCumulativeSections(sections) {
  return sections.reduce((acc, section) => {
    acc.sections.push({ ...section, accumulated: acc.accumulated });
    acc.accumulated += section.value;
    return acc;
  }, { accumulated: 0, sections: [] }).sections;
}
var sizes12 = {
  xs: 3,
  sm: 5,
  md: 8,
  lg: 12,
  xl: 16
};
var stripesAnimation = keyframes({
  from: { backgroundPosition: "0 0" },
  to: { backgroundPosition: "40px 0" }
});
var Progress_styles_default = createStyles((theme4, { color, radius: radius2, size: size3, striped, animate, shade }) => ({
  root: {
    [`${theme4.dark} &`]: {
      backgroundColor: theme4.fn.themeColor("dark", 4)
    },
    position: "relative",
    height: theme4.fn.size({ size: size3, sizes: sizes12 }),
    backgroundColor: theme4.fn.themeColor("gray", 2),
    borderRadius: theme4.fn.radius(radius2),
    overflow: "hidden"
  },
  bar: {
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 0,
    height: "100%",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: theme4.fn.themeColor(color || "blue", shade),
    transition: "width 100ms linear",
    animation: animate ? `${stripesAnimation} 1000ms linear infinite` : "none",
    backgroundSize: "20px 20px",
    backgroundImage: striped ? "linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent)" : "none",
    "&:last-of-type": {
      borderTopRightRadius: theme4.fn.radius(radius2),
      borderBottomRightRadius: theme4.fn.radius(radius2)
    },
    "&:first-of-type": {
      borderTopLeftRadius: theme4.fn.radius(radius2),
      borderBottomLeftRadius: theme4.fn.radius(radius2)
    },
    "@media (prefers-reduced-motion)": {
      transitionDuration: "0ms"
    }
  },
  label: {
    color: theme4.colors.white.value,
    fontSize: theme4.fn.size({ size: size3, sizes: sizes12 }) * 0.65,
    fontWeight: 700,
    userSelect: "none",
    overflow: "hidden",
    whiteSpace: "nowrap"
  }
}));

// node_modules/@svelteuidev/core/dist/components/Progress/Progress.svelte
var file40 = "node_modules/@svelteuidev/core/dist/components/Progress/Progress.svelte";
var get_label_slot_changes2 = (dirty) => ({});
var get_label_slot_context2 = (ctx8) => ({});
function get_each_context5(ctx8, list, i2) {
  const child_ctx = ctx8.slice();
  child_ctx[28] = list[i2];
  return child_ctx;
}
function create_else_block14(ctx8) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let div_aria_valuemax_value;
  let div_aria_valuemin_value;
  let div_style_value;
  let current;
  const if_block_creators = [create_if_block_212, create_if_block_35];
  const if_blocks = [];
  function select_block_type_1(ctx9, dirty) {
    if (
      /*$$slots*/
      ctx9[17].label
    )
      return 0;
    if (
      /*label*/
      ctx9[5]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx8, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx8);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        role: true,
        "aria-valuemax": true,
        "aria-valuemin": true,
        "aria-valuenow": true,
        "aria-label": true,
        style: true
      });
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*classes*/
      ctx8[12].bar);
      attr_dev(div, "role", "progressbar");
      attr_dev(div, "aria-valuemax", div_aria_valuemax_value = 100);
      attr_dev(div, "aria-valuemin", div_aria_valuemin_value = 0);
      attr_dev(
        div,
        "aria-valuenow",
        /*value*/
        ctx8[4]
      );
      attr_dev(
        div,
        "aria-label",
        /*ariaLabel*/
        ctx8[8]
      );
      attr_dev(div, "style", div_style_value = `width:${/*tween*/
      ctx8[9] ? (
        /*$progress*/
        ctx8[15]
      ) : (
        /*value*/
        ctx8[4]
      )}%`);
      add_location(div, file40, 39, 2, 1509);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx9, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx9, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx9);
            if_block.c();
          } else {
            if_block.p(ctx9, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, null);
        } else {
          if_block = null;
        }
      }
      if (!current || dirty & /*classes*/
      4096 && div_class_value !== (div_class_value = /*classes*/
      ctx9[12].bar)) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & /*value*/
      16) {
        attr_dev(
          div,
          "aria-valuenow",
          /*value*/
          ctx9[4]
        );
      }
      if (!current || dirty & /*ariaLabel*/
      256) {
        attr_dev(
          div,
          "aria-label",
          /*ariaLabel*/
          ctx9[8]
        );
      }
      if (!current || dirty & /*tween, $progress, value*/
      33296 && div_style_value !== (div_style_value = `width:${/*tween*/
      ctx9[9] ? (
        /*$progress*/
        ctx9[15]
      ) : (
        /*value*/
        ctx9[4]
      )}%`)) {
        attr_dev(div, "style", div_style_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block14.name,
    type: "else",
    source: "(39:1) {:else}",
    ctx: ctx8
  });
  return block;
}
function create_if_block34(ctx8) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(getCumulativeSections(
    /*sections*/
    ctx8[6]
  ));
  const get_key = (ctx9) => (
    /*section*/
    ctx9[28]
  );
  validate_each_keys(ctx8, each_value, get_each_context5, get_key);
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context5(ctx8, each_value, i2);
    let key3 = get_key(child_ctx);
    each_1_lookup.set(key3, each_blocks[i2] = create_each_block5(key3, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*classes, tween, $progress, sections, theme, shade*/
      38592) {
        each_value = ensure_array_like_dev(getCumulativeSections(
          /*sections*/
          ctx9[6]
        ));
        group_outros();
        validate_each_keys(ctx9, each_value, get_each_context5, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx9, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block5, each_1_anchor, get_each_context5);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block34.name,
    type: "if",
    source: "(24:1) {#if segments}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_35(ctx8) {
  let text_1;
  let current;
  text_1 = new Text_default({
    props: {
      class: (
        /*classes*/
        ctx8[12].label
      ),
      $$slots: { default: [create_default_slot_34] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(text_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(text_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(text_1, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const text_1_changes = {};
      if (dirty & /*classes*/
      4096)
        text_1_changes.class = /*classes*/
        ctx9[12].label;
      if (dirty & /*$$scope, label*/
      67108896) {
        text_1_changes.$$scope = { dirty, ctx: ctx9 };
      }
      text_1.$set(text_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(text_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_35.name,
    type: "if",
    source: "(51:19) ",
    ctx: ctx8
  });
  return block;
}
function create_if_block_212(ctx8) {
  let current;
  const label_slot_template = (
    /*#slots*/
    ctx8[24].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[26],
    get_label_slot_context2
  );
  const block = {
    c: function create() {
      if (label_slot)
        label_slot.c();
    },
    l: function claim(nodes) {
      if (label_slot)
        label_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (label_slot) {
        label_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty & /*$$scope*/
        67108864)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[26],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[26]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx9[26],
              dirty,
              get_label_slot_changes2
            ),
            get_label_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (label_slot)
        label_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_212.name,
    type: "if",
    source: "(49:3) {#if $$slots.label}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_34(ctx8) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*label*/
        ctx8[5]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*label*/
        ctx8[5]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*label*/
      32)
        set_data_dev(
          t,
          /*label*/
          ctx9[5]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_34.name,
    type: "slot",
    source: "(52:4) <Text class={classes.label}>",
    ctx: ctx8
  });
  return block;
}
function create_if_block_119(ctx8) {
  let text_1;
  let current;
  text_1 = new Text_default({
    props: {
      class: (
        /*classes*/
        ctx8[12].label
      ),
      $$slots: { default: [create_default_slot_29] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(text_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(text_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(text_1, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const text_1_changes = {};
      if (dirty & /*classes*/
      4096)
        text_1_changes.class = /*classes*/
        ctx9[12].label;
      if (dirty & /*$$scope, sections*/
      67108928) {
        text_1_changes.$$scope = { dirty, ctx: ctx9 };
      }
      text_1.$set(text_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(text_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_119.name,
    type: "if",
    source: "(34:4) {#if section.label}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_29(ctx8) {
  let t_value = (
    /*section*/
    ctx8[28].label + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*sections*/
      64 && t_value !== (t_value = /*section*/
      ctx9[28].label + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_29.name,
    type: "slot",
    source: "(35:5) <Text class={classes.label}>",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_118(ctx8) {
  let t;
  let current;
  let if_block = (
    /*section*/
    ctx8[28].label && create_if_block_119(ctx8)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      t = space();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      t = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (
        /*section*/
        ctx9[28].label
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
          if (dirty & /*sections*/
          64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_119(ctx9);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_118.name,
    type: "slot",
    source: "(26:3) <Box     class={classes.bar}     css={{      width: `${tween ? $progress : section.value}% !important`,      left: `${section.accumulated}% !important`,      backgroundColor: `${theme.fn.themeColor(section.color, shade)} !important`     }}    >",
    ctx: ctx8
  });
  return block;
}
function create_each_block5(key_1, ctx8) {
  let first;
  let box;
  let current;
  box = new Box_default({
    props: {
      class: (
        /*classes*/
        ctx8[12].bar
      ),
      css: {
        width: `${/*tween*/
        ctx8[9] ? (
          /*$progress*/
          ctx8[15]
        ) : (
          /*section*/
          ctx8[28].value
        )}% !important`,
        left: `${/*section*/
        ctx8[28].accumulated}% !important`,
        backgroundColor: `${/*theme*/
        ctx8[10].fn.themeColor(
          /*section*/
          ctx8[28].color,
          /*shade*/
          ctx8[7]
        )} !important`
      },
      $$slots: { default: [create_default_slot_118] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(box.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(box.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx8 = new_ctx;
      const box_changes = {};
      if (dirty & /*classes*/
      4096)
        box_changes.class = /*classes*/
        ctx8[12].bar;
      if (dirty & /*tween, $progress, sections, theme, shade*/
      34496)
        box_changes.css = {
          width: `${/*tween*/
          ctx8[9] ? (
            /*$progress*/
            ctx8[15]
          ) : (
            /*section*/
            ctx8[28].value
          )}% !important`,
          left: `${/*section*/
          ctx8[28].accumulated}% !important`,
          backgroundColor: `${/*theme*/
          ctx8[10].fn.themeColor(
            /*section*/
            ctx8[28].color,
            /*shade*/
            ctx8[7]
          )} !important`
        };
      if (dirty & /*$$scope, classes, sections*/
      67113024) {
        box_changes.$$scope = { dirty, ctx: ctx8 };
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block5.name,
    type: "each",
    source: "(25:2) {#each getCumulativeSections(sections) as section (section)}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot65(ctx8) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block34, create_else_block14];
  const if_blocks = [];
  function select_block_type(ctx9, dirty) {
    if (
      /*segments*/
      ctx9[14]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx8, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx8);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx9, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx9, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx9);
          if_block.c();
        } else {
          if_block.p(ctx9, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot65.name,
    type: "slot",
    source: "(23:0) <Box bind:element {use} class={cx(className, classes.root, getStyles({ css: override }))}>",
    ctx: ctx8
  });
  return block;
}
function create_fragment88(ctx8) {
  let box;
  let updating_element;
  let current;
  function box_element_binding(value) {
    ctx8[25](value);
  }
  let box_props = {
    use: (
      /*use*/
      ctx8[1]
    ),
    class: (
      /*cx*/
      ctx8[13](
        /*className*/
        ctx8[2],
        /*classes*/
        ctx8[12].root,
        /*getStyles*/
        ctx8[11]({ css: (
          /*override*/
          ctx8[3]
        ) })
      )
    ),
    $$slots: { default: [create_default_slot65] },
    $$scope: { ctx: ctx8 }
  };
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = {};
      if (dirty & /*use*/
      2)
        box_changes.use = /*use*/
        ctx9[1];
      if (dirty & /*cx, className, classes, getStyles, override*/
      14348)
        box_changes.class = /*cx*/
        ctx9[13](
          /*className*/
          ctx9[2],
          /*classes*/
          ctx9[12].root,
          /*getStyles*/
          ctx9[11]({ css: (
            /*override*/
            ctx9[3]
          ) })
        );
      if (dirty & /*$$scope, sections, classes, tween, $progress, theme, shade, segments, value, ariaLabel, $$slots, label*/
      67295216) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment88.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance88($$self, $$props, $$invalidate) {
  let segments;
  let cx2;
  let classes;
  let getStyles;
  let theme4;
  let $progress;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Progress", slots, ["label"]);
  const $$slots = compute_slots(slots);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, value = void 0, color = void 0, size: size3 = "md", radius: radius2 = "sm", striped = false, animate = false, label = "", sections = void 0, shade = 6, ariaLabel = randomID(), tween = false, tweenOptions = {} } = $$props;
  const defaultTweenOptions = {
    delay: 0,
    duration: 400,
    easing: cubicOut
  };
  const progress = tweened(void 0, { ...defaultTweenOptions, ...tweenOptions });
  validate_store(progress, "progress");
  component_subscribe($$self, progress, (value2) => $$invalidate(15, $progress = value2));
  const writable_props = [
    "use",
    "element",
    "class",
    "override",
    "value",
    "color",
    "size",
    "radius",
    "striped",
    "animate",
    "label",
    "sections",
    "shade",
    "ariaLabel",
    "tween",
    "tweenOptions"
  ];
  Object.keys($$props).forEach((key3) => {
    if (!~writable_props.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<Progress> was created with unknown prop '${key3}'`);
  });
  function box_element_binding(value2) {
    element2 = value2;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$props2) => {
    if ("use" in $$props2)
      $$invalidate(1, use = $$props2.use);
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("class" in $$props2)
      $$invalidate(2, className = $$props2.class);
    if ("override" in $$props2)
      $$invalidate(3, override = $$props2.override);
    if ("value" in $$props2)
      $$invalidate(4, value = $$props2.value);
    if ("color" in $$props2)
      $$invalidate(18, color = $$props2.color);
    if ("size" in $$props2)
      $$invalidate(19, size3 = $$props2.size);
    if ("radius" in $$props2)
      $$invalidate(20, radius2 = $$props2.radius);
    if ("striped" in $$props2)
      $$invalidate(21, striped = $$props2.striped);
    if ("animate" in $$props2)
      $$invalidate(22, animate = $$props2.animate);
    if ("label" in $$props2)
      $$invalidate(5, label = $$props2.label);
    if ("sections" in $$props2)
      $$invalidate(6, sections = $$props2.sections);
    if ("shade" in $$props2)
      $$invalidate(7, shade = $$props2.shade);
    if ("ariaLabel" in $$props2)
      $$invalidate(8, ariaLabel = $$props2.ariaLabel);
    if ("tween" in $$props2)
      $$invalidate(9, tween = $$props2.tween);
    if ("tweenOptions" in $$props2)
      $$invalidate(23, tweenOptions = $$props2.tweenOptions);
    if ("$$scope" in $$props2)
      $$invalidate(26, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: Progress_styles_default,
    getCumulativeSections,
    tweened,
    Box: Box_default,
    Text: Text_default,
    randomID,
    cubicOut,
    use,
    element: element2,
    className,
    override,
    value,
    color,
    size: size3,
    radius: radius2,
    striped,
    animate,
    label,
    sections,
    shade,
    ariaLabel,
    tween,
    tweenOptions,
    defaultTweenOptions,
    progress,
    theme: theme4,
    getStyles,
    classes,
    cx: cx2,
    segments,
    $progress
  });
  $$self.$inject_state = ($$props2) => {
    if ("use" in $$props2)
      $$invalidate(1, use = $$props2.use);
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("className" in $$props2)
      $$invalidate(2, className = $$props2.className);
    if ("override" in $$props2)
      $$invalidate(3, override = $$props2.override);
    if ("value" in $$props2)
      $$invalidate(4, value = $$props2.value);
    if ("color" in $$props2)
      $$invalidate(18, color = $$props2.color);
    if ("size" in $$props2)
      $$invalidate(19, size3 = $$props2.size);
    if ("radius" in $$props2)
      $$invalidate(20, radius2 = $$props2.radius);
    if ("striped" in $$props2)
      $$invalidate(21, striped = $$props2.striped);
    if ("animate" in $$props2)
      $$invalidate(22, animate = $$props2.animate);
    if ("label" in $$props2)
      $$invalidate(5, label = $$props2.label);
    if ("sections" in $$props2)
      $$invalidate(6, sections = $$props2.sections);
    if ("shade" in $$props2)
      $$invalidate(7, shade = $$props2.shade);
    if ("ariaLabel" in $$props2)
      $$invalidate(8, ariaLabel = $$props2.ariaLabel);
    if ("tween" in $$props2)
      $$invalidate(9, tween = $$props2.tween);
    if ("tweenOptions" in $$props2)
      $$invalidate(23, tweenOptions = $$props2.tweenOptions);
    if ("theme" in $$props2)
      $$invalidate(10, theme4 = $$props2.theme);
    if ("getStyles" in $$props2)
      $$invalidate(11, getStyles = $$props2.getStyles);
    if ("classes" in $$props2)
      $$invalidate(12, classes = $$props2.classes);
    if ("cx" in $$props2)
      $$invalidate(13, cx2 = $$props2.cx);
    if ("segments" in $$props2)
      $$invalidate(14, segments = $$props2.segments);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*sections*/
    64) {
      $:
        $$invalidate(14, segments = Array.isArray(sections));
    }
    if ($$self.$$.dirty & /*value*/
    16) {
      $:
        progress.set(value);
    }
    if ($$self.$$.dirty & /*animate, color, radius, size, shade, striped*/
    8126592) {
      $:
        $$invalidate(
          13,
          { cx: cx2, classes, getStyles, theme: theme4 } = Progress_styles_default(
            {
              animate,
              color,
              radius: radius2,
              size: size3,
              shade,
              striped: striped || animate
            },
            { name: "Progress" }
          ),
          cx2,
          ($$invalidate(12, classes), $$invalidate(22, animate), $$invalidate(18, color), $$invalidate(20, radius2), $$invalidate(19, size3), $$invalidate(7, shade), $$invalidate(21, striped)),
          ($$invalidate(11, getStyles), $$invalidate(22, animate), $$invalidate(18, color), $$invalidate(20, radius2), $$invalidate(19, size3), $$invalidate(7, shade), $$invalidate(21, striped)),
          ($$invalidate(10, theme4), $$invalidate(22, animate), $$invalidate(18, color), $$invalidate(20, radius2), $$invalidate(19, size3), $$invalidate(7, shade), $$invalidate(21, striped))
        );
    }
  };
  return [
    element2,
    use,
    className,
    override,
    value,
    label,
    sections,
    shade,
    ariaLabel,
    tween,
    theme4,
    getStyles,
    classes,
    cx2,
    segments,
    $progress,
    progress,
    $$slots,
    color,
    size3,
    radius2,
    striped,
    animate,
    tweenOptions,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Progress = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance88, create_fragment88, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      value: 4,
      color: 18,
      size: 19,
      radius: 20,
      striped: 21,
      animate: 22,
      label: 5,
      sections: 6,
      shade: 7,
      ariaLabel: 8,
      tween: 9,
      tweenOptions: 23
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Progress",
      options,
      id: create_fragment88.name
    });
  }
  get use() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get striped() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set striped(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animate() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animate(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sections() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sections(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shade() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shade(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaLabel() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabel(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tween() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tween(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tweenOptions() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tweenOptions(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Progress_default = Progress;

// node_modules/@svelteuidev/core/dist/components/Radio/Radio.styles.js
var sizes13 = {
  xs: 16,
  sm: 20,
  md: 24,
  lg: 30,
  xl: 36
};
var innerSizes = {
  xs: 6,
  sm: 8,
  md: 10,
  lg: 14,
  xl: 16
};
var padding2 = {
  xs: 5,
  sm: 8,
  md: 10,
  lg: 11,
  xl: 12
};
var Radio_styles_default = createStyles((theme4, { color, size: size3, labelDirection, error }, getRef) => {
  return {
    root: {
      display: "flex"
    },
    container: {
      display: "flex",
      flexDirection: labelDirection === "left" ? "row" : "row-reverse",
      alignItems: "center"
    },
    inputContainer: {
      position: "relative"
    },
    input: {
      border: `1px solid ${error ? theme4.fn.variant({ variant: "filled", color: "red" }).background : theme4.fn.themeColor("gray", 4)}`,
      position: "relative",
      appearance: "none",
      width: theme4.fn.size({ sizes: sizes13, size: size3 }),
      height: theme4.fn.size({ sizes: sizes13, size: size3 }),
      borderRadius: theme4.fn.size({ sizes: sizes13, size: size3 }),
      margin: 0,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      cursor: "pointer",
      backgroundColor: theme4.colors.white.value,
      darkMode: {
        backgroundColor: theme4.fn.themeColor("dark", 6),
        border: `1px solid ${error ? theme4.fn.variant({ variant: "filled", color: "red" }).background : theme4.fn.themeColor("dark", 4)}`
      },
      "&:checked": {
        background: theme4.fn.variant({ variant: "filled", color }).background[1],
        borderColor: theme4.fn.variant({ variant: "filled", color }).background[1],
        [`& + .${getRef("inner")}`]: {
          opacity: 1,
          transform: "scale(1)"
        }
      },
      "&.disabled": {
        backgroundColor: theme4.fn.themeColor("gray", 1),
        borderColor: theme4.fn.themeColor("gray", 4),
        darkMode: {
          backgroundColor: theme4.fn.themeColor("dark", 5),
          borderColor: theme4.fn.themeColor("dark", 5)
        },
        [`& + .${getRef("inner")}`]: {
          color: theme4.fn.themeColor("gray", 4),
          darkMode: {
            color: theme4.fn.themeColor("dark", 6)
          }
        }
      }
    },
    inner: {
      ref: getRef("inner"),
      backgroundColor: theme4.colors.white.value,
      borderRadius: "100%",
      opacity: 0,
      transform: "scale(0.75) translateY(2px)",
      pointerEvents: "none",
      width: theme4.fn.size({ sizes: innerSizes, size: size3 }),
      height: theme4.fn.size({ sizes: innerSizes, size: size3 }),
      position: "absolute",
      top: `calc(50% - ${theme4.fn.size({ sizes: innerSizes, size: size3 }) / 2}px)`,
      left: `calc(50% - ${theme4.fn.size({ sizes: innerSizes, size: size3 }) / 2}px)`
    },
    label: {
      fontSize: theme4.fontSizes[size3].value,
      marginLeft: labelDirection == "left" ? `${theme4.fn.size({ size: size3, sizes: padding2 })}px` : 0,
      marginRight: labelDirection == "right" ? `${theme4.fn.size({ size: size3, sizes: padding2 })}px` : 0,
      "&.disabled": {
        color: theme4.fn.themeColor("gray", 5)
      }
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Radio/Radio.svelte
var file41 = "node_modules/@svelteuidev/core/dist/components/Radio/Radio.svelte";
function create_else_block15(ctx8) {
  let input;
  let input_class_value;
  let useActions_action;
  let forwardEvents_action;
  let mounted;
  let dispose;
  let input_levels = [
    {
      class: input_class_value = /*classes*/
      ctx8[12].input
    },
    { type: "radio" },
    { checked: (
      /*checked*/
      ctx8[1]
    ) },
    { name: (
      /*name*/
      ctx8[10]
    ) },
    { disabled: (
      /*disabled*/
      ctx8[7]
    ) },
    { value: (
      /*value*/
      ctx8[8]
    ) },
    { id: (
      /*id*/
      ctx8[6]
    ) },
    /*$$restProps*/
    ctx8[16]
  ];
  let input_data = {};
  for (let i2 = 0; i2 < input_levels.length; i2 += 1) {
    input_data = assign(input_data, input_levels[i2]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        class: true,
        type: true,
        name: true,
        id: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      toggle_class(
        input,
        "disabled",
        /*disabled*/
        ctx8[7]
      );
      add_location(input, file41, 50, 4, 1543);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*onChange*/
            ctx8[15],
            false,
            false,
            false,
            false
          ),
          action_destroyer(useActions_action = useActions.call(
            null,
            input,
            /*use*/
            ctx8[3]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx8[14].call(null, input))
        ];
        mounted = true;
      }
    },
    p: function update(ctx9, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty & /*classes*/
        4096 && input_class_value !== (input_class_value = /*classes*/
        ctx9[12].input) && { class: input_class_value },
        { type: "radio" },
        dirty & /*checked*/
        2 && { checked: (
          /*checked*/
          ctx9[1]
        ) },
        dirty & /*name*/
        1024 && { name: (
          /*name*/
          ctx9[10]
        ) },
        dirty & /*disabled*/
        128 && { disabled: (
          /*disabled*/
          ctx9[7]
        ) },
        dirty & /*value*/
        256 && { value: (
          /*value*/
          ctx9[8]
        ) },
        dirty & /*id*/
        64 && { id: (
          /*id*/
          ctx9[6]
        ) },
        dirty & /*$$restProps*/
        65536 && /*$$restProps*/
        ctx9[16]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      8)
        useActions_action.update.call(
          null,
          /*use*/
          ctx9[3]
        );
      toggle_class(
        input,
        "disabled",
        /*disabled*/
        ctx9[7]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block15.name,
    type: "else",
    source: "(50:3) {:else}",
    ctx: ctx8
  });
  return block;
}
function create_if_block35(ctx8) {
  let input;
  let input_class_value;
  let useActions_action;
  let forwardEvents_action;
  let binding_group;
  let mounted;
  let dispose;
  let input_levels = [
    {
      class: input_class_value = /*classes*/
      ctx8[12].input
    },
    { type: "radio" },
    { name: (
      /*name*/
      ctx8[10]
    ) },
    { disabled: (
      /*disabled*/
      ctx8[7]
    ) },
    { __value: (
      /*value*/
      ctx8[8]
    ) },
    { id: (
      /*id*/
      ctx8[6]
    ) },
    /*$$restProps*/
    ctx8[16]
  ];
  let input_data = {};
  for (let i2 = 0; i2 < input_levels.length; i2 += 1) {
    input_data = assign(input_data, input_levels[i2]);
  }
  binding_group = init_binding_group(
    /*$$binding_groups*/
    ctx8[23][0]
  );
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        class: true,
        type: true,
        name: true,
        id: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      toggle_class(
        input,
        "disabled",
        /*disabled*/
        ctx8[7]
      );
      add_location(input, file41, 36, 4, 1311);
      binding_group.p(input);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      input.checked = input.__value === /*group*/
      ctx8[2];
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx8[22]
          ),
          action_destroyer(useActions_action = useActions.call(
            null,
            input,
            /*use*/
            ctx8[3]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx8[14].call(null, input))
        ];
        mounted = true;
      }
    },
    p: function update(ctx9, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty & /*classes*/
        4096 && input_class_value !== (input_class_value = /*classes*/
        ctx9[12].input) && { class: input_class_value },
        { type: "radio" },
        dirty & /*name*/
        1024 && { name: (
          /*name*/
          ctx9[10]
        ) },
        dirty & /*disabled*/
        128 && { disabled: (
          /*disabled*/
          ctx9[7]
        ) },
        dirty & /*value*/
        256 && { __value: (
          /*value*/
          ctx9[8]
        ) },
        dirty & /*id*/
        64 && { id: (
          /*id*/
          ctx9[6]
        ) },
        dirty & /*$$restProps*/
        65536 && /*$$restProps*/
        ctx9[16]
      ]));
      if (dirty & /*group*/
      4) {
        input.checked = input.__value === /*group*/
        ctx9[2];
      }
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      8)
        useActions_action.update.call(
          null,
          /*use*/
          ctx9[3]
        );
      toggle_class(
        input,
        "disabled",
        /*disabled*/
        ctx9[7]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      binding_group.r();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block35.name,
    type: "if",
    source: "(36:3) {#if group}",
    ctx: ctx8
  });
  return block;
}
function fallback_block21(ctx8) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*label*/
        ctx8[9]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*label*/
        ctx8[9]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*label*/
      512)
        set_data_dev(
          t,
          /*label*/
          ctx9[9]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block21.name,
    type: "fallback",
    source: "(69:9) {label}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot66(ctx8) {
  let div2;
  let div1;
  let t0;
  let div0;
  let div0_class_value;
  let div1_class_value;
  let t1;
  let label_1;
  let label_1_class_value;
  let div2_class_value;
  let current;
  function select_block_type(ctx9, dirty) {
    if (
      /*group*/
      ctx9[2]
    )
      return create_if_block35;
    return create_else_block15;
  }
  let current_block_type = select_block_type(ctx8, -1);
  let if_block = current_block_type(ctx8);
  const default_slot_template = (
    /*#slots*/
    ctx8[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[25],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block21(ctx8);
  const block = {
    c: function create() {
      div2 = element("div");
      div1 = element("div");
      if_block.c();
      t0 = space();
      div0 = element("div");
      t1 = space();
      label_1 = element("label");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if_block.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true, "aria-hidden": true });
      children(div0).forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      label_1 = claim_element(div2_nodes, "LABEL", { class: true, for: true });
      var label_1_nodes = children(label_1);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(label_1_nodes);
      label_1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = /*classes*/
      ctx8[12].inner);
      attr_dev(div0, "aria-hidden", "");
      add_location(div0, file41, 65, 3, 1797);
      attr_dev(div1, "class", div1_class_value = /*classes*/
      ctx8[12].inputContainer);
      add_location(div1, file41, 34, 2, 1255);
      attr_dev(label_1, "class", label_1_class_value = /*classes*/
      ctx8[12].label);
      attr_dev(
        label_1,
        "for",
        /*id*/
        ctx8[6]
      );
      toggle_class(
        label_1,
        "disabled",
        /*disabled*/
        ctx8[7]
      );
      add_location(label_1, file41, 67, 2, 1850);
      attr_dev(div2, "class", div2_class_value = /*classes*/
      ctx8[12].container);
      add_location(div2, file41, 33, 1, 1221);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div1);
      if_block.m(div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, label_1);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(label_1, null);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx9, dirty)) && if_block) {
        if_block.p(ctx9, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx9);
        if (if_block) {
          if_block.c();
          if_block.m(div1, t0);
        }
      }
      if (!current || dirty & /*classes*/
      4096 && div0_class_value !== (div0_class_value = /*classes*/
      ctx9[12].inner)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty & /*classes*/
      4096 && div1_class_value !== (div1_class_value = /*classes*/
      ctx9[12].inputContainer)) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[25]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[25],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*label*/
        512)) {
          default_slot_or_fallback.p(ctx9, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*classes*/
      4096 && label_1_class_value !== (label_1_class_value = /*classes*/
      ctx9[12].label)) {
        attr_dev(label_1, "class", label_1_class_value);
      }
      if (!current || dirty & /*id*/
      64) {
        attr_dev(
          label_1,
          "for",
          /*id*/
          ctx9[6]
        );
      }
      if (!current || dirty & /*classes, disabled*/
      4224) {
        toggle_class(
          label_1,
          "disabled",
          /*disabled*/
          ctx9[7]
        );
      }
      if (!current || dirty & /*classes*/
      4096 && div2_class_value !== (div2_class_value = /*classes*/
      ctx9[12].container)) {
        attr_dev(div2, "class", div2_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if_block.d();
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot66.name,
    type: "slot",
    source: "(33:0) <Box bind:element class={cx(className, classes.root, getStyles({ css: override }))}>",
    ctx: ctx8
  });
  return block;
}
function create_fragment89(ctx8) {
  let box;
  let updating_element;
  let current;
  function box_element_binding(value) {
    ctx8[24](value);
  }
  let box_props = {
    class: (
      /*cx*/
      ctx8[13](
        /*className*/
        ctx8[4],
        /*classes*/
        ctx8[12].root,
        /*getStyles*/
        ctx8[11]({ css: (
          /*override*/
          ctx8[5]
        ) })
      )
    ),
    $$slots: { default: [create_default_slot66] },
    $$scope: { ctx: ctx8 }
  };
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = {};
      if (dirty & /*cx, className, classes, getStyles, override*/
      14384)
        box_changes.class = /*cx*/
        ctx9[13](
          /*className*/
          ctx9[4],
          /*classes*/
          ctx9[12].root,
          /*getStyles*/
          ctx9[11]({ css: (
            /*override*/
            ctx9[5]
          ) })
        );
      if (dirty & /*$$scope, classes, id, disabled, label, name, value, $$restProps, group, use, checked*/
      33626062) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment89.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
var ctx5 = "Radio";
function instance89($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "color",
    "id",
    "disabled",
    "value",
    "checked",
    "label",
    "error",
    "labelDirection",
    "size",
    "name",
    "group"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Radio", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, color = "blue", id = randomID(), disabled = false, value = void 0, checked = false, label = "", error = false, labelDirection = "left", size: size3 = "sm", name = "", group = void 0 } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  function onChange(e) {
    $$invalidate(1, checked = e.target.checked);
  }
  const $$binding_groups = [[]];
  function input_change_handler() {
    group = this.__value;
    $$invalidate(2, group);
  }
  function box_element_binding(value2) {
    element2 = value2;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(3, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(5, override = $$new_props.override);
    if ("color" in $$new_props)
      $$invalidate(17, color = $$new_props.color);
    if ("id" in $$new_props)
      $$invalidate(6, id = $$new_props.id);
    if ("disabled" in $$new_props)
      $$invalidate(7, disabled = $$new_props.disabled);
    if ("value" in $$new_props)
      $$invalidate(8, value = $$new_props.value);
    if ("checked" in $$new_props)
      $$invalidate(1, checked = $$new_props.checked);
    if ("label" in $$new_props)
      $$invalidate(9, label = $$new_props.label);
    if ("error" in $$new_props)
      $$invalidate(18, error = $$new_props.error);
    if ("labelDirection" in $$new_props)
      $$invalidate(19, labelDirection = $$new_props.labelDirection);
    if ("size" in $$new_props)
      $$invalidate(20, size3 = $$new_props.size);
    if ("name" in $$new_props)
      $$invalidate(10, name = $$new_props.name);
    if ("group" in $$new_props)
      $$invalidate(2, group = $$new_props.group);
    if ("$$scope" in $$new_props)
      $$invalidate(25, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    ctx: ctx5,
    get_current_component,
    createEventForwarder,
    useActions,
    randomID,
    Box: Box_default,
    useStyles: Radio_styles_default,
    use,
    element: element2,
    className,
    override,
    color,
    id,
    disabled,
    value,
    checked,
    label,
    error,
    labelDirection,
    size: size3,
    name,
    group,
    forwardEvents,
    onChange,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(3, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(5, override = $$new_props.override);
    if ("color" in $$props)
      $$invalidate(17, color = $$new_props.color);
    if ("id" in $$props)
      $$invalidate(6, id = $$new_props.id);
    if ("disabled" in $$props)
      $$invalidate(7, disabled = $$new_props.disabled);
    if ("value" in $$props)
      $$invalidate(8, value = $$new_props.value);
    if ("checked" in $$props)
      $$invalidate(1, checked = $$new_props.checked);
    if ("label" in $$props)
      $$invalidate(9, label = $$new_props.label);
    if ("error" in $$props)
      $$invalidate(18, error = $$new_props.error);
    if ("labelDirection" in $$props)
      $$invalidate(19, labelDirection = $$new_props.labelDirection);
    if ("size" in $$props)
      $$invalidate(20, size3 = $$new_props.size);
    if ("name" in $$props)
      $$invalidate(10, name = $$new_props.name);
    if ("group" in $$props)
      $$invalidate(2, group = $$new_props.group);
    if ("getStyles" in $$props)
      $$invalidate(11, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(12, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(13, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*color, size, labelDirection, error*/
    1966080) {
      $:
        $$invalidate(13, { cx: cx2, classes, getStyles } = Radio_styles_default({ color, size: size3, labelDirection, error }, { name: "Radio" }), cx2, ($$invalidate(12, classes), $$invalidate(17, color), $$invalidate(20, size3), $$invalidate(19, labelDirection), $$invalidate(18, error)), ($$invalidate(11, getStyles), $$invalidate(17, color), $$invalidate(20, size3), $$invalidate(19, labelDirection), $$invalidate(18, error)));
    }
  };
  return [
    element2,
    checked,
    group,
    use,
    className,
    override,
    id,
    disabled,
    value,
    label,
    name,
    getStyles,
    classes,
    cx2,
    forwardEvents,
    onChange,
    $$restProps,
    color,
    error,
    labelDirection,
    size3,
    slots,
    input_change_handler,
    $$binding_groups,
    box_element_binding,
    $$scope
  ];
}
var Radio = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance89, create_fragment89, safe_not_equal, {
      use: 3,
      element: 0,
      class: 4,
      override: 5,
      color: 17,
      id: 6,
      disabled: 7,
      value: 8,
      checked: 1,
      label: 9,
      error: 18,
      labelDirection: 19,
      size: 20,
      name: 10,
      group: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Radio",
      options,
      id: create_fragment89.name
    });
  }
  get use() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get error() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set error(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelDirection() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelDirection(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get group() {
    throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Radio_default = Radio;

// node_modules/@svelteuidev/core/dist/components/Radio/RadioGroup/RadioGroup.svelte
function get_each_context6(ctx8, list, i2) {
  const child_ctx = ctx8.slice();
  child_ctx[26] = list[i2];
  return child_ctx;
}
function create_else_block16(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[24],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16777216)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[24],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[24]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[24],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block16.name,
    type: "else",
    source: "(50:2) {:else}",
    ctx: ctx8
  });
  return block;
}
function create_if_block36(ctx8) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*items*/
    ctx8[5]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block6(get_each_context6(ctx8, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  const block = {
    c: function create() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*use, items, labelDirection, radius, size, color, name, disabled, group, onChanged*/
      206693) {
        each_value = ensure_array_like_dev(
          /*items*/
          ctx9[5]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context6(ctx9, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block6(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block36.name,
    type: "if",
    source: "(34:2) {#if items && items.length > 0}",
    ctx: ctx8
  });
  return block;
}
function create_each_block6(ctx8) {
  let radio;
  let updating_group;
  let current;
  function radio_group_binding(value) {
    ctx8[21](value);
  }
  function change_handler(...args) {
    return (
      /*change_handler*/
      ctx8[22](
        /*item*/
        ctx8[26],
        ...args
      )
    );
  }
  let radio_props = {
    use: (
      /*use*/
      ctx8[2]
    ),
    label: (
      /*item*/
      ctx8[26].label
    ),
    value: (
      /*item*/
      ctx8[26].value
    ),
    labelDirection: (
      /*labelDirection*/
      ctx8[13]
    ),
    radius: (
      /*radius*/
      ctx8[10]
    ),
    size: (
      /*size*/
      ctx8[9]
    ),
    color: (
      /*color*/
      ctx8[6]
    ),
    name: (
      /*name*/
      ctx8[16]
    ),
    disabled: (
      /*disabled*/
      ctx8[8]
    )
  };
  if (
    /*group*/
    ctx8[0] !== void 0
  ) {
    radio_props.group = /*group*/
    ctx8[0];
  }
  radio = new Radio_default({ props: radio_props, $$inline: true });
  binding_callbacks.push(() => bind(radio, "group", radio_group_binding));
  radio.$on("change", change_handler);
  const block = {
    c: function create() {
      create_component(radio.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(radio.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(radio, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx8 = new_ctx;
      const radio_changes = {};
      if (dirty & /*use*/
      4)
        radio_changes.use = /*use*/
        ctx8[2];
      if (dirty & /*items*/
      32)
        radio_changes.label = /*item*/
        ctx8[26].label;
      if (dirty & /*items*/
      32)
        radio_changes.value = /*item*/
        ctx8[26].value;
      if (dirty & /*labelDirection*/
      8192)
        radio_changes.labelDirection = /*labelDirection*/
        ctx8[13];
      if (dirty & /*radius*/
      1024)
        radio_changes.radius = /*radius*/
        ctx8[10];
      if (dirty & /*size*/
      512)
        radio_changes.size = /*size*/
        ctx8[9];
      if (dirty & /*color*/
      64)
        radio_changes.color = /*color*/
        ctx8[6];
      if (dirty & /*name*/
      65536)
        radio_changes.name = /*name*/
        ctx8[16];
      if (dirty & /*disabled*/
      256)
        radio_changes.disabled = /*disabled*/
        ctx8[8];
      if (!updating_group && dirty & /*group*/
      1) {
        updating_group = true;
        radio_changes.group = /*group*/
        ctx8[0];
        add_flush_callback(() => updating_group = false);
      }
      radio.$set(radio_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(radio.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(radio.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(radio, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block6.name,
    type: "each",
    source: "(35:3) {#each items as item}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_119(ctx8) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block36, create_else_block16];
  const if_blocks = [];
  function select_block_type(ctx9, dirty) {
    if (
      /*items*/
      ctx9[5] && /*items*/
      ctx9[5].length > 0
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx8, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx8);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx9, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx9, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx9);
          if_block.c();
        } else {
          if_block.p(ctx9, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_119.name,
    type: "slot",
    source: "(33:1) <Group {direction} {align} {position} {spacing}>",
    ctx: ctx8
  });
  return block;
}
function create_default_slot67(ctx8) {
  let group_1;
  let current;
  group_1 = new Group_default({
    props: {
      direction: (
        /*direction*/
        ctx8[12]
      ),
      align: (
        /*align*/
        ctx8[14]
      ),
      position: (
        /*position*/
        ctx8[11]
      ),
      spacing: (
        /*spacing*/
        ctx8[15]
      ),
      $$slots: { default: [create_default_slot_119] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(group_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(group_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(group_1, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const group_1_changes = {};
      if (dirty & /*direction*/
      4096)
        group_1_changes.direction = /*direction*/
        ctx9[12];
      if (dirty & /*align*/
      16384)
        group_1_changes.align = /*align*/
        ctx9[14];
      if (dirty & /*position*/
      2048)
        group_1_changes.position = /*position*/
        ctx9[11];
      if (dirty & /*spacing*/
      32768)
        group_1_changes.spacing = /*spacing*/
        ctx9[15];
      if (dirty & /*$$scope, items, use, labelDirection, radius, size, color, name, disabled, group*/
      16852837) {
        group_1_changes.$$scope = { dirty, ctx: ctx9 };
      }
      group_1.$set(group_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(group_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(group_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(group_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot67.name,
    type: "slot",
    source: "(32:0) <InputWrapper bind:element class={className} {label} {override} {size} {...$$restProps}>",
    ctx: ctx8
  });
  return block;
}
function create_fragment90(ctx8) {
  let inputwrapper;
  let updating_element;
  let current;
  const inputwrapper_spread_levels = [
    { class: (
      /*className*/
      ctx8[3]
    ) },
    { label: (
      /*label*/
      ctx8[7]
    ) },
    { override: (
      /*override*/
      ctx8[4]
    ) },
    { size: (
      /*size*/
      ctx8[9]
    ) },
    /*$$restProps*/
    ctx8[18]
  ];
  function inputwrapper_element_binding(value) {
    ctx8[23](value);
  }
  let inputwrapper_props = {
    $$slots: { default: [create_default_slot67] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < inputwrapper_spread_levels.length; i2 += 1) {
    inputwrapper_props = assign(inputwrapper_props, inputwrapper_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[1] !== void 0
  ) {
    inputwrapper_props.element = /*element*/
    ctx8[1];
  }
  inputwrapper = new InputWrapper_default({
    props: inputwrapper_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(inputwrapper, "element", inputwrapper_element_binding));
  const block = {
    c: function create() {
      create_component(inputwrapper.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(inputwrapper.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(inputwrapper, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const inputwrapper_changes = dirty & /*className, label, override, size, $$restProps*/
      262808 ? get_spread_update(inputwrapper_spread_levels, [
        dirty & /*className*/
        8 && { class: (
          /*className*/
          ctx9[3]
        ) },
        dirty & /*label*/
        128 && { label: (
          /*label*/
          ctx9[7]
        ) },
        dirty & /*override*/
        16 && { override: (
          /*override*/
          ctx9[4]
        ) },
        dirty & /*size*/
        512 && { size: (
          /*size*/
          ctx9[9]
        ) },
        dirty & /*$$restProps*/
        262144 && get_spread_object(
          /*$$restProps*/
          ctx9[18]
        )
      ]) : {};
      if (dirty & /*$$scope, direction, align, position, spacing, items, use, labelDirection, radius, size, color, name, disabled, group*/
      16908133) {
        inputwrapper_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      2) {
        updating_element = true;
        inputwrapper_changes.element = /*element*/
        ctx9[1];
        add_flush_callback(() => updating_element = false);
      }
      inputwrapper.$set(inputwrapper_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(inputwrapper.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(inputwrapper.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(inputwrapper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment90.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance90($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "items",
    "group",
    "color",
    "value",
    "label",
    "disabled",
    "size",
    "radius",
    "position",
    "direction",
    "labelDirection",
    "align",
    "spacing",
    "name"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioGroup", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, items = [], group = void 0, color = void 0, value = void 0, label = null, disabled = false, size: size3 = void 0, radius: radius2 = void 0, position = "left", direction = "row", labelDirection = "right", align = "flex-start", spacing = "md", name = randomID() } = $$props;
  const dispatch = createEventDispatcher();
  function onChanged(val, el) {
    const checked = el.checked;
    $$invalidate(19, value = checked ? val : void 0);
    dispatch("change", val);
  }
  function radio_group_binding(value$1) {
    group = value$1;
    $$invalidate(0, group), $$invalidate(19, value);
  }
  const change_handler = (item, e) => onChanged(item.value, e.target);
  function inputwrapper_element_binding(value2) {
    element2 = value2;
    $$invalidate(1, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(18, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(1, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(4, override = $$new_props.override);
    if ("items" in $$new_props)
      $$invalidate(5, items = $$new_props.items);
    if ("group" in $$new_props)
      $$invalidate(0, group = $$new_props.group);
    if ("color" in $$new_props)
      $$invalidate(6, color = $$new_props.color);
    if ("value" in $$new_props)
      $$invalidate(19, value = $$new_props.value);
    if ("label" in $$new_props)
      $$invalidate(7, label = $$new_props.label);
    if ("disabled" in $$new_props)
      $$invalidate(8, disabled = $$new_props.disabled);
    if ("size" in $$new_props)
      $$invalidate(9, size3 = $$new_props.size);
    if ("radius" in $$new_props)
      $$invalidate(10, radius2 = $$new_props.radius);
    if ("position" in $$new_props)
      $$invalidate(11, position = $$new_props.position);
    if ("direction" in $$new_props)
      $$invalidate(12, direction = $$new_props.direction);
    if ("labelDirection" in $$new_props)
      $$invalidate(13, labelDirection = $$new_props.labelDirection);
    if ("align" in $$new_props)
      $$invalidate(14, align = $$new_props.align);
    if ("spacing" in $$new_props)
      $$invalidate(15, spacing = $$new_props.spacing);
    if ("name" in $$new_props)
      $$invalidate(16, name = $$new_props.name);
    if ("$$scope" in $$new_props)
      $$invalidate(24, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    InputWrapper: InputWrapper_default,
    Group: Group_default,
    Radio: Radio_default,
    randomID,
    use,
    element: element2,
    className,
    override,
    items,
    group,
    color,
    value,
    label,
    disabled,
    size: size3,
    radius: radius2,
    position,
    direction,
    labelDirection,
    align,
    spacing,
    name,
    dispatch,
    onChanged
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(1, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(4, override = $$new_props.override);
    if ("items" in $$props)
      $$invalidate(5, items = $$new_props.items);
    if ("group" in $$props)
      $$invalidate(0, group = $$new_props.group);
    if ("color" in $$props)
      $$invalidate(6, color = $$new_props.color);
    if ("value" in $$props)
      $$invalidate(19, value = $$new_props.value);
    if ("label" in $$props)
      $$invalidate(7, label = $$new_props.label);
    if ("disabled" in $$props)
      $$invalidate(8, disabled = $$new_props.disabled);
    if ("size" in $$props)
      $$invalidate(9, size3 = $$new_props.size);
    if ("radius" in $$props)
      $$invalidate(10, radius2 = $$new_props.radius);
    if ("position" in $$props)
      $$invalidate(11, position = $$new_props.position);
    if ("direction" in $$props)
      $$invalidate(12, direction = $$new_props.direction);
    if ("labelDirection" in $$props)
      $$invalidate(13, labelDirection = $$new_props.labelDirection);
    if ("align" in $$props)
      $$invalidate(14, align = $$new_props.align);
    if ("spacing" in $$props)
      $$invalidate(15, spacing = $$new_props.spacing);
    if ("name" in $$props)
      $$invalidate(16, name = $$new_props.name);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*group, value*/
    524289) {
      $:
        $$invalidate(0, group = group || value);
    }
  };
  return [
    group,
    element2,
    use,
    className,
    override,
    items,
    color,
    label,
    disabled,
    size3,
    radius2,
    position,
    direction,
    labelDirection,
    align,
    spacing,
    name,
    onChanged,
    $$restProps,
    value,
    slots,
    radio_group_binding,
    change_handler,
    inputwrapper_element_binding,
    $$scope
  ];
}
var RadioGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance90, create_fragment90, safe_not_equal, {
      use: 2,
      element: 1,
      class: 3,
      override: 4,
      items: 5,
      group: 0,
      color: 6,
      value: 19,
      label: 7,
      disabled: 8,
      size: 9,
      radius: 10,
      position: 11,
      direction: 12,
      labelDirection: 13,
      align: 14,
      spacing: 15,
      name: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioGroup",
      options,
      id: create_fragment90.name
    });
  }
  get use() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get items() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get group() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get direction() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set direction(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelDirection() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelDirection(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RadioGroup_default = RadioGroup;

// node_modules/@svelteuidev/core/dist/components/Seo/Seo.svelte
var file42 = "node_modules/@svelteuidev/core/dist/components/Seo/Seo.svelte";
function get_each_context7(ctx8, list, i2) {
  const child_ctx = ctx8.slice();
  child_ctx[16] = list[i2];
  return child_ctx;
}
function get_each_context_1(ctx8, list, i2) {
  const child_ctx = ctx8.slice();
  child_ctx[16] = list[i2];
  return child_ctx;
}
function get_each_context_2(ctx8, list, i2) {
  const child_ctx = ctx8.slice();
  child_ctx[21] = list[i2];
  return child_ctx;
}
function get_each_context_3(ctx8, list, i2) {
  const child_ctx = ctx8.slice();
  child_ctx[24] = list[i2];
  return child_ctx;
}
function get_each_context_8(ctx8, list, i2) {
  const child_ctx = ctx8.slice();
  child_ctx[16] = list[i2];
  return child_ctx;
}
function get_each_context_9(ctx8, list, i2) {
  const child_ctx = ctx8.slice();
  child_ctx[38] = list[i2];
  return child_ctx;
}
function get_each_context_10(ctx8, list, i2) {
  const child_ctx = ctx8.slice();
  child_ctx[41] = list[i2];
  return child_ctx;
}
function get_each_context_11(ctx8, list, i2) {
  const child_ctx = ctx8.slice();
  child_ctx[44] = list[i2];
  return child_ctx;
}
function get_each_context_6(ctx8, list, i2) {
  const child_ctx = ctx8.slice();
  child_ctx[16] = list[i2];
  return child_ctx;
}
function get_each_context_7(ctx8, list, i2) {
  const child_ctx = ctx8.slice();
  child_ctx[29] = list[i2];
  return child_ctx;
}
function get_each_context_4(ctx8, list, i2) {
  const child_ctx = ctx8.slice();
  child_ctx[16] = list[i2];
  return child_ctx;
}
function get_each_context_5(ctx8, list, i2) {
  const child_ctx = ctx8.slice();
  child_ctx[29] = list[i2];
  return child_ctx;
}
function get_each_context_12(ctx8, list, i2) {
  const child_ctx = ctx8.slice();
  child_ctx[47] = list[i2];
  return child_ctx;
}
function create_if_block_59(ctx8) {
  let meta;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { name: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "name", "description");
      attr_dev(
        meta,
        "content",
        /*description*/
        ctx8[2]
      );
      add_location(meta, file42, 40, 2, 1699);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*description*/
      4) {
        attr_dev(
          meta,
          "content",
          /*description*/
          ctx9[2]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_59.name,
    type: "if",
    source: "(40:1) {#if description}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_58(ctx8) {
  let link;
  const block = {
    c: function create() {
      link = element("link");
      this.h();
    },
    l: function claim(nodes) {
      link = claim_element(nodes, "LINK", { rel: true, href: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(link, "rel", "canonical");
      attr_dev(
        link,
        "href",
        /*canonical*/
        ctx8[8]
      );
      add_location(link, file42, 44, 2, 1776);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, link, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*canonical*/
      256) {
        attr_dev(
          link,
          "href",
          /*canonical*/
          ctx9[8]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(link);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_58.name,
    type: "if",
    source: "(44:1) {#if canonical}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_57(ctx8) {
  let link;
  let link_media_value;
  let link_href_value;
  const block = {
    c: function create() {
      link = element("link");
      this.h();
    },
    l: function claim(nodes) {
      link = claim_element(nodes, "LINK", { rel: true, media: true, href: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(link, "rel", "alternate");
      attr_dev(link, "media", link_media_value = /*mobileAlternate*/
      ctx8[3].media);
      attr_dev(link, "href", link_href_value = /*mobileAlternate*/
      ctx8[3].href);
      add_location(link, file42, 48, 2, 1851);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, link, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*mobileAlternate*/
      8 && link_media_value !== (link_media_value = /*mobileAlternate*/
      ctx9[3].media)) {
        attr_dev(link, "media", link_media_value);
      }
      if (dirty[0] & /*mobileAlternate*/
      8 && link_href_value !== (link_href_value = /*mobileAlternate*/
      ctx9[3].href)) {
        attr_dev(link, "href", link_href_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(link);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_57.name,
    type: "if",
    source: "(48:1) {#if mobileAlternate}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_56(ctx8) {
  let each_1_anchor;
  let each_value_12 = ensure_array_like_dev(
    /*languageAlternates*/
    ctx8[4]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_12.length; i2 += 1) {
    each_blocks[i2] = create_each_block_12(get_each_context_12(ctx8, each_value_12, i2));
  }
  const block = {
    c: function create() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*languageAlternates*/
      16) {
        each_value_12 = ensure_array_like_dev(
          /*languageAlternates*/
          ctx9[4]
        );
        let i2;
        for (i2 = 0; i2 < each_value_12.length; i2 += 1) {
          const child_ctx = get_each_context_12(ctx9, each_value_12, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_12(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_12.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_56.name,
    type: "if",
    source: "(52:1) {#if languageAlternates && languageAlternates.length > 0}",
    ctx: ctx8
  });
  return block;
}
function create_each_block_12(ctx8) {
  let link;
  let link_hreflang_value;
  let link_href_value;
  const block = {
    c: function create() {
      link = element("link");
      this.h();
    },
    l: function claim(nodes) {
      link = claim_element(nodes, "LINK", { rel: true, hreflang: true, href: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(link, "rel", "alternate");
      attr_dev(link, "hreflang", link_hreflang_value = /*languageAlternate*/
      ctx8[47].hrefLang);
      attr_dev(link, "href", link_href_value = /*languageAlternate*/
      ctx8[47].href);
      add_location(link, file42, 53, 3, 2054);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, link, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*languageAlternates*/
      16 && link_hreflang_value !== (link_hreflang_value = /*languageAlternate*/
      ctx9[47].hrefLang)) {
        attr_dev(link, "hreflang", link_hreflang_value);
      }
      if (dirty[0] & /*languageAlternates*/
      16 && link_href_value !== (link_href_value = /*languageAlternate*/
      ctx9[47].href)) {
        attr_dev(link, "href", link_href_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(link);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_12.name,
    type: "each",
    source: "(53:2) {#each languageAlternates as languageAlternate}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_48(ctx8) {
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let if_block6_anchor;
  let if_block0 = (
    /*twitter*/
    ctx8[5].cardType && create_if_block_55(ctx8)
  );
  let if_block1 = (
    /*twitter*/
    ctx8[5].site && create_if_block_54(ctx8)
  );
  let if_block2 = (
    /*twitter*/
    ctx8[5].handle && create_if_block_53(ctx8)
  );
  let if_block3 = (
    /*twitter*/
    ctx8[5].title && create_if_block_522(ctx8)
  );
  let if_block4 = (
    /*twitter*/
    ctx8[5].description && create_if_block_51(ctx8)
  );
  let if_block5 = (
    /*twitter*/
    ctx8[5].image && create_if_block_50(ctx8)
  );
  let if_block6 = (
    /*twitter*/
    ctx8[5].imageAlt && create_if_block_49(ctx8)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      t3 = space();
      if (if_block4)
        if_block4.c();
      t4 = space();
      if (if_block5)
        if_block5.c();
      t5 = space();
      if (if_block6)
        if_block6.c();
      if_block6_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t1 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      t2 = claim_space(nodes);
      if (if_block3)
        if_block3.l(nodes);
      t3 = claim_space(nodes);
      if (if_block4)
        if_block4.l(nodes);
      t4 = claim_space(nodes);
      if (if_block5)
        if_block5.l(nodes);
      t5 = claim_space(nodes);
      if (if_block6)
        if_block6.l(nodes);
      if_block6_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert_hydration_dev(target, t3, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert_hydration_dev(target, t4, anchor);
      if (if_block5)
        if_block5.m(target, anchor);
      insert_hydration_dev(target, t5, anchor);
      if (if_block6)
        if_block6.m(target, anchor);
      insert_hydration_dev(target, if_block6_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (
        /*twitter*/
        ctx9[5].cardType
      ) {
        if (if_block0) {
          if_block0.p(ctx9, dirty);
        } else {
          if_block0 = create_if_block_55(ctx9);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*twitter*/
        ctx9[5].site
      ) {
        if (if_block1) {
          if_block1.p(ctx9, dirty);
        } else {
          if_block1 = create_if_block_54(ctx9);
          if_block1.c();
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*twitter*/
        ctx9[5].handle
      ) {
        if (if_block2) {
          if_block2.p(ctx9, dirty);
        } else {
          if_block2 = create_if_block_53(ctx9);
          if_block2.c();
          if_block2.m(t2.parentNode, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*twitter*/
        ctx9[5].title
      ) {
        if (if_block3) {
          if_block3.p(ctx9, dirty);
        } else {
          if_block3 = create_if_block_522(ctx9);
          if_block3.c();
          if_block3.m(t3.parentNode, t3);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (
        /*twitter*/
        ctx9[5].description
      ) {
        if (if_block4) {
          if_block4.p(ctx9, dirty);
        } else {
          if_block4 = create_if_block_51(ctx9);
          if_block4.c();
          if_block4.m(t4.parentNode, t4);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (
        /*twitter*/
        ctx9[5].image
      ) {
        if (if_block5) {
          if_block5.p(ctx9, dirty);
        } else {
          if_block5 = create_if_block_50(ctx9);
          if_block5.c();
          if_block5.m(t5.parentNode, t5);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
      if (
        /*twitter*/
        ctx9[5].imageAlt
      ) {
        if (if_block6) {
          if_block6.p(ctx9, dirty);
        } else {
          if_block6 = create_if_block_49(ctx9);
          if_block6.c();
          if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
        }
      } else if (if_block6) {
        if_block6.d(1);
        if_block6 = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
        detach_dev(t3);
        detach_dev(t4);
        detach_dev(t5);
        detach_dev(if_block6_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
      if (if_block2)
        if_block2.d(detaching);
      if (if_block3)
        if_block3.d(detaching);
      if (if_block4)
        if_block4.d(detaching);
      if (if_block5)
        if_block5.d(detaching);
      if (if_block6)
        if_block6.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_48.name,
    type: "if",
    source: "(58:1) {#if twitter}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_55(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { name: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "name", "twitter:card");
      attr_dev(meta, "content", meta_content_value = /*twitter*/
      ctx8[5].cardType);
      add_location(meta, file42, 59, 3, 2208);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*twitter*/
      32 && meta_content_value !== (meta_content_value = /*twitter*/
      ctx9[5].cardType)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_55.name,
    type: "if",
    source: "(59:2) {#if twitter.cardType}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_54(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { name: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "name", "twitter:site");
      attr_dev(meta, "content", meta_content_value = /*twitter*/
      ctx8[5].site);
      add_location(meta, file42, 62, 3, 2296);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*twitter*/
      32 && meta_content_value !== (meta_content_value = /*twitter*/
      ctx9[5].site)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_54.name,
    type: "if",
    source: "(62:2) {#if twitter.site}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_53(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { name: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "name", "twitter:creator");
      attr_dev(meta, "content", meta_content_value = /*twitter*/
      ctx8[5].handle);
      add_location(meta, file42, 65, 3, 2382);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*twitter*/
      32 && meta_content_value !== (meta_content_value = /*twitter*/
      ctx9[5].handle)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_53.name,
    type: "if",
    source: "(65:2) {#if twitter.handle}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_522(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { name: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "name", "twitter:title");
      attr_dev(meta, "content", meta_content_value = /*twitter*/
      ctx8[5].title);
      add_location(meta, file42, 68, 3, 2472);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*twitter*/
      32 && meta_content_value !== (meta_content_value = /*twitter*/
      ctx9[5].title)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_522.name,
    type: "if",
    source: "(68:2) {#if twitter.title}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_51(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { name: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "name", "twitter:description");
      attr_dev(meta, "content", meta_content_value = /*twitter*/
      ctx8[5].description);
      add_location(meta, file42, 71, 3, 2565);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*twitter*/
      32 && meta_content_value !== (meta_content_value = /*twitter*/
      ctx9[5].description)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_51.name,
    type: "if",
    source: "(71:2) {#if twitter.description}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_50(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { name: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "name", "twitter:image");
      attr_dev(meta, "content", meta_content_value = /*twitter*/
      ctx8[5].image);
      add_location(meta, file42, 74, 3, 2664);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*twitter*/
      32 && meta_content_value !== (meta_content_value = /*twitter*/
      ctx9[5].image)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_50.name,
    type: "if",
    source: "(74:2) {#if twitter.image}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_49(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { name: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "name", "twitter:image:alt");
      attr_dev(meta, "content", meta_content_value = /*twitter*/
      ctx8[5].imageAlt);
      add_location(meta, file42, 77, 3, 2754);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*twitter*/
      32 && meta_content_value !== (meta_content_value = /*twitter*/
      ctx9[5].imageAlt)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_49.name,
    type: "if",
    source: "(77:2) {#if twitter.imageAlt}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_47(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "fb:app_id");
      attr_dev(meta, "content", meta_content_value = /*facebook*/
      ctx8[6].appId);
      add_location(meta, file42, 82, 2, 2849);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*facebook*/
      64 && meta_content_value !== (meta_content_value = /*facebook*/
      ctx9[6].appId)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_47.name,
    type: "if",
    source: "(82:1) {#if facebook}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_213(ctx8) {
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let if_block7_anchor;
  let if_block0 = (
    /*openGraph*/
    (ctx8[7].url || /*canonical*/
    ctx8[8]) && create_if_block_46(ctx8)
  );
  let if_block1 = (
    /*openGraph*/
    ctx8[7].type && create_if_block_182(ctx8)
  );
  let if_block2 = (
    /*openGraph*/
    (ctx8[7].title || /*updatedTitle*/
    ctx8[12]) && create_if_block_172(ctx8)
  );
  let if_block3 = (
    /*openGraph*/
    (ctx8[7].description || /*description*/
    ctx8[2]) && create_if_block_162(ctx8)
  );
  let if_block4 = (
    /*openGraph*/
    ctx8[7].images && /*openGraph*/
    ctx8[7].images.length && create_if_block_11(ctx8)
  );
  let if_block5 = (
    /*openGraph*/
    ctx8[7].videos && /*openGraph*/
    ctx8[7].videos.length && create_if_block_510(ctx8)
  );
  let if_block6 = (
    /*openGraph*/
    ctx8[7].locale && create_if_block_410(ctx8)
  );
  let if_block7 = (
    /*openGraph*/
    ctx8[7].site_name && create_if_block_310(ctx8)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      t3 = space();
      if (if_block4)
        if_block4.c();
      t4 = space();
      if (if_block5)
        if_block5.c();
      t5 = space();
      if (if_block6)
        if_block6.c();
      t6 = space();
      if (if_block7)
        if_block7.c();
      if_block7_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t1 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      t2 = claim_space(nodes);
      if (if_block3)
        if_block3.l(nodes);
      t3 = claim_space(nodes);
      if (if_block4)
        if_block4.l(nodes);
      t4 = claim_space(nodes);
      if (if_block5)
        if_block5.l(nodes);
      t5 = claim_space(nodes);
      if (if_block6)
        if_block6.l(nodes);
      t6 = claim_space(nodes);
      if (if_block7)
        if_block7.l(nodes);
      if_block7_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert_hydration_dev(target, t3, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert_hydration_dev(target, t4, anchor);
      if (if_block5)
        if_block5.m(target, anchor);
      insert_hydration_dev(target, t5, anchor);
      if (if_block6)
        if_block6.m(target, anchor);
      insert_hydration_dev(target, t6, anchor);
      if (if_block7)
        if_block7.m(target, anchor);
      insert_hydration_dev(target, if_block7_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (
        /*openGraph*/
        ctx9[7].url || /*canonical*/
        ctx9[8]
      ) {
        if (if_block0) {
          if_block0.p(ctx9, dirty);
        } else {
          if_block0 = create_if_block_46(ctx9);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*openGraph*/
        ctx9[7].type
      ) {
        if (if_block1) {
          if_block1.p(ctx9, dirty);
        } else {
          if_block1 = create_if_block_182(ctx9);
          if_block1.c();
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*openGraph*/
        ctx9[7].title || /*updatedTitle*/
        ctx9[12]
      ) {
        if (if_block2) {
          if_block2.p(ctx9, dirty);
        } else {
          if_block2 = create_if_block_172(ctx9);
          if_block2.c();
          if_block2.m(t2.parentNode, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*openGraph*/
        ctx9[7].description || /*description*/
        ctx9[2]
      ) {
        if (if_block3) {
          if_block3.p(ctx9, dirty);
        } else {
          if_block3 = create_if_block_162(ctx9);
          if_block3.c();
          if_block3.m(t3.parentNode, t3);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (
        /*openGraph*/
        ctx9[7].images && /*openGraph*/
        ctx9[7].images.length
      ) {
        if (if_block4) {
          if_block4.p(ctx9, dirty);
        } else {
          if_block4 = create_if_block_11(ctx9);
          if_block4.c();
          if_block4.m(t4.parentNode, t4);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (
        /*openGraph*/
        ctx9[7].videos && /*openGraph*/
        ctx9[7].videos.length
      ) {
        if (if_block5) {
          if_block5.p(ctx9, dirty);
        } else {
          if_block5 = create_if_block_510(ctx9);
          if_block5.c();
          if_block5.m(t5.parentNode, t5);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
      if (
        /*openGraph*/
        ctx9[7].locale
      ) {
        if (if_block6) {
          if_block6.p(ctx9, dirty);
        } else {
          if_block6 = create_if_block_410(ctx9);
          if_block6.c();
          if_block6.m(t6.parentNode, t6);
        }
      } else if (if_block6) {
        if_block6.d(1);
        if_block6 = null;
      }
      if (
        /*openGraph*/
        ctx9[7].site_name
      ) {
        if (if_block7) {
          if_block7.p(ctx9, dirty);
        } else {
          if_block7 = create_if_block_310(ctx9);
          if_block7.c();
          if_block7.m(if_block7_anchor.parentNode, if_block7_anchor);
        }
      } else if (if_block7) {
        if_block7.d(1);
        if_block7 = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
        detach_dev(t3);
        detach_dev(t4);
        detach_dev(t5);
        detach_dev(t6);
        detach_dev(if_block7_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
      if (if_block2)
        if_block2.d(detaching);
      if (if_block3)
        if_block3.d(detaching);
      if (if_block4)
        if_block4.d(detaching);
      if (if_block5)
        if_block5.d(detaching);
      if (if_block6)
        if_block6.d(detaching);
      if (if_block7)
        if_block7.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_213.name,
    type: "if",
    source: "(86:1) {#if openGraph}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_46(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "og:url");
      attr_dev(meta, "content", meta_content_value = /*openGraph*/
      ctx8[7].url || /*canonical*/
      ctx8[8]);
      add_location(meta, file42, 87, 3, 2967);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph, canonical*/
      384 && meta_content_value !== (meta_content_value = /*openGraph*/
      ctx9[7].url || /*canonical*/
      ctx9[8])) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_46.name,
    type: "if",
    source: "(87:2) {#if openGraph.url || canonical}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_182(ctx8) {
  let meta;
  let meta_content_value;
  let t;
  let show_if;
  let show_if_1;
  let show_if_2;
  let show_if_3;
  let if_block_anchor;
  function select_block_type(ctx9, dirty) {
    if (dirty[0] & /*openGraph*/
    128)
      show_if = null;
    if (dirty[0] & /*openGraph*/
    128)
      show_if_1 = null;
    if (dirty[0] & /*openGraph*/
    128)
      show_if_2 = null;
    if (dirty[0] & /*openGraph*/
    128)
      show_if_3 = null;
    if (show_if == null)
      show_if = !!/*openGraph*/
      (ctx9[7].type.toLowerCase() === "profile" && /*openGraph*/
      ctx9[7].profile);
    if (show_if)
      return create_if_block_192;
    if (show_if_1 == null)
      show_if_1 = !!/*openGraph*/
      (ctx9[7].type.toLowerCase() === "book" && /*openGraph*/
      ctx9[7].book);
    if (show_if_1)
      return create_if_block_242;
    if (show_if_2 == null)
      show_if_2 = !!/*openGraph*/
      (ctx9[7].type.toLowerCase() === "article" && /*openGraph*/
      ctx9[7].article);
    if (show_if_2)
      return create_if_block_292;
    if (show_if_3 == null)
      show_if_3 = !!/*openGraph*/
      (ctx9[7].type.toLowerCase() === "video.movie" || /*openGraph*/
      ctx9[7].type.toLowerCase() === "video.episode" || /*openGraph*/
      ctx9[7].type.toLowerCase() === "video.tv_show" || /*openGraph*/
      ctx9[7].type.toLowerCase() === "video.other" && /*openGraph*/
      ctx9[7].video);
    if (show_if_3)
      return create_if_block_36;
  }
  let current_block_type = select_block_type(ctx8, [-1, -1]);
  let if_block = current_block_type && current_block_type(ctx8);
  const block = {
    c: function create() {
      meta = element("meta");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      t = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "og:type");
      attr_dev(meta, "content", meta_content_value = /*openGraph*/
      ctx8[7].type.toLowerCase());
      add_location(meta, file42, 91, 3, 3066);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*openGraph*/
      ctx9[7].type.toLowerCase())) {
        attr_dev(meta, "content", meta_content_value);
      }
      if (current_block_type === (current_block_type = select_block_type(ctx9, dirty)) && if_block) {
        if_block.p(ctx9, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx9);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
        detach_dev(t);
        detach_dev(if_block_anchor);
      }
      if (if_block) {
        if_block.d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_182.name,
    type: "if",
    source: "(91:2) {#if openGraph.type}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_36(ctx8) {
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let if_block6_anchor;
  let if_block0 = (
    /*openGraph*/
    ctx8[7].video.actors && /*openGraph*/
    ctx8[7].video.actors.length && create_if_block_43(ctx8)
  );
  let if_block1 = (
    /*openGraph*/
    ctx8[7].video.directors && /*openGraph*/
    ctx8[7].video.directors.length && create_if_block_422(ctx8)
  );
  let if_block2 = (
    /*openGraph*/
    ctx8[7].video.writers && /*openGraph*/
    ctx8[7].video.writers.length && create_if_block_41(ctx8)
  );
  let if_block3 = (
    /*openGraph*/
    ctx8[7].video.duration && create_if_block_40(ctx8)
  );
  let if_block4 = (
    /*openGraph*/
    ctx8[7].video.releaseDate && create_if_block_39(ctx8)
  );
  let if_block5 = (
    /*openGraph*/
    ctx8[7].video.tags && /*openGraph*/
    ctx8[7].video.tags.length && create_if_block_38(ctx8)
  );
  let if_block6 = (
    /*openGraph*/
    ctx8[7].video.series && create_if_block_37(ctx8)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      t3 = space();
      if (if_block4)
        if_block4.c();
      t4 = space();
      if (if_block5)
        if_block5.c();
      t5 = space();
      if (if_block6)
        if_block6.c();
      if_block6_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t1 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      t2 = claim_space(nodes);
      if (if_block3)
        if_block3.l(nodes);
      t3 = claim_space(nodes);
      if (if_block4)
        if_block4.l(nodes);
      t4 = claim_space(nodes);
      if (if_block5)
        if_block5.l(nodes);
      t5 = claim_space(nodes);
      if (if_block6)
        if_block6.l(nodes);
      if_block6_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert_hydration_dev(target, t3, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert_hydration_dev(target, t4, anchor);
      if (if_block5)
        if_block5.m(target, anchor);
      insert_hydration_dev(target, t5, anchor);
      if (if_block6)
        if_block6.m(target, anchor);
      insert_hydration_dev(target, if_block6_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (
        /*openGraph*/
        ctx9[7].video.actors && /*openGraph*/
        ctx9[7].video.actors.length
      ) {
        if (if_block0) {
          if_block0.p(ctx9, dirty);
        } else {
          if_block0 = create_if_block_43(ctx9);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*openGraph*/
        ctx9[7].video.directors && /*openGraph*/
        ctx9[7].video.directors.length
      ) {
        if (if_block1) {
          if_block1.p(ctx9, dirty);
        } else {
          if_block1 = create_if_block_422(ctx9);
          if_block1.c();
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*openGraph*/
        ctx9[7].video.writers && /*openGraph*/
        ctx9[7].video.writers.length
      ) {
        if (if_block2) {
          if_block2.p(ctx9, dirty);
        } else {
          if_block2 = create_if_block_41(ctx9);
          if_block2.c();
          if_block2.m(t2.parentNode, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*openGraph*/
        ctx9[7].video.duration
      ) {
        if (if_block3) {
          if_block3.p(ctx9, dirty);
        } else {
          if_block3 = create_if_block_40(ctx9);
          if_block3.c();
          if_block3.m(t3.parentNode, t3);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (
        /*openGraph*/
        ctx9[7].video.releaseDate
      ) {
        if (if_block4) {
          if_block4.p(ctx9, dirty);
        } else {
          if_block4 = create_if_block_39(ctx9);
          if_block4.c();
          if_block4.m(t4.parentNode, t4);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (
        /*openGraph*/
        ctx9[7].video.tags && /*openGraph*/
        ctx9[7].video.tags.length
      ) {
        if (if_block5) {
          if_block5.p(ctx9, dirty);
        } else {
          if_block5 = create_if_block_38(ctx9);
          if_block5.c();
          if_block5.m(t5.parentNode, t5);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
      if (
        /*openGraph*/
        ctx9[7].video.series
      ) {
        if (if_block6) {
          if_block6.p(ctx9, dirty);
        } else {
          if_block6 = create_if_block_37(ctx9);
          if_block6.c();
          if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
        }
      } else if (if_block6) {
        if_block6.d(1);
        if_block6 = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
        detach_dev(t3);
        detach_dev(t4);
        detach_dev(t5);
        detach_dev(if_block6_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
      if (if_block2)
        if_block2.d(detaching);
      if (if_block3)
        if_block3.d(detaching);
      if (if_block4)
        if_block4.d(detaching);
      if (if_block5)
        if_block5.d(detaching);
      if (if_block6)
        if_block6.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_36.name,
    type: "if",
    source: "(157:235) ",
    ctx: ctx8
  });
  return block;
}
function create_if_block_292(ctx8) {
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let if_block5_anchor;
  let if_block0 = (
    /*openGraph*/
    ctx8[7].article.publishedTime && create_if_block_352(ctx8)
  );
  let if_block1 = (
    /*openGraph*/
    ctx8[7].article.modifiedTime && create_if_block_342(ctx8)
  );
  let if_block2 = (
    /*openGraph*/
    ctx8[7].article.expirationTime && create_if_block_332(ctx8)
  );
  let if_block3 = (
    /*openGraph*/
    ctx8[7].article.authors && /*openGraph*/
    ctx8[7].article.authors.length && create_if_block_322(ctx8)
  );
  let if_block4 = (
    /*openGraph*/
    ctx8[7].article.section && create_if_block_31(ctx8)
  );
  let if_block5 = (
    /*openGraph*/
    ctx8[7].article.tags && /*openGraph*/
    ctx8[7].article.tags.length && create_if_block_30(ctx8)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      t3 = space();
      if (if_block4)
        if_block4.c();
      t4 = space();
      if (if_block5)
        if_block5.c();
      if_block5_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t1 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      t2 = claim_space(nodes);
      if (if_block3)
        if_block3.l(nodes);
      t3 = claim_space(nodes);
      if (if_block4)
        if_block4.l(nodes);
      t4 = claim_space(nodes);
      if (if_block5)
        if_block5.l(nodes);
      if_block5_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert_hydration_dev(target, t3, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert_hydration_dev(target, t4, anchor);
      if (if_block5)
        if_block5.m(target, anchor);
      insert_hydration_dev(target, if_block5_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (
        /*openGraph*/
        ctx9[7].article.publishedTime
      ) {
        if (if_block0) {
          if_block0.p(ctx9, dirty);
        } else {
          if_block0 = create_if_block_352(ctx9);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*openGraph*/
        ctx9[7].article.modifiedTime
      ) {
        if (if_block1) {
          if_block1.p(ctx9, dirty);
        } else {
          if_block1 = create_if_block_342(ctx9);
          if_block1.c();
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*openGraph*/
        ctx9[7].article.expirationTime
      ) {
        if (if_block2) {
          if_block2.p(ctx9, dirty);
        } else {
          if_block2 = create_if_block_332(ctx9);
          if_block2.c();
          if_block2.m(t2.parentNode, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*openGraph*/
        ctx9[7].article.authors && /*openGraph*/
        ctx9[7].article.authors.length
      ) {
        if (if_block3) {
          if_block3.p(ctx9, dirty);
        } else {
          if_block3 = create_if_block_322(ctx9);
          if_block3.c();
          if_block3.m(t3.parentNode, t3);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (
        /*openGraph*/
        ctx9[7].article.section
      ) {
        if (if_block4) {
          if_block4.p(ctx9, dirty);
        } else {
          if_block4 = create_if_block_31(ctx9);
          if_block4.c();
          if_block4.m(t4.parentNode, t4);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (
        /*openGraph*/
        ctx9[7].article.tags && /*openGraph*/
        ctx9[7].article.tags.length
      ) {
        if (if_block5) {
          if_block5.p(ctx9, dirty);
        } else {
          if_block5 = create_if_block_30(ctx9);
          if_block5.c();
          if_block5.m(if_block5_anchor.parentNode, if_block5_anchor);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
        detach_dev(t3);
        detach_dev(t4);
        detach_dev(if_block5_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
      if (if_block2)
        if_block2.d(detaching);
      if (if_block3)
        if_block3.d(detaching);
      if (if_block4)
        if_block4.d(detaching);
      if (if_block5)
        if_block5.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_292.name,
    type: "if",
    source: "(129:77) ",
    ctx: ctx8
  });
  return block;
}
function create_if_block_242(ctx8) {
  let t0;
  let t1;
  let t2;
  let if_block3_anchor;
  let if_block0 = (
    /*openGraph*/
    ctx8[7].book.authors && /*openGraph*/
    ctx8[7].book.authors.length && create_if_block_282(ctx8)
  );
  let if_block1 = (
    /*openGraph*/
    ctx8[7].book.isbn && create_if_block_272(ctx8)
  );
  let if_block2 = (
    /*openGraph*/
    ctx8[7].book.releaseDate && create_if_block_262(ctx8)
  );
  let if_block3 = (
    /*openGraph*/
    ctx8[7].book.tags && /*openGraph*/
    ctx8[7].book.tags.length && create_if_block_252(ctx8)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      if_block3_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t1 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      t2 = claim_space(nodes);
      if (if_block3)
        if_block3.l(nodes);
      if_block3_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert_hydration_dev(target, if_block3_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (
        /*openGraph*/
        ctx9[7].book.authors && /*openGraph*/
        ctx9[7].book.authors.length
      ) {
        if (if_block0) {
          if_block0.p(ctx9, dirty);
        } else {
          if_block0 = create_if_block_282(ctx9);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*openGraph*/
        ctx9[7].book.isbn
      ) {
        if (if_block1) {
          if_block1.p(ctx9, dirty);
        } else {
          if_block1 = create_if_block_272(ctx9);
          if_block1.c();
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*openGraph*/
        ctx9[7].book.releaseDate
      ) {
        if (if_block2) {
          if_block2.p(ctx9, dirty);
        } else {
          if_block2 = create_if_block_262(ctx9);
          if_block2.c();
          if_block2.m(t2.parentNode, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*openGraph*/
        ctx9[7].book.tags && /*openGraph*/
        ctx9[7].book.tags.length
      ) {
        if (if_block3) {
          if_block3.p(ctx9, dirty);
        } else {
          if_block3 = create_if_block_252(ctx9);
          if_block3.c();
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
        detach_dev(if_block3_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
      if (if_block2)
        if_block2.d(detaching);
      if (if_block3)
        if_block3.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_242.name,
    type: "if",
    source: "(109:71) ",
    ctx: ctx8
  });
  return block;
}
function create_if_block_192(ctx8) {
  let t0;
  let t1;
  let t2;
  let if_block3_anchor;
  let if_block0 = (
    /*openGraph*/
    ctx8[7].profile.firstName && create_if_block_232(ctx8)
  );
  let if_block1 = (
    /*openGraph*/
    ctx8[7].profile.lastName && create_if_block_222(ctx8)
  );
  let if_block2 = (
    /*openGraph*/
    ctx8[7].profile.username && create_if_block_21(ctx8)
  );
  let if_block3 = (
    /*openGraph*/
    ctx8[7].profile.gender && create_if_block_20(ctx8)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      if_block3_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t1 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      t2 = claim_space(nodes);
      if (if_block3)
        if_block3.l(nodes);
      if_block3_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert_hydration_dev(target, if_block3_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (
        /*openGraph*/
        ctx9[7].profile.firstName
      ) {
        if (if_block0) {
          if_block0.p(ctx9, dirty);
        } else {
          if_block0 = create_if_block_232(ctx9);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*openGraph*/
        ctx9[7].profile.lastName
      ) {
        if (if_block1) {
          if_block1.p(ctx9, dirty);
        } else {
          if_block1 = create_if_block_222(ctx9);
          if_block1.c();
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*openGraph*/
        ctx9[7].profile.username
      ) {
        if (if_block2) {
          if_block2.p(ctx9, dirty);
        } else {
          if_block2 = create_if_block_21(ctx9);
          if_block2.c();
          if_block2.m(t2.parentNode, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*openGraph*/
        ctx9[7].profile.gender
      ) {
        if (if_block3) {
          if_block3.p(ctx9, dirty);
        } else {
          if_block3 = create_if_block_20(ctx9);
          if_block3.c();
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
        detach_dev(if_block3_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
      if (if_block2)
        if_block2.d(detaching);
      if (if_block3)
        if_block3.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_192.name,
    type: "if",
    source: "(93:3) {#if openGraph.type.toLowerCase() === 'profile' && openGraph.profile}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_43(ctx8) {
  let each_1_anchor;
  let each_value_11 = ensure_array_like_dev(
    /*openGraph*/
    ctx8[7].video.actors
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_11.length; i2 += 1) {
    each_blocks[i2] = create_each_block_11(get_each_context_11(ctx8, each_value_11, i2));
  }
  const block = {
    c: function create() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128) {
        each_value_11 = ensure_array_like_dev(
          /*openGraph*/
          ctx9[7].video.actors
        );
        let i2;
        for (i2 = 0; i2 < each_value_11.length; i2 += 1) {
          const child_ctx = get_each_context_11(ctx9, each_value_11, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_11(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_11.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_43.name,
    type: "if",
    source: "(158:4) {#if openGraph.video.actors && openGraph.video.actors.length}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_45(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "video:actor");
      attr_dev(meta, "content", meta_content_value = /*actor*/
      ctx8[44].profile);
      add_location(meta, file42, 160, 7, 5779);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*actor*/
      ctx9[44].profile)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_45.name,
    type: "if",
    source: "(160:6) {#if actor.profile}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_44(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "video:actor:role");
      attr_dev(meta, "content", meta_content_value = /*actor*/
      ctx8[44].role);
      add_location(meta, file42, 163, 7, 5877);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*actor*/
      ctx9[44].role)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_44.name,
    type: "if",
    source: "(163:6) {#if actor.role}",
    ctx: ctx8
  });
  return block;
}
function create_each_block_11(ctx8) {
  let t;
  let if_block1_anchor;
  let if_block0 = (
    /*actor*/
    ctx8[44].profile && create_if_block_45(ctx8)
  );
  let if_block1 = (
    /*actor*/
    ctx8[44].role && create_if_block_44(ctx8)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (
        /*actor*/
        ctx9[44].profile
      ) {
        if (if_block0) {
          if_block0.p(ctx9, dirty);
        } else {
          if_block0 = create_if_block_45(ctx9);
          if_block0.c();
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*actor*/
        ctx9[44].role
      ) {
        if (if_block1) {
          if_block1.p(ctx9, dirty);
        } else {
          if_block1 = create_if_block_44(ctx9);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_11.name,
    type: "each",
    source: "(159:5) {#each openGraph.video.actors as actor}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_422(ctx8) {
  let each_1_anchor;
  let each_value_10 = ensure_array_like_dev(
    /*openGraph*/
    ctx8[7].video.directors
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_10.length; i2 += 1) {
    each_blocks[i2] = create_each_block_10(get_each_context_10(ctx8, each_value_10, i2));
  }
  const block = {
    c: function create() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128) {
        each_value_10 = ensure_array_like_dev(
          /*openGraph*/
          ctx9[7].video.directors
        );
        let i2;
        for (i2 = 0; i2 < each_value_10.length; i2 += 1) {
          const child_ctx = get_each_context_10(ctx9, each_value_10, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_10(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_10.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_422.name,
    type: "if",
    source: "(169:4) {#if openGraph.video.directors && openGraph.video.directors.length}",
    ctx: ctx8
  });
  return block;
}
function create_each_block_10(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "video:director");
      attr_dev(meta, "content", meta_content_value = /*director*/
      ctx8[41]);
      add_location(meta, file42, 170, 6, 6100);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*director*/
      ctx9[41])) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_10.name,
    type: "each",
    source: "(170:5) {#each openGraph.video.directors as director}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_41(ctx8) {
  let each_1_anchor;
  let each_value_9 = ensure_array_like_dev(
    /*openGraph*/
    ctx8[7].video.writers
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_9.length; i2 += 1) {
    each_blocks[i2] = create_each_block_9(get_each_context_9(ctx8, each_value_9, i2));
  }
  const block = {
    c: function create() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128) {
        each_value_9 = ensure_array_like_dev(
          /*openGraph*/
          ctx9[7].video.writers
        );
        let i2;
        for (i2 = 0; i2 < each_value_9.length; i2 += 1) {
          const child_ctx = get_each_context_9(ctx9, each_value_9, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_9(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_9.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_41.name,
    type: "if",
    source: "(175:4) {#if openGraph.video.writers && openGraph.video.writers.length}",
    ctx: ctx8
  });
  return block;
}
function create_each_block_9(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "video:writer");
      attr_dev(meta, "content", meta_content_value = /*writer*/
      ctx8[38]);
      add_location(meta, file42, 176, 6, 6299);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*writer*/
      ctx9[38])) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_9.name,
    type: "each",
    source: "(176:5) {#each openGraph.video.writers as writer}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_40(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "video:duration");
      attr_dev(meta, "content", meta_content_value = /*openGraph*/
      ctx8[7].video.duration.toString());
      add_location(meta, file42, 181, 5, 6413);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*openGraph*/
      ctx9[7].video.duration.toString())) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_40.name,
    type: "if",
    source: "(181:4) {#if openGraph.video.duration}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_39(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "video:release_date");
      attr_dev(meta, "content", meta_content_value = /*openGraph*/
      ctx8[7].video.releaseDate);
      add_location(meta, file42, 185, 5, 6548);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*openGraph*/
      ctx9[7].video.releaseDate)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_39.name,
    type: "if",
    source: "(185:4) {#if openGraph.video.releaseDate}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_38(ctx8) {
  let each_1_anchor;
  let each_value_8 = ensure_array_like_dev(
    /*openGraph*/
    ctx8[7].video.tags
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_8.length; i2 += 1) {
    each_blocks[i2] = create_each_block_8(get_each_context_8(ctx8, each_value_8, i2));
  }
  const block = {
    c: function create() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128) {
        each_value_8 = ensure_array_like_dev(
          /*openGraph*/
          ctx9[7].video.tags
        );
        let i2;
        for (i2 = 0; i2 < each_value_8.length; i2 += 1) {
          const child_ctx = get_each_context_8(ctx9, each_value_8, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_8(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_8.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_38.name,
    type: "if",
    source: "(189:4) {#if openGraph.video.tags && openGraph.video.tags.length}",
    ctx: ctx8
  });
  return block;
}
function create_each_block_8(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "video:tag");
      attr_dev(meta, "content", meta_content_value = /*tag*/
      ctx8[16]);
      add_location(meta, file42, 190, 6, 6745);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*tag*/
      ctx9[16])) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_8.name,
    type: "each",
    source: "(190:5) {#each openGraph.video.tags as tag}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_37(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "video:series");
      attr_dev(meta, "content", meta_content_value = /*openGraph*/
      ctx8[7].video.series);
      add_location(meta, file42, 195, 5, 6851);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*openGraph*/
      ctx9[7].video.series)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_37.name,
    type: "if",
    source: "(195:4) {#if openGraph.video.series}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_352(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "article:published_time");
      attr_dev(meta, "content", meta_content_value = /*openGraph*/
      ctx8[7].article.publishedTime);
      add_location(meta, file42, 130, 5, 4506);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*openGraph*/
      ctx9[7].article.publishedTime)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_352.name,
    type: "if",
    source: "(130:4) {#if openGraph.article.publishedTime}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_342(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "article:modified_time");
      attr_dev(meta, "content", meta_content_value = /*openGraph*/
      ctx8[7].article.modifiedTime);
      add_location(meta, file42, 134, 5, 4648);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*openGraph*/
      ctx9[7].article.modifiedTime)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_342.name,
    type: "if",
    source: "(134:4) {#if openGraph.article.modifiedTime}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_332(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "article:expiration_time");
      attr_dev(meta, "content", meta_content_value = /*openGraph*/
      ctx8[7].article.expirationTime);
      add_location(meta, file42, 138, 5, 4790);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*openGraph*/
      ctx9[7].article.expirationTime)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_332.name,
    type: "if",
    source: "(138:4) {#if openGraph.article.expirationTime}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_322(ctx8) {
  let each_1_anchor;
  let each_value_7 = ensure_array_like_dev(
    /*openGraph*/
    ctx8[7].article.authors
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_7.length; i2 += 1) {
    each_blocks[i2] = create_each_block_7(get_each_context_7(ctx8, each_value_7, i2));
  }
  const block = {
    c: function create() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128) {
        each_value_7 = ensure_array_like_dev(
          /*openGraph*/
          ctx9[7].article.authors
        );
        let i2;
        for (i2 = 0; i2 < each_value_7.length; i2 += 1) {
          const child_ctx = get_each_context_7(ctx9, each_value_7, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_7(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_7.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_322.name,
    type: "if",
    source: "(142:4) {#if openGraph.article.authors && openGraph.article.authors.length}",
    ctx: ctx8
  });
  return block;
}
function create_each_block_7(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "article:author");
      attr_dev(meta, "content", meta_content_value = /*author*/
      ctx8[29]);
      add_location(meta, file42, 143, 6, 5015);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*author*/
      ctx9[29])) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_7.name,
    type: "each",
    source: "(143:5) {#each openGraph.article.authors as author}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_31(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "article:section");
      attr_dev(meta, "content", meta_content_value = /*openGraph*/
      ctx8[7].article.section);
      add_location(meta, file42, 148, 5, 5132);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*openGraph*/
      ctx9[7].article.section)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_31.name,
    type: "if",
    source: "(148:4) {#if openGraph.article.section}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_30(ctx8) {
  let each_1_anchor;
  let each_value_6 = ensure_array_like_dev(
    /*openGraph*/
    ctx8[7].article.tags
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_6.length; i2 += 1) {
    each_blocks[i2] = create_each_block_6(get_each_context_6(ctx8, each_value_6, i2));
  }
  const block = {
    c: function create() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128) {
        each_value_6 = ensure_array_like_dev(
          /*openGraph*/
          ctx9[7].article.tags
        );
        let i2;
        for (i2 = 0; i2 < each_value_6.length; i2 += 1) {
          const child_ctx = get_each_context_6(ctx9, each_value_6, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_6(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_6.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_30.name,
    type: "if",
    source: "(152:4) {#if openGraph.article.tags && openGraph.article.tags.length}",
    ctx: ctx8
  });
  return block;
}
function create_each_block_6(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "article:tag");
      attr_dev(meta, "content", meta_content_value = /*tag*/
      ctx8[16]);
      add_location(meta, file42, 153, 6, 5330);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*tag*/
      ctx9[16])) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_6.name,
    type: "each",
    source: "(153:5) {#each openGraph.article.tags as tag}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_282(ctx8) {
  let each_1_anchor;
  let each_value_5 = ensure_array_like_dev(
    /*openGraph*/
    ctx8[7].book.authors
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_5.length; i2 += 1) {
    each_blocks[i2] = create_each_block_5(get_each_context_5(ctx8, each_value_5, i2));
  }
  const block = {
    c: function create() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128) {
        each_value_5 = ensure_array_like_dev(
          /*openGraph*/
          ctx9[7].book.authors
        );
        let i2;
        for (i2 = 0; i2 < each_value_5.length; i2 += 1) {
          const child_ctx = get_each_context_5(ctx9, each_value_5, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_5(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_5.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_282.name,
    type: "if",
    source: "(110:4) {#if openGraph.book.authors && openGraph.book.authors.length}",
    ctx: ctx8
  });
  return block;
}
function create_each_block_5(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "book:author");
      attr_dev(meta, "content", meta_content_value = /*author*/
      ctx8[29]);
      add_location(meta, file42, 111, 6, 3902);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*author*/
      ctx9[29])) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_5.name,
    type: "each",
    source: "(111:5) {#each openGraph.book.authors as author}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_272(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "book:isbn");
      attr_dev(meta, "content", meta_content_value = /*openGraph*/
      ctx8[7].book.isbn);
      add_location(meta, file42, 116, 5, 4010);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*openGraph*/
      ctx9[7].book.isbn)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_272.name,
    type: "if",
    source: "(116:4) {#if openGraph.book.isbn}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_262(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "book:release_date");
      attr_dev(meta, "content", meta_content_value = /*openGraph*/
      ctx8[7].book.releaseDate);
      add_location(meta, file42, 120, 5, 4123);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*openGraph*/
      ctx9[7].book.releaseDate)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_262.name,
    type: "if",
    source: "(120:4) {#if openGraph.book.releaseDate}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_252(ctx8) {
  let each_1_anchor;
  let each_value_4 = ensure_array_like_dev(
    /*openGraph*/
    ctx8[7].book.tags
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_4.length; i2 += 1) {
    each_blocks[i2] = create_each_block_4(get_each_context_4(ctx8, each_value_4, i2));
  }
  const block = {
    c: function create() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128) {
        each_value_4 = ensure_array_like_dev(
          /*openGraph*/
          ctx9[7].book.tags
        );
        let i2;
        for (i2 = 0; i2 < each_value_4.length; i2 += 1) {
          const child_ctx = get_each_context_4(ctx9, each_value_4, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_4(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_4.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_252.name,
    type: "if",
    source: "(124:4) {#if openGraph.book.tags && openGraph.book.tags.length}",
    ctx: ctx8
  });
  return block;
}
function create_each_block_4(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "book:tag");
      attr_dev(meta, "content", meta_content_value = /*tag*/
      ctx8[16]);
      add_location(meta, file42, 125, 6, 4315);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*tag*/
      ctx9[16])) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_4.name,
    type: "each",
    source: "(125:5) {#each openGraph.book.tags as tag}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_232(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "profile:first_name");
      attr_dev(meta, "content", meta_content_value = /*openGraph*/
      ctx8[7].profile.firstName);
      add_location(meta, file42, 94, 5, 3249);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*openGraph*/
      ctx9[7].profile.firstName)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_232.name,
    type: "if",
    source: "(94:4) {#if openGraph.profile.firstName}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_222(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "profile:last_name");
      attr_dev(meta, "content", meta_content_value = /*openGraph*/
      ctx8[7].profile.lastName);
      add_location(meta, file42, 98, 5, 3379);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*openGraph*/
      ctx9[7].profile.lastName)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_222.name,
    type: "if",
    source: "(98:4) {#if openGraph.profile.lastName}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_21(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "profile:username");
      attr_dev(meta, "content", meta_content_value = /*openGraph*/
      ctx8[7].profile.username);
      add_location(meta, file42, 102, 5, 3507);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*openGraph*/
      ctx9[7].profile.username)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_21.name,
    type: "if",
    source: "(102:4) {#if openGraph.profile.username}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_20(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "profile:gender");
      attr_dev(meta, "content", meta_content_value = /*openGraph*/
      ctx8[7].profile.gender);
      add_location(meta, file42, 106, 5, 3632);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*openGraph*/
      ctx9[7].profile.gender)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_20.name,
    type: "if",
    source: "(106:4) {#if openGraph.profile.gender}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_172(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "og:title");
      attr_dev(meta, "content", meta_content_value = /*openGraph*/
      ctx8[7].title || /*updatedTitle*/
      ctx8[12]);
      add_location(meta, file42, 201, 3, 6988);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph, updatedTitle*/
      4224 && meta_content_value !== (meta_content_value = /*openGraph*/
      ctx9[7].title || /*updatedTitle*/
      ctx9[12])) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_172.name,
    type: "if",
    source: "(201:2) {#if openGraph.title || updatedTitle}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_162(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "og:description");
      attr_dev(meta, "content", meta_content_value = /*openGraph*/
      ctx8[7].description || /*description*/
      ctx8[2]);
      add_location(meta, file42, 205, 3, 7116);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph, description*/
      132 && meta_content_value !== (meta_content_value = /*openGraph*/
      ctx9[7].description || /*description*/
      ctx9[2])) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_162.name,
    type: "if",
    source: "(205:2) {#if openGraph.description || description}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_11(ctx8) {
  let each_1_anchor;
  let each_value_3 = ensure_array_like_dev(
    /*openGraph*/
    ctx8[7].images
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
    each_blocks[i2] = create_each_block_3(get_each_context_3(ctx8, each_value_3, i2));
  }
  const block = {
    c: function create() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128) {
        each_value_3 = ensure_array_like_dev(
          /*openGraph*/
          ctx9[7].images
        );
        let i2;
        for (i2 = 0; i2 < each_value_3.length; i2 += 1) {
          const child_ctx = get_each_context_3(ctx9, each_value_3, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_3(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_3.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_11.name,
    type: "if",
    source: "(209:2) {#if openGraph.images && openGraph.images.length}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_152(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "og:image:alt");
      attr_dev(meta, "content", meta_content_value = /*image*/
      ctx8[24].alt);
      add_location(meta, file42, 212, 5, 7374);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*image*/
      ctx9[24].alt)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_152.name,
    type: "if",
    source: "(212:4) {#if image.alt}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_142(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "og:image:width");
      attr_dev(meta, "content", meta_content_value = /*image*/
      ctx8[24].width.toString());
      add_location(meta, file42, 215, 5, 7464);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*image*/
      ctx9[24].width.toString())) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_142.name,
    type: "if",
    source: "(215:4) {#if image.width}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_132(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "og:image:height");
      attr_dev(meta, "content", meta_content_value = /*image*/
      ctx8[24].height.toString());
      add_location(meta, file42, 218, 5, 7570);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*image*/
      ctx9[24].height.toString())) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_132.name,
    type: "if",
    source: "(218:4) {#if image.height}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_122(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "og:image:secure_url");
      attr_dev(meta, "content", meta_content_value = /*image*/
      ctx8[24].url);
      add_location(meta, file42, 221, 5, 7678);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*image*/
      ctx9[24].url)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_122.name,
    type: "if",
    source: "(221:4) {#if image.secure}",
    ctx: ctx8
  });
  return block;
}
function create_each_block_3(ctx8) {
  let meta;
  let meta_content_value;
  let t0;
  let t1;
  let t2;
  let t3;
  let if_block3_anchor;
  let if_block0 = (
    /*image*/
    ctx8[24].alt && create_if_block_152(ctx8)
  );
  let if_block1 = (
    /*image*/
    ctx8[24].width && create_if_block_142(ctx8)
  );
  let if_block2 = (
    /*image*/
    ctx8[24].height && create_if_block_132(ctx8)
  );
  let if_block3 = (
    /*image*/
    ctx8[24].secure && create_if_block_122(ctx8)
  );
  const block = {
    c: function create() {
      meta = element("meta");
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      if_block3_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      t0 = claim_space(nodes);
      if (if_block0)
        if_block0.l(nodes);
      t1 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t2 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      t3 = claim_space(nodes);
      if (if_block3)
        if_block3.l(nodes);
      if_block3_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "og:image");
      attr_dev(meta, "content", meta_content_value = /*image*/
      ctx8[24].url);
      add_location(meta, file42, 210, 4, 7300);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, t3, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert_hydration_dev(target, if_block3_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*image*/
      ctx9[24].url)) {
        attr_dev(meta, "content", meta_content_value);
      }
      if (
        /*image*/
        ctx9[24].alt
      ) {
        if (if_block0) {
          if_block0.p(ctx9, dirty);
        } else {
          if_block0 = create_if_block_152(ctx9);
          if_block0.c();
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*image*/
        ctx9[24].width
      ) {
        if (if_block1) {
          if_block1.p(ctx9, dirty);
        } else {
          if_block1 = create_if_block_142(ctx9);
          if_block1.c();
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*image*/
        ctx9[24].height
      ) {
        if (if_block2) {
          if_block2.p(ctx9, dirty);
        } else {
          if_block2 = create_if_block_132(ctx9);
          if_block2.c();
          if_block2.m(t3.parentNode, t3);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*image*/
        ctx9[24].secure
      ) {
        if (if_block3) {
          if_block3.p(ctx9, dirty);
        } else {
          if_block3 = create_if_block_122(ctx9);
          if_block3.c();
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
        detach_dev(t3);
        detach_dev(if_block3_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
      if (if_block2)
        if_block2.d(detaching);
      if (if_block3)
        if_block3.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_3.name,
    type: "each",
    source: "(210:3) {#each openGraph.images as image}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_510(ctx8) {
  let each_1_anchor;
  let each_value_2 = ensure_array_like_dev(
    /*openGraph*/
    ctx8[7].videos
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2(get_each_context_2(ctx8, each_value_2, i2));
  }
  const block = {
    c: function create() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128) {
        each_value_2 = ensure_array_like_dev(
          /*openGraph*/
          ctx9[7].videos
        );
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2(ctx9, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_2(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_510.name,
    type: "if",
    source: "(227:2) {#if openGraph.videos && openGraph.videos.length}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_102(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "og:video:alt");
      attr_dev(meta, "content", meta_content_value = /*video*/
      ctx8[21].alt);
      add_location(meta, file42, 230, 5, 7935);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*video*/
      ctx9[21].alt)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_102.name,
    type: "if",
    source: "(230:4) {#if video.alt}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_92(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "og:video:width");
      attr_dev(meta, "content", meta_content_value = /*video*/
      ctx8[21].width.toString());
      add_location(meta, file42, 233, 5, 8025);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*video*/
      ctx9[21].width.toString())) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_92.name,
    type: "if",
    source: "(233:4) {#if video.width}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_82(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "og:video:height");
      attr_dev(meta, "content", meta_content_value = /*video*/
      ctx8[21].height.toString());
      add_location(meta, file42, 236, 5, 8131);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*video*/
      ctx9[21].height.toString())) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_82.name,
    type: "if",
    source: "(236:4) {#if video.height}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_72(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "og:video:secure_url");
      attr_dev(meta, "content", meta_content_value = /*video*/
      ctx8[21].secureUrl.toString());
      add_location(meta, file42, 239, 5, 8242);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*video*/
      ctx9[21].secureUrl.toString())) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_72.name,
    type: "if",
    source: "(239:4) {#if video.secureUrl}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_62(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "og:video:type");
      attr_dev(meta, "content", meta_content_value = /*video*/
      ctx8[21].type.toString());
      add_location(meta, file42, 242, 5, 8355);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*video*/
      ctx9[21].type.toString())) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_62.name,
    type: "if",
    source: "(242:4) {#if video.type}",
    ctx: ctx8
  });
  return block;
}
function create_each_block_2(ctx8) {
  let meta;
  let meta_content_value;
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let if_block4_anchor;
  let if_block0 = (
    /*video*/
    ctx8[21].alt && create_if_block_102(ctx8)
  );
  let if_block1 = (
    /*video*/
    ctx8[21].width && create_if_block_92(ctx8)
  );
  let if_block2 = (
    /*video*/
    ctx8[21].height && create_if_block_82(ctx8)
  );
  let if_block3 = (
    /*video*/
    ctx8[21].secureUrl && create_if_block_72(ctx8)
  );
  let if_block4 = (
    /*video*/
    ctx8[21].type && create_if_block_62(ctx8)
  );
  const block = {
    c: function create() {
      meta = element("meta");
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      t4 = space();
      if (if_block4)
        if_block4.c();
      if_block4_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      t0 = claim_space(nodes);
      if (if_block0)
        if_block0.l(nodes);
      t1 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t2 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      t3 = claim_space(nodes);
      if (if_block3)
        if_block3.l(nodes);
      t4 = claim_space(nodes);
      if (if_block4)
        if_block4.l(nodes);
      if_block4_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "og:video");
      attr_dev(meta, "content", meta_content_value = /*video*/
      ctx8[21].url);
      add_location(meta, file42, 228, 4, 7861);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration_dev(target, t3, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert_hydration_dev(target, t4, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert_hydration_dev(target, if_block4_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*video*/
      ctx9[21].url)) {
        attr_dev(meta, "content", meta_content_value);
      }
      if (
        /*video*/
        ctx9[21].alt
      ) {
        if (if_block0) {
          if_block0.p(ctx9, dirty);
        } else {
          if_block0 = create_if_block_102(ctx9);
          if_block0.c();
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*video*/
        ctx9[21].width
      ) {
        if (if_block1) {
          if_block1.p(ctx9, dirty);
        } else {
          if_block1 = create_if_block_92(ctx9);
          if_block1.c();
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*video*/
        ctx9[21].height
      ) {
        if (if_block2) {
          if_block2.p(ctx9, dirty);
        } else {
          if_block2 = create_if_block_82(ctx9);
          if_block2.c();
          if_block2.m(t3.parentNode, t3);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*video*/
        ctx9[21].secureUrl
      ) {
        if (if_block3) {
          if_block3.p(ctx9, dirty);
        } else {
          if_block3 = create_if_block_72(ctx9);
          if_block3.c();
          if_block3.m(t4.parentNode, t4);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (
        /*video*/
        ctx9[21].type
      ) {
        if (if_block4) {
          if_block4.p(ctx9, dirty);
        } else {
          if_block4 = create_if_block_62(ctx9);
          if_block4.c();
          if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
        detach_dev(t3);
        detach_dev(t4);
        detach_dev(if_block4_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
      if (if_block2)
        if_block2.d(detaching);
      if (if_block3)
        if_block3.d(detaching);
      if (if_block4)
        if_block4.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(228:3) {#each openGraph.videos as video}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_410(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "og:locale");
      attr_dev(meta, "content", meta_content_value = /*openGraph*/
      ctx8[7].locale);
      add_location(meta, file42, 248, 3, 8479);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*openGraph*/
      ctx9[7].locale)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_410.name,
    type: "if",
    source: "(248:2) {#if openGraph.locale}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_310(ctx8) {
  let meta;
  let meta_content_value;
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", { property: true, content: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta, "property", "og:site_name");
      attr_dev(meta, "content", meta_content_value = /*openGraph*/
      ctx8[7].site_name);
      add_location(meta, file42, 252, 3, 8576);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*openGraph*/
      128 && meta_content_value !== (meta_content_value = /*openGraph*/
      ctx9[7].site_name)) {
        attr_dev(meta, "content", meta_content_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_310.name,
    type: "if",
    source: "(252:2) {#if openGraph.site_name}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_120(ctx8) {
  let each_1_anchor;
  let each_value_1 = ensure_array_like_dev(
    /*additionalMetaTags*/
    ctx8[9]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1(get_each_context_1(ctx8, each_value_1, i2));
  }
  const block = {
    c: function create() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*additionalMetaTags*/
      512) {
        each_value_1 = ensure_array_like_dev(
          /*additionalMetaTags*/
          ctx9[9]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1(ctx9, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_120.name,
    type: "if",
    source: "(257:1) {#if additionalMetaTags && additionalMetaTags.length > 0}",
    ctx: ctx8
  });
  return block;
}
function create_each_block_1(ctx8) {
  let meta;
  let meta_levels = [
    /*tag*/
    ctx8[16]
  ];
  let meta_data = {};
  for (let i2 = 0; i2 < meta_levels.length; i2 += 1) {
    meta_data = assign(meta_data, meta_levels[i2]);
  }
  const block = {
    c: function create() {
      meta = element("meta");
      this.h();
    },
    l: function claim(nodes) {
      meta = claim_element(nodes, "META", {});
      this.h();
    },
    h: function hydrate() {
      set_attributes(meta, meta_data);
      add_location(meta, file42, 258, 3, 8753);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, meta, anchor);
    },
    p: function update(ctx9, dirty) {
      set_attributes(meta, meta_data = get_spread_update(meta_levels, [dirty[0] & /*additionalMetaTags*/
      512 && /*tag*/
      ctx9[16]]));
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(meta);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(258:2) {#each additionalMetaTags as tag}",
    ctx: ctx8
  });
  return block;
}
function create_if_block37(ctx8) {
  let each_1_anchor;
  let each_value = ensure_array_like_dev(
    /*additionalLinkTags*/
    ctx8[10]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block7(get_each_context7(ctx8, each_value, i2));
  }
  const block = {
    c: function create() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*additionalLinkTags*/
      1024) {
        each_value = ensure_array_like_dev(
          /*additionalLinkTags*/
          ctx9[10]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context7(ctx9, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block7(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block37.name,
    type: "if",
    source: "(263:1) {#if additionalLinkTags?.length}",
    ctx: ctx8
  });
  return block;
}
function create_each_block7(ctx8) {
  let link;
  let link_levels = [
    /*tag*/
    ctx8[16]
  ];
  let link_data = {};
  for (let i2 = 0; i2 < link_levels.length; i2 += 1) {
    link_data = assign(link_data, link_levels[i2]);
  }
  const block = {
    c: function create() {
      link = element("link");
      this.h();
    },
    l: function claim(nodes) {
      link = claim_element(nodes, "LINK", {});
      this.h();
    },
    h: function hydrate() {
      set_attributes(link, link_data);
      add_location(link, file42, 264, 3, 8862);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, link, anchor);
    },
    p: function update(ctx9, dirty) {
      set_attributes(link, link_data = get_spread_update(link_levels, [dirty[0] & /*additionalLinkTags*/
      1024 && /*tag*/
      ctx9[16]]));
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(link);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block7.name,
    type: "each",
    source: "(264:2) {#each additionalLinkTags as tag}",
    ctx: ctx8
  });
  return block;
}
function create_fragment91(ctx8) {
  var _a;
  let title_value;
  let meta0;
  let meta0_content_value;
  let meta1;
  let meta1_content_value;
  let if_block0_anchor;
  let if_block1_anchor;
  let if_block2_anchor;
  let if_block3_anchor;
  let if_block4_anchor;
  let if_block5_anchor;
  let if_block6_anchor;
  let if_block7_anchor;
  let if_block8_anchor;
  document.title = title_value = /*updatedTitle*/
  ctx8[12];
  let if_block0 = (
    /*description*/
    ctx8[2] && create_if_block_59(ctx8)
  );
  let if_block1 = (
    /*canonical*/
    ctx8[8] && create_if_block_58(ctx8)
  );
  let if_block2 = (
    /*mobileAlternate*/
    ctx8[3] && create_if_block_57(ctx8)
  );
  let if_block3 = (
    /*languageAlternates*/
    ctx8[4] && /*languageAlternates*/
    ctx8[4].length > 0 && create_if_block_56(ctx8)
  );
  let if_block4 = (
    /*twitter*/
    ctx8[5] && create_if_block_48(ctx8)
  );
  let if_block5 = (
    /*facebook*/
    ctx8[6] && create_if_block_47(ctx8)
  );
  let if_block6 = (
    /*openGraph*/
    ctx8[7] && create_if_block_213(ctx8)
  );
  let if_block7 = (
    /*additionalMetaTags*/
    ctx8[9] && /*additionalMetaTags*/
    ctx8[9].length > 0 && create_if_block_120(ctx8)
  );
  let if_block8 = (
    /*additionalLinkTags*/
    ((_a = ctx8[10]) == null ? void 0 : _a.length) && create_if_block37(ctx8)
  );
  const block = {
    c: function create() {
      meta0 = element("meta");
      meta1 = element("meta");
      if (if_block0)
        if_block0.c();
      if_block0_anchor = empty();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
      if (if_block3)
        if_block3.c();
      if_block3_anchor = empty();
      if (if_block4)
        if_block4.c();
      if_block4_anchor = empty();
      if (if_block5)
        if_block5.c();
      if_block5_anchor = empty();
      if (if_block6)
        if_block6.c();
      if_block6_anchor = empty();
      if (if_block7)
        if_block7.c();
      if_block7_anchor = empty();
      if (if_block8)
        if_block8.c();
      if_block8_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      const head_nodes = head_selector("svelte-6di7xa", document.head);
      meta0 = claim_element(head_nodes, "META", { name: true, content: true });
      meta1 = claim_element(head_nodes, "META", { name: true, content: true });
      if (if_block0)
        if_block0.l(head_nodes);
      if_block0_anchor = empty();
      if (if_block1)
        if_block1.l(head_nodes);
      if_block1_anchor = empty();
      if (if_block2)
        if_block2.l(head_nodes);
      if_block2_anchor = empty();
      if (if_block3)
        if_block3.l(head_nodes);
      if_block3_anchor = empty();
      if (if_block4)
        if_block4.l(head_nodes);
      if_block4_anchor = empty();
      if (if_block5)
        if_block5.l(head_nodes);
      if_block5_anchor = empty();
      if (if_block6)
        if_block6.l(head_nodes);
      if_block6_anchor = empty();
      if (if_block7)
        if_block7.l(head_nodes);
      if_block7_anchor = empty();
      if (if_block8)
        if_block8.l(head_nodes);
      if_block8_anchor = empty();
      head_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(meta0, "name", "robots");
      attr_dev(meta0, "content", meta0_content_value = `${/*noindex*/
      ctx8[0] ? "noindex" : "index"},${/*nofollow*/
      ctx8[1] ? "nofollow" : "follow"}${/*robotsParams*/
      ctx8[11]}`);
      add_location(meta0, file42, 30, 1, 1425);
      attr_dev(meta1, "name", "googlebot");
      attr_dev(meta1, "content", meta1_content_value = `${/*noindex*/
      ctx8[0] ? "noindex" : "index"},${/*nofollow*/
      ctx8[1] ? "nofollow" : "follow"}${/*robotsParams*/
      ctx8[11]}`);
      add_location(meta1, file42, 34, 1, 1550);
    },
    m: function mount(target, anchor) {
      append_hydration_dev(document.head, meta0);
      append_hydration_dev(document.head, meta1);
      if (if_block0)
        if_block0.m(document.head, null);
      append_hydration_dev(document.head, if_block0_anchor);
      if (if_block1)
        if_block1.m(document.head, null);
      append_hydration_dev(document.head, if_block1_anchor);
      if (if_block2)
        if_block2.m(document.head, null);
      append_hydration_dev(document.head, if_block2_anchor);
      if (if_block3)
        if_block3.m(document.head, null);
      append_hydration_dev(document.head, if_block3_anchor);
      if (if_block4)
        if_block4.m(document.head, null);
      append_hydration_dev(document.head, if_block4_anchor);
      if (if_block5)
        if_block5.m(document.head, null);
      append_hydration_dev(document.head, if_block5_anchor);
      if (if_block6)
        if_block6.m(document.head, null);
      append_hydration_dev(document.head, if_block6_anchor);
      if (if_block7)
        if_block7.m(document.head, null);
      append_hydration_dev(document.head, if_block7_anchor);
      if (if_block8)
        if_block8.m(document.head, null);
      append_hydration_dev(document.head, if_block8_anchor);
    },
    p: function update(ctx9, dirty) {
      var _a2;
      if (dirty[0] & /*updatedTitle*/
      4096 && title_value !== (title_value = /*updatedTitle*/
      ctx9[12])) {
        document.title = title_value;
      }
      if (dirty[0] & /*noindex, nofollow, robotsParams*/
      2051 && meta0_content_value !== (meta0_content_value = `${/*noindex*/
      ctx9[0] ? "noindex" : "index"},${/*nofollow*/
      ctx9[1] ? "nofollow" : "follow"}${/*robotsParams*/
      ctx9[11]}`)) {
        attr_dev(meta0, "content", meta0_content_value);
      }
      if (dirty[0] & /*noindex, nofollow, robotsParams*/
      2051 && meta1_content_value !== (meta1_content_value = `${/*noindex*/
      ctx9[0] ? "noindex" : "index"},${/*nofollow*/
      ctx9[1] ? "nofollow" : "follow"}${/*robotsParams*/
      ctx9[11]}`)) {
        attr_dev(meta1, "content", meta1_content_value);
      }
      if (
        /*description*/
        ctx9[2]
      ) {
        if (if_block0) {
          if_block0.p(ctx9, dirty);
        } else {
          if_block0 = create_if_block_59(ctx9);
          if_block0.c();
          if_block0.m(if_block0_anchor.parentNode, if_block0_anchor);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*canonical*/
        ctx9[8]
      ) {
        if (if_block1) {
          if_block1.p(ctx9, dirty);
        } else {
          if_block1 = create_if_block_58(ctx9);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*mobileAlternate*/
        ctx9[3]
      ) {
        if (if_block2) {
          if_block2.p(ctx9, dirty);
        } else {
          if_block2 = create_if_block_57(ctx9);
          if_block2.c();
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*languageAlternates*/
        ctx9[4] && /*languageAlternates*/
        ctx9[4].length > 0
      ) {
        if (if_block3) {
          if_block3.p(ctx9, dirty);
        } else {
          if_block3 = create_if_block_56(ctx9);
          if_block3.c();
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (
        /*twitter*/
        ctx9[5]
      ) {
        if (if_block4) {
          if_block4.p(ctx9, dirty);
        } else {
          if_block4 = create_if_block_48(ctx9);
          if_block4.c();
          if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (
        /*facebook*/
        ctx9[6]
      ) {
        if (if_block5) {
          if_block5.p(ctx9, dirty);
        } else {
          if_block5 = create_if_block_47(ctx9);
          if_block5.c();
          if_block5.m(if_block5_anchor.parentNode, if_block5_anchor);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
      if (
        /*openGraph*/
        ctx9[7]
      ) {
        if (if_block6) {
          if_block6.p(ctx9, dirty);
        } else {
          if_block6 = create_if_block_213(ctx9);
          if_block6.c();
          if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
        }
      } else if (if_block6) {
        if_block6.d(1);
        if_block6 = null;
      }
      if (
        /*additionalMetaTags*/
        ctx9[9] && /*additionalMetaTags*/
        ctx9[9].length > 0
      ) {
        if (if_block7) {
          if_block7.p(ctx9, dirty);
        } else {
          if_block7 = create_if_block_120(ctx9);
          if_block7.c();
          if_block7.m(if_block7_anchor.parentNode, if_block7_anchor);
        }
      } else if (if_block7) {
        if_block7.d(1);
        if_block7 = null;
      }
      if (
        /*additionalLinkTags*/
        (_a2 = ctx9[10]) == null ? void 0 : _a2.length
      ) {
        if (if_block8) {
          if_block8.p(ctx9, dirty);
        } else {
          if_block8 = create_if_block37(ctx9);
          if_block8.c();
          if_block8.m(if_block8_anchor.parentNode, if_block8_anchor);
        }
      } else if (if_block8) {
        if_block8.d(1);
        if_block8 = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      detach_dev(meta0);
      detach_dev(meta1);
      if (if_block0)
        if_block0.d(detaching);
      detach_dev(if_block0_anchor);
      if (if_block1)
        if_block1.d(detaching);
      detach_dev(if_block1_anchor);
      if (if_block2)
        if_block2.d(detaching);
      detach_dev(if_block2_anchor);
      if (if_block3)
        if_block3.d(detaching);
      detach_dev(if_block3_anchor);
      if (if_block4)
        if_block4.d(detaching);
      detach_dev(if_block4_anchor);
      if (if_block5)
        if_block5.d(detaching);
      detach_dev(if_block5_anchor);
      if (if_block6)
        if_block6.d(detaching);
      detach_dev(if_block6_anchor);
      if (if_block7)
        if_block7.d(detaching);
      detach_dev(if_block7_anchor);
      if (if_block8)
        if_block8.d(detaching);
      detach_dev(if_block8_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment91.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance91($$self, $$props, $$invalidate) {
  let updatedTitle;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Seo", slots, []);
  let { title = "" } = $$props;
  let { titleTemplate = "" } = $$props;
  let { noindex = false } = $$props;
  let { nofollow = false } = $$props;
  let { robotsProps = void 0 } = $$props;
  let { description = void 0 } = $$props;
  let { mobileAlternate = void 0 } = $$props;
  let { languageAlternates = void 0 } = $$props;
  let { twitter = void 0 } = $$props;
  let { facebook = void 0 } = $$props;
  let { openGraph = void 0 } = $$props;
  let { canonical = void 0 } = $$props;
  let { additionalMetaTags = void 0 } = $$props;
  let { additionalLinkTags = void 0 } = $$props;
  let robotsParams = "";
  if (robotsProps) {
    const { nosnippet, maxSnippet, maxImagePreview, maxVideoPreview, noarchive, noimageindex, notranslate, unavailableAfter } = robotsProps;
    robotsParams = `${nosnippet ? ",nosnippet" : ""}${maxSnippet ? `,max-snippet:${maxSnippet}` : ""}${maxImagePreview ? `,max-image-preview:${maxImagePreview}` : ""}${noarchive ? ",noarchive" : ""}${unavailableAfter ? `,unavailable_after:${unavailableAfter}` : ""}${noimageindex ? ",noimageindex" : ""}${maxVideoPreview ? `,max-video-preview:${maxVideoPreview}` : ""}${notranslate ? ",notranslate" : ""}`;
  }
  const writable_props = [
    "title",
    "titleTemplate",
    "noindex",
    "nofollow",
    "robotsProps",
    "description",
    "mobileAlternate",
    "languageAlternates",
    "twitter",
    "facebook",
    "openGraph",
    "canonical",
    "additionalMetaTags",
    "additionalLinkTags"
  ];
  Object.keys($$props).forEach((key3) => {
    if (!~writable_props.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<Seo> was created with unknown prop '${key3}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(13, title = $$props2.title);
    if ("titleTemplate" in $$props2)
      $$invalidate(14, titleTemplate = $$props2.titleTemplate);
    if ("noindex" in $$props2)
      $$invalidate(0, noindex = $$props2.noindex);
    if ("nofollow" in $$props2)
      $$invalidate(1, nofollow = $$props2.nofollow);
    if ("robotsProps" in $$props2)
      $$invalidate(15, robotsProps = $$props2.robotsProps);
    if ("description" in $$props2)
      $$invalidate(2, description = $$props2.description);
    if ("mobileAlternate" in $$props2)
      $$invalidate(3, mobileAlternate = $$props2.mobileAlternate);
    if ("languageAlternates" in $$props2)
      $$invalidate(4, languageAlternates = $$props2.languageAlternates);
    if ("twitter" in $$props2)
      $$invalidate(5, twitter = $$props2.twitter);
    if ("facebook" in $$props2)
      $$invalidate(6, facebook = $$props2.facebook);
    if ("openGraph" in $$props2)
      $$invalidate(7, openGraph = $$props2.openGraph);
    if ("canonical" in $$props2)
      $$invalidate(8, canonical = $$props2.canonical);
    if ("additionalMetaTags" in $$props2)
      $$invalidate(9, additionalMetaTags = $$props2.additionalMetaTags);
    if ("additionalLinkTags" in $$props2)
      $$invalidate(10, additionalLinkTags = $$props2.additionalLinkTags);
  };
  $$self.$capture_state = () => ({
    title,
    titleTemplate,
    noindex,
    nofollow,
    robotsProps,
    description,
    mobileAlternate,
    languageAlternates,
    twitter,
    facebook,
    openGraph,
    canonical,
    additionalMetaTags,
    additionalLinkTags,
    robotsParams,
    updatedTitle
  });
  $$self.$inject_state = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(13, title = $$props2.title);
    if ("titleTemplate" in $$props2)
      $$invalidate(14, titleTemplate = $$props2.titleTemplate);
    if ("noindex" in $$props2)
      $$invalidate(0, noindex = $$props2.noindex);
    if ("nofollow" in $$props2)
      $$invalidate(1, nofollow = $$props2.nofollow);
    if ("robotsProps" in $$props2)
      $$invalidate(15, robotsProps = $$props2.robotsProps);
    if ("description" in $$props2)
      $$invalidate(2, description = $$props2.description);
    if ("mobileAlternate" in $$props2)
      $$invalidate(3, mobileAlternate = $$props2.mobileAlternate);
    if ("languageAlternates" in $$props2)
      $$invalidate(4, languageAlternates = $$props2.languageAlternates);
    if ("twitter" in $$props2)
      $$invalidate(5, twitter = $$props2.twitter);
    if ("facebook" in $$props2)
      $$invalidate(6, facebook = $$props2.facebook);
    if ("openGraph" in $$props2)
      $$invalidate(7, openGraph = $$props2.openGraph);
    if ("canonical" in $$props2)
      $$invalidate(8, canonical = $$props2.canonical);
    if ("additionalMetaTags" in $$props2)
      $$invalidate(9, additionalMetaTags = $$props2.additionalMetaTags);
    if ("additionalLinkTags" in $$props2)
      $$invalidate(10, additionalLinkTags = $$props2.additionalLinkTags);
    if ("robotsParams" in $$props2)
      $$invalidate(11, robotsParams = $$props2.robotsParams);
    if ("updatedTitle" in $$props2)
      $$invalidate(12, updatedTitle = $$props2.updatedTitle);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*titleTemplate, title*/
    24576) {
      $:
        $$invalidate(12, updatedTitle = titleTemplate ? titleTemplate.replace(/%t%/g, title) : title);
    }
  };
  return [
    noindex,
    nofollow,
    description,
    mobileAlternate,
    languageAlternates,
    twitter,
    facebook,
    openGraph,
    canonical,
    additionalMetaTags,
    additionalLinkTags,
    robotsParams,
    updatedTitle,
    title,
    titleTemplate,
    robotsProps
  ];
}
var Seo = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance91,
      create_fragment91,
      safe_not_equal,
      {
        title: 13,
        titleTemplate: 14,
        noindex: 0,
        nofollow: 1,
        robotsProps: 15,
        description: 2,
        mobileAlternate: 3,
        languageAlternates: 4,
        twitter: 5,
        facebook: 6,
        openGraph: 7,
        canonical: 8,
        additionalMetaTags: 9,
        additionalLinkTags: 10
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Seo",
      options,
      id: create_fragment91.name
    });
  }
  get title() {
    throw new Error("<Seo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Seo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleTemplate() {
    throw new Error("<Seo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleTemplate(value) {
    throw new Error("<Seo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noindex() {
    throw new Error("<Seo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noindex(value) {
    throw new Error("<Seo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nofollow() {
    throw new Error("<Seo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nofollow(value) {
    throw new Error("<Seo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get robotsProps() {
    throw new Error("<Seo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set robotsProps(value) {
    throw new Error("<Seo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get description() {
    throw new Error("<Seo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set description(value) {
    throw new Error("<Seo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mobileAlternate() {
    throw new Error("<Seo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mobileAlternate(value) {
    throw new Error("<Seo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get languageAlternates() {
    throw new Error("<Seo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set languageAlternates(value) {
    throw new Error("<Seo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get twitter() {
    throw new Error("<Seo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set twitter(value) {
    throw new Error("<Seo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get facebook() {
    throw new Error("<Seo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set facebook(value) {
    throw new Error("<Seo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get openGraph() {
    throw new Error("<Seo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set openGraph(value) {
    throw new Error("<Seo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get canonical() {
    throw new Error("<Seo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set canonical(value) {
    throw new Error("<Seo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get additionalMetaTags() {
    throw new Error("<Seo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set additionalMetaTags(value) {
    throw new Error("<Seo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get additionalLinkTags() {
    throw new Error("<Seo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set additionalLinkTags(value) {
    throw new Error("<Seo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Seo_default = Seo;

// node_modules/@svelteuidev/core/dist/components/SimpleGrid/get-sorted-breakpoints.js
var theme3 = {
  spacing: {
    xs: 10,
    sm: 12,
    md: 16,
    lg: 20,
    xl: 24
  },
  breakpoints: {
    xs: 576,
    sm: 768,
    md: 992,
    lg: 1200,
    xl: 1400
  }
};
function size2(props) {
  if (typeof props.size === "number") {
    return props.size;
  }
  return props.sizes[props.size] || props.size || props.sizes.md;
}
function getSortedBreakpoints2(theme4, breakpoints) {
  if (breakpoints.length === 0) {
    return breakpoints;
  }
  const property = "maxWidth" in breakpoints[0] ? "maxWidth" : "minWidth";
  const sorted = [...breakpoints].sort((a, b) => size2({ size: b[property], sizes: theme4.breakpoints }) - size2({ size: a[property], sizes: theme4.breakpoints }));
  return property === "minWidth" ? sorted.reverse() : sorted;
}

// node_modules/@svelteuidev/core/dist/components/SimpleGrid/SimpleGrid.styles.js
var SimpleGrid_styles_default = createStyles((theme4, { cols, spacing, gridBreakpoints }) => {
  return {
    root: {
      boxSizing: "border-box",
      display: "grid",
      gridTemplateColumns: `repeat(${cols}, minmax(0, 1fr))`,
      gap: theme4.fn.size({ size: spacing, sizes: theme4.space }),
      ...gridBreakpoints
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/SimpleGrid/SimpleGrid.svelte
function create_default_slot68(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[14],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[14],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot68.name,
    type: "slot",
    source: "(38:0) <Box  bind:element  {use}  class={cx(className, classes.root, getStyles({ css: override }))}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment92(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { use: (
      /*use*/
      ctx8[1]
    ) },
    {
      class: (
        /*cx*/
        ctx8[6](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[5].root,
          /*getStyles*/
          ctx8[4]({ css: (
            /*override*/
            ctx8[3]
          ) })
        )
      )
    },
    /*$$restProps*/
    ctx8[7]
  ];
  function box_element_binding(value) {
    ctx8[13](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot68] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*use, cx, className, classes, getStyles, override, $$restProps*/
      254 ? get_spread_update(box_spread_levels, [
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*cx, className, classes, getStyles, override*/
        124 && {
          class: (
            /*cx*/
            ctx9[6](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[5].root,
              /*getStyles*/
              ctx9[4]({ css: (
                /*override*/
                ctx9[3]
              ) })
            )
          )
        },
        dirty & /*$$restProps*/
        128 && get_spread_object(
          /*$$restProps*/
          ctx9[7]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      16384) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment92.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance92($$self, $$props, $$invalidate) {
  let gridBreakpoints;
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = ["use", "element", "class", "override", "breakpoints", "cols", "spacing"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SimpleGrid", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, breakpoints = [], cols = 1, spacing = "md" } = $$props;
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("breakpoints" in $$new_props)
      $$invalidate(8, breakpoints = $$new_props.breakpoints);
    if ("cols" in $$new_props)
      $$invalidate(9, cols = $$new_props.cols);
    if ("spacing" in $$new_props)
      $$invalidate(10, spacing = $$new_props.spacing);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Box: Box_default,
    getSortedBreakpoints: getSortedBreakpoints2,
    size: size2,
    theme: theme3,
    useStyles: SimpleGrid_styles_default,
    use,
    element: element2,
    className,
    override,
    breakpoints,
    cols,
    spacing,
    gridBreakpoints,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("breakpoints" in $$props)
      $$invalidate(8, breakpoints = $$new_props.breakpoints);
    if ("cols" in $$props)
      $$invalidate(9, cols = $$new_props.cols);
    if ("spacing" in $$props)
      $$invalidate(10, spacing = $$new_props.spacing);
    if ("gridBreakpoints" in $$props)
      $$invalidate(11, gridBreakpoints = $$new_props.gridBreakpoints);
    if ("getStyles" in $$props)
      $$invalidate(4, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(5, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(6, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*breakpoints, spacing*/
    1280) {
      $:
        $$invalidate(11, gridBreakpoints = getSortedBreakpoints2(theme3, breakpoints).reduce(
          (acc, breakpoint) => {
            const property = "maxWidth" in breakpoint ? "max-width" : "min-width";
            const breakpointSize = size2({
              size: property === "max-width" ? breakpoint.maxWidth : breakpoint.minWidth,
              sizes: theme3.breakpoints
            });
            acc[`@media (${property}: ${breakpointSize + (property === "max-width" ? 0 : 1)}px)`] = {
              gridTemplateColumns: `repeat(${breakpoint.cols}, minmax(0, 1fr))`,
              gap: size2({
                size: breakpoint.spacing || spacing,
                sizes: theme3.spacing
              })
            };
            return acc;
          },
          {}
        ));
    }
    if ($$self.$$.dirty & /*cols, spacing, gridBreakpoints*/
    3584) {
      $:
        $$invalidate(6, { cx: cx2, classes, getStyles } = SimpleGrid_styles_default({ cols, spacing, gridBreakpoints }, { name: "SimpleGrid" }), cx2, ($$invalidate(5, classes), $$invalidate(9, cols), $$invalidate(10, spacing), $$invalidate(11, gridBreakpoints), $$invalidate(8, breakpoints)), ($$invalidate(4, getStyles), $$invalidate(9, cols), $$invalidate(10, spacing), $$invalidate(11, gridBreakpoints), $$invalidate(8, breakpoints)));
    }
  };
  return [
    element2,
    use,
    className,
    override,
    getStyles,
    classes,
    cx2,
    $$restProps,
    breakpoints,
    cols,
    spacing,
    gridBreakpoints,
    slots,
    box_element_binding,
    $$scope
  ];
}
var SimpleGrid = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance92, create_fragment92, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      breakpoints: 8,
      cols: 9,
      spacing: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SimpleGrid",
      options,
      id: create_fragment92.name
    });
  }
  get use() {
    throw new Error("<SimpleGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<SimpleGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<SimpleGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<SimpleGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<SimpleGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<SimpleGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<SimpleGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<SimpleGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get breakpoints() {
    throw new Error("<SimpleGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set breakpoints(value) {
    throw new Error("<SimpleGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cols() {
    throw new Error("<SimpleGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cols(value) {
    throw new Error("<SimpleGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<SimpleGrid>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<SimpleGrid>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SimpleGrid_default = SimpleGrid;

// node_modules/@svelteuidev/core/dist/components/Space/Space.styles.js
var Space_styles_default = createStyles((theme4, { h, w }) => {
  return {
    root: {
      width: theme4.fn.size({ size: w, sizes: theme4.space }),
      minWidth: theme4.fn.size({ size: w, sizes: theme4.space }),
      height: theme4.fn.size({ size: h, sizes: theme4.space }),
      minHeight: theme4.fn.size({ size: h, sizes: theme4.space })
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Space/Space.svelte
function create_default_slot69(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[12],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[12],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot69.name,
    type: "slot",
    source: "(21:0) <Box  bind:element  {use}  class={cx(className, classes.root, getStyles({ css: override }))}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment93(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { use: (
      /*use*/
      ctx8[1]
    ) },
    {
      class: (
        /*cx*/
        ctx8[6](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[5].root,
          /*getStyles*/
          ctx8[4]({ css: (
            /*override*/
            ctx8[3]
          ) })
        )
      )
    },
    /*$$restProps*/
    ctx8[7]
  ];
  function box_element_binding(value) {
    ctx8[11](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot69] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*use, cx, className, classes, getStyles, override, $$restProps*/
      254 ? get_spread_update(box_spread_levels, [
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*cx, className, classes, getStyles, override*/
        124 && {
          class: (
            /*cx*/
            ctx9[6](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[5].root,
              /*getStyles*/
              ctx9[4]({ css: (
                /*override*/
                ctx9[3]
              ) })
            )
          )
        },
        dirty & /*$$restProps*/
        128 && get_spread_object(
          /*$$restProps*/
          ctx9[7]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      4096) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment93.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance93($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = ["use", "element", "class", "override", "w", "h"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Space", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, w = 0, h = 0 } = $$props;
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("w" in $$new_props)
      $$invalidate(8, w = $$new_props.w);
    if ("h" in $$new_props)
      $$invalidate(9, h = $$new_props.h);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Box: Box_default,
    useStyles: Space_styles_default,
    use,
    element: element2,
    className,
    override,
    w,
    h,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("w" in $$props)
      $$invalidate(8, w = $$new_props.w);
    if ("h" in $$props)
      $$invalidate(9, h = $$new_props.h);
    if ("getStyles" in $$props)
      $$invalidate(4, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(5, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(6, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*h, w*/
    768) {
      $:
        $$invalidate(6, { cx: cx2, classes, getStyles } = Space_styles_default({ h, w }, { name: "Space" }), cx2, ($$invalidate(5, classes), $$invalidate(9, h), $$invalidate(8, w)), ($$invalidate(4, getStyles), $$invalidate(9, h), $$invalidate(8, w)));
    }
  };
  return [
    element2,
    use,
    className,
    override,
    getStyles,
    classes,
    cx2,
    $$restProps,
    w,
    h,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Space = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance93, create_fragment93, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      w: 8,
      h: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Space",
      options,
      id: create_fragment93.name
    });
  }
  get use() {
    throw new Error("<Space>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Space>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Space>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Space>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Space>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Space>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Space>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Space>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get w() {
    throw new Error("<Space>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set w(value) {
    throw new Error("<Space>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get h() {
    throw new Error("<Space>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set h(value) {
    throw new Error("<Space>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Space_default = Space;

// node_modules/@svelteuidev/core/dist/components/Stack/Stack.styles.js
var Stack_styles_default = createStyles((theme4, { align, justify, spacing }) => {
  return {
    root: {
      display: "flex",
      flexDirection: "column",
      alignItems: `${align}`,
      justifyContent: `${justify}`,
      gap: theme4.fn.size({ size: spacing, sizes: theme4.space })
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Stack/Stack.svelte
function create_default_slot70(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[13],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[13],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot70.name,
    type: "slot",
    source: "(24:0) <Box  bind:element  {use}  class={cx(className, classes.root, getStyles({ css: override }))}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment94(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { use: (
      /*use*/
      ctx8[1]
    ) },
    {
      class: (
        /*cx*/
        ctx8[6](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[5].root,
          /*getStyles*/
          ctx8[4]({ css: (
            /*override*/
            ctx8[3]
          ) })
        )
      )
    },
    /*$$restProps*/
    ctx8[7]
  ];
  function box_element_binding(value) {
    ctx8[12](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot70] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*use, cx, className, classes, getStyles, override, $$restProps*/
      254 ? get_spread_update(box_spread_levels, [
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*cx, className, classes, getStyles, override*/
        124 && {
          class: (
            /*cx*/
            ctx9[6](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[5].root,
              /*getStyles*/
              ctx9[4]({ css: (
                /*override*/
                ctx9[3]
              ) })
            )
          )
        },
        dirty & /*$$restProps*/
        128 && get_spread_object(
          /*$$restProps*/
          ctx9[7]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      8192) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment94.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance94($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = ["use", "element", "class", "override", "spacing", "align", "justify"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Stack", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, spacing = "md", align = "stretch", justify = "center" } = $$props;
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("spacing" in $$new_props)
      $$invalidate(8, spacing = $$new_props.spacing);
    if ("align" in $$new_props)
      $$invalidate(9, align = $$new_props.align);
    if ("justify" in $$new_props)
      $$invalidate(10, justify = $$new_props.justify);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Box: Box_default,
    useStyles: Stack_styles_default,
    use,
    element: element2,
    className,
    override,
    spacing,
    align,
    justify,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("spacing" in $$props)
      $$invalidate(8, spacing = $$new_props.spacing);
    if ("align" in $$props)
      $$invalidate(9, align = $$new_props.align);
    if ("justify" in $$props)
      $$invalidate(10, justify = $$new_props.justify);
    if ("getStyles" in $$props)
      $$invalidate(4, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(5, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(6, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*align, justify, spacing*/
    1792) {
      $:
        $$invalidate(6, { cx: cx2, classes, getStyles } = Stack_styles_default({ align, justify, spacing }, { name: "Stack" }), cx2, ($$invalidate(5, classes), $$invalidate(9, align), $$invalidate(10, justify), $$invalidate(8, spacing)), ($$invalidate(4, getStyles), $$invalidate(9, align), $$invalidate(10, justify), $$invalidate(8, spacing)));
    }
  };
  return [
    element2,
    use,
    className,
    override,
    getStyles,
    classes,
    cx2,
    $$restProps,
    spacing,
    align,
    justify,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Stack = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance94, create_fragment94, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      spacing: 8,
      align: 9,
      justify: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Stack",
      options,
      id: create_fragment94.name
    });
  }
  get use() {
    throw new Error("<Stack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Stack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Stack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Stack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Stack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Stack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Stack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Stack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<Stack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<Stack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<Stack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<Stack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get justify() {
    throw new Error("<Stack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set justify(value) {
    throw new Error("<Stack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Stack_default = Stack;

// node_modules/@svelteuidev/core/dist/components/Stack/Stack.errors.js
var Stack_errors_exports = {};
__export(Stack_errors_exports, {
  StackErrors: () => StackErrors
});
var StackErrors = Object.freeze([
  {
    error: true,
    message: "Message",
    solution: `
                If your component looks like this:
                
                &lt;Stack&gt; Button Text &lt;/Stack&gt;
                        ^^^^^^^^ - Try removing this
                `
  }
]);

// node_modules/@svelteuidev/core/dist/components/Switch/Switch.styles.js
var radii = {
  xs: 2,
  sm: 4,
  md: 8,
  lg: 16,
  xl: 32
};
var sizes14 = {
  xs: {
    height: 16,
    width: 30,
    handle: 12,
    labelFont: 12,
    insideLabelFont: 5
  },
  sm: {
    height: 20,
    width: 38,
    handle: 14,
    labelFont: 14,
    insideLabelFont: 6
  },
  md: {
    height: 24,
    width: 46,
    handle: 18,
    labelFont: 16,
    insideLabelFont: 7
  },
  lg: {
    height: 30,
    width: 56,
    handle: 22,
    labelFont: 18,
    insideLabelFont: 9
  },
  xl: {
    height: 36,
    width: 68,
    handle: 28,
    labelFont: 20,
    insideLabelFont: 11
  }
};
var Switch_styles_default = createStyles((theme4, { radius: radius2, size: size3, transitionFunction, color, offLabel, onLabel, insideLabelSize }) => {
  return {
    root: {
      display: "flex",
      alignItems: "center"
    },
    input: {
      focusRing: "auto",
      overflow: "hidden",
      WebkitTapHighlightColor: "transparent",
      position: "relative",
      borderRadius: radii[radius2],
      backgroundColor: theme4.fn.themeColor("gray", 2),
      border: `1px solid ${theme4.fn.themeColor("gray", 3)}`,
      height: sizes14[size3].height,
      width: sizes14[size3].width,
      minWidth: sizes14[size3].width,
      margin: 0,
      transitionProperty: "background-color, border-color",
      transitionTimingFunction: transitionFunction,
      transitionDuration: "150ms",
      boxSizing: "border-box",
      appearance: "none",
      display: "flex",
      alignItems: "center",
      fontSize: insideLabelSize || sizes14[size3].insideLabelFont,
      fontWeight: 600,
      [`${dark.selector} &`]: {
        backgroundColor: theme4.fn.themeColor("dark", 6),
        borderColor: theme4.fn.themeColor("dark", 4)
      },
      "&:hover": { cursor: "pointer" },
      "&::before": {
        zIndex: 1,
        borderRadius: radii[radius2],
        boxSizing: "border-box",
        content: "''",
        display: "block",
        backgroundColor: "White",
        border: `1px solid ${theme4.fn.themeColor("gray", 3)}`,
        height: sizes14[size3].handle,
        width: sizes14[size3].handle,
        transition: `transform 150ms ${transitionFunction}`,
        transform: `translateX(${size3 === "xs" ? 1 : 2}px)`,
        "@media (prefers-reduced-motion)": {
          transitionDuration: "0ms"
        },
        [`${dark.selector} &`]: {
          borderColor: "White"
        }
      },
      "&::after": {
        position: "absolute",
        zIndex: 0,
        display: "flex",
        height: "100%",
        alignItems: "center",
        lineHeight: 0,
        right: "10%",
        transform: "translateX(0)",
        content: offLabel ? `'${offLabel}'` : "''",
        color: theme4.fn.themeColor("gray", 6),
        transition: `color 150ms ${transitionFunction}`,
        [`${dark.selector} &`]: {
          color: theme4.fn.themeColor("dark", 1)
        }
      },
      "&:checked": {
        backgroundColor: theme4.fn.themeColor(color, 6),
        borderColor: theme4.fn.themeColor(color, 6),
        "&::before": {
          transform: `translateX(${sizes14[size3].width - sizes14[size3].handle - (size3 === "xs" ? 3 : 4)}px)`,
          borderColor: "White"
        },
        "&::after": {
          left: "10%",
          content: onLabel ? `'${onLabel}'` : "''",
          color: "White"
        }
      },
      "&.disabled": {
        backgroundColor: theme4.fn.themeColor("gray", 2),
        borderColor: theme4.fn.themeColor("gray", 2),
        cursor: "not-allowed",
        [`${dark.selector} &`]: {
          backgroundColor: theme4.fn.themeColor("dark", 4),
          borderColor: theme4.fn.themeColor("dark", 3)
        },
        "&::before": {
          borderColor: theme4.fn.themeColor("gray", 2),
          backgroundColor: theme4.fn.themeColor("gray", 0),
          [`${dark.selector} &`]: {
            backgroundColor: theme4.fn.themeColor("dark", 3),
            borderColor: theme4.fn.themeColor("dark", 4)
          }
        }
      }
    },
    label: {
      fontSize: sizes14[size3].labelFont,
      lineHeight: `${sizes14[size3].height}px`,
      fontWeight: 600,
      paddingLeft: theme4.fn.size({ size: "sm", sizes: theme4.space })
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Switch/Switch.svelte
var file43 = "node_modules/@svelteuidev/core/dist/components/Switch/Switch.svelte";
function add_css4(target) {
  append_styles(target, "svelte-1oesh6k", ".switch.svelte-1oesh6k{display:flex;flex-direction:row;align-items:center}.label.svelte-1oesh6k{padding-left:10px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3dpdGNoLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyIvVXNlcnMvbWFudmlzaW5naGFsL0RvY3VtZW50cy9HaXRIdWIvYmFja3BhY2trLXN2ZWx0ZS9ub2RlX21vZHVsZXMvQHN2ZWx0ZXVpZGV2L2NvcmUvZGlzdC9jb21wb25lbnRzL1N3aXRjaC9Td2l0Y2guc3ZlbHRlIl19 */");
}
function create_if_block38(ctx8) {
  let label_1;
  let t;
  let label_1_class_value;
  const block = {
    c: function create() {
      label_1 = element("label");
      t = text(
        /*label*/
        ctx8[6]
      );
      this.h();
    },
    l: function claim(nodes) {
      label_1 = claim_element(nodes, "LABEL", { for: true, class: true });
      var label_1_nodes = children(label_1);
      t = claim_text(
        label_1_nodes,
        /*label*/
        ctx8[6]
      );
      label_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        label_1,
        "for",
        /*id*/
        ctx8[5]
      );
      attr_dev(label_1, "class", label_1_class_value = null_to_empty(
        /*classes*/
        ctx8[9].label
      ) + " svelte-1oesh6k");
      add_location(label_1, file43, 44, 2, 1432);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label_1, anchor);
      append_hydration_dev(label_1, t);
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*label*/
      64)
        set_data_dev(
          t,
          /*label*/
          ctx9[6]
        );
      if (dirty & /*id*/
      32) {
        attr_dev(
          label_1,
          "for",
          /*id*/
          ctx9[5]
        );
      }
      if (dirty & /*classes*/
      512 && label_1_class_value !== (label_1_class_value = null_to_empty(
        /*classes*/
        ctx9[9].label
      ) + " svelte-1oesh6k")) {
        attr_dev(label_1, "class", label_1_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block38.name,
    type: "if",
    source: "(44:1) {#if label}",
    ctx: ctx8
  });
  return block;
}
function create_fragment95(ctx8) {
  let div;
  let input;
  let input_class_value;
  let useActions_action;
  let forwardEvents_action;
  let t;
  let div_class_value;
  let mounted;
  let dispose;
  let if_block = (
    /*label*/
    ctx8[6] && create_if_block38(ctx8)
  );
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      input = claim_element(div_nodes, "INPUT", { id: true, type: true, class: true });
      t = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        input,
        "id",
        /*id*/
        ctx8[5]
      );
      input.disabled = /*disabled*/
      ctx8[7];
      attr_dev(input, "type", "checkbox");
      attr_dev(input, "class", input_class_value = null_to_empty(
        /*cx*/
        ctx8[10](
          /*className*/
          ctx8[3],
          /*classes*/
          ctx8[9].input,
          /*getStyles*/
          ctx8[8]({ css: (
            /*override*/
            ctx8[4]
          ) })
        )
      ) + " svelte-1oesh6k");
      toggle_class(
        input,
        "disabled",
        /*disabled*/
        ctx8[7]
      );
      add_location(input, file43, 32, 1, 1202);
      attr_dev(div, "class", div_class_value = null_to_empty(
        /*cx*/
        ctx8[10](
          /*className*/
          ctx8[3],
          /*classes*/
          ctx8[9].root
        )
      ) + " svelte-1oesh6k");
      add_location(div, file43, 31, 0, 1159);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, input);
      ctx8[19](input);
      input.checked = /*checked*/
      ctx8[1];
      append_hydration_dev(div, t);
      if (if_block)
        if_block.m(div, null);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            input,
            /*use*/
            ctx8[2]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx8[11].call(null, input)),
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx8[20]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx9, [dirty]) {
      if (dirty & /*id*/
      32) {
        attr_dev(
          input,
          "id",
          /*id*/
          ctx9[5]
        );
      }
      if (dirty & /*disabled*/
      128) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx9[7]
        );
      }
      if (dirty & /*cx, className, classes, getStyles, override*/
      1816 && input_class_value !== (input_class_value = null_to_empty(
        /*cx*/
        ctx9[10](
          /*className*/
          ctx9[3],
          /*classes*/
          ctx9[9].input,
          /*getStyles*/
          ctx9[8]({ css: (
            /*override*/
            ctx9[4]
          ) })
        )
      ) + " svelte-1oesh6k")) {
        attr_dev(input, "class", input_class_value);
      }
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      4)
        useActions_action.update.call(
          null,
          /*use*/
          ctx9[2]
        );
      if (dirty & /*checked*/
      2) {
        input.checked = /*checked*/
        ctx9[1];
      }
      if (dirty & /*cx, className, classes, getStyles, override, disabled*/
      1944) {
        toggle_class(
          input,
          "disabled",
          /*disabled*/
          ctx9[7]
        );
      }
      if (
        /*label*/
        ctx9[6]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
        } else {
          if_block = create_if_block38(ctx9);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*cx, className, classes*/
      1544 && div_class_value !== (div_class_value = null_to_empty(
        /*cx*/
        ctx9[10](
          /*className*/
          ctx9[3],
          /*classes*/
          ctx9[9].root
        )
      ) + " svelte-1oesh6k")) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      ctx8[19](null);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment95.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance95($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Switch", slots, []);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, color = "blue", size: size3 = "sm", radius: radius2 = "xl", insideLabelSize = void 0, transitionFunction = "linear", id = randomID(), label = "", onLabel = "", offLabel = "", disabled = false, checked = false } = $$props;
  const forwardEvents = createEventForwarder(get_current_component());
  const writable_props = [
    "use",
    "element",
    "class",
    "override",
    "color",
    "size",
    "radius",
    "insideLabelSize",
    "transitionFunction",
    "id",
    "label",
    "onLabel",
    "offLabel",
    "disabled",
    "checked"
  ];
  Object.keys($$props).forEach((key3) => {
    if (!~writable_props.indexOf(key3) && key3.slice(0, 2) !== "$$" && key3 !== "slot")
      console.warn(`<Switch> was created with unknown prop '${key3}'`);
  });
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  function input_change_handler() {
    checked = this.checked;
    $$invalidate(1, checked);
  }
  $$self.$$set = ($$props2) => {
    if ("use" in $$props2)
      $$invalidate(2, use = $$props2.use);
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("class" in $$props2)
      $$invalidate(3, className = $$props2.class);
    if ("override" in $$props2)
      $$invalidate(4, override = $$props2.override);
    if ("color" in $$props2)
      $$invalidate(12, color = $$props2.color);
    if ("size" in $$props2)
      $$invalidate(13, size3 = $$props2.size);
    if ("radius" in $$props2)
      $$invalidate(14, radius2 = $$props2.radius);
    if ("insideLabelSize" in $$props2)
      $$invalidate(15, insideLabelSize = $$props2.insideLabelSize);
    if ("transitionFunction" in $$props2)
      $$invalidate(16, transitionFunction = $$props2.transitionFunction);
    if ("id" in $$props2)
      $$invalidate(5, id = $$props2.id);
    if ("label" in $$props2)
      $$invalidate(6, label = $$props2.label);
    if ("onLabel" in $$props2)
      $$invalidate(17, onLabel = $$props2.onLabel);
    if ("offLabel" in $$props2)
      $$invalidate(18, offLabel = $$props2.offLabel);
    if ("disabled" in $$props2)
      $$invalidate(7, disabled = $$props2.disabled);
    if ("checked" in $$props2)
      $$invalidate(1, checked = $$props2.checked);
  };
  $$self.$capture_state = () => ({
    get_current_component,
    createEventForwarder,
    useActions,
    randomID,
    useStyles: Switch_styles_default,
    use,
    element: element2,
    className,
    override,
    color,
    size: size3,
    radius: radius2,
    insideLabelSize,
    transitionFunction,
    id,
    label,
    onLabel,
    offLabel,
    disabled,
    checked,
    forwardEvents,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$props2) => {
    if ("use" in $$props2)
      $$invalidate(2, use = $$props2.use);
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
    if ("className" in $$props2)
      $$invalidate(3, className = $$props2.className);
    if ("override" in $$props2)
      $$invalidate(4, override = $$props2.override);
    if ("color" in $$props2)
      $$invalidate(12, color = $$props2.color);
    if ("size" in $$props2)
      $$invalidate(13, size3 = $$props2.size);
    if ("radius" in $$props2)
      $$invalidate(14, radius2 = $$props2.radius);
    if ("insideLabelSize" in $$props2)
      $$invalidate(15, insideLabelSize = $$props2.insideLabelSize);
    if ("transitionFunction" in $$props2)
      $$invalidate(16, transitionFunction = $$props2.transitionFunction);
    if ("id" in $$props2)
      $$invalidate(5, id = $$props2.id);
    if ("label" in $$props2)
      $$invalidate(6, label = $$props2.label);
    if ("onLabel" in $$props2)
      $$invalidate(17, onLabel = $$props2.onLabel);
    if ("offLabel" in $$props2)
      $$invalidate(18, offLabel = $$props2.offLabel);
    if ("disabled" in $$props2)
      $$invalidate(7, disabled = $$props2.disabled);
    if ("checked" in $$props2)
      $$invalidate(1, checked = $$props2.checked);
    if ("getStyles" in $$props2)
      $$invalidate(8, getStyles = $$props2.getStyles);
    if ("classes" in $$props2)
      $$invalidate(9, classes = $$props2.classes);
    if ("cx" in $$props2)
      $$invalidate(10, cx2 = $$props2.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*color, offLabel, onLabel, insideLabelSize, radius, size, transitionFunction*/
    520192) {
      $:
        $$invalidate(
          10,
          { cx: cx2, classes, getStyles } = Switch_styles_default(
            {
              color,
              offLabel,
              onLabel,
              insideLabelSize,
              radius: radius2,
              size: size3,
              transitionFunction
            },
            { name: "Switch" }
          ),
          cx2,
          ($$invalidate(9, classes), $$invalidate(12, color), $$invalidate(18, offLabel), $$invalidate(17, onLabel), $$invalidate(15, insideLabelSize), $$invalidate(14, radius2), $$invalidate(13, size3), $$invalidate(16, transitionFunction)),
          ($$invalidate(8, getStyles), $$invalidate(12, color), $$invalidate(18, offLabel), $$invalidate(17, onLabel), $$invalidate(15, insideLabelSize), $$invalidate(14, radius2), $$invalidate(13, size3), $$invalidate(16, transitionFunction))
        );
    }
  };
  return [
    element2,
    checked,
    use,
    className,
    override,
    id,
    label,
    disabled,
    getStyles,
    classes,
    cx2,
    forwardEvents,
    color,
    size3,
    radius2,
    insideLabelSize,
    transitionFunction,
    onLabel,
    offLabel,
    input_binding,
    input_change_handler
  ];
}
var Switch = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance95,
      create_fragment95,
      safe_not_equal,
      {
        use: 2,
        element: 0,
        class: 3,
        override: 4,
        color: 12,
        size: 13,
        radius: 14,
        insideLabelSize: 15,
        transitionFunction: 16,
        id: 5,
        label: 6,
        onLabel: 17,
        offLabel: 18,
        disabled: 7,
        checked: 1
      },
      add_css4
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Switch",
      options,
      id: create_fragment95.name
    });
  }
  get use() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get insideLabelSize() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set insideLabelSize(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionFunction() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionFunction(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onLabel() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onLabel(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get offLabel() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set offLabel(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Switch_default = Switch;

// node_modules/@svelteuidev/core/dist/components/Tabs/Tabs.styles.js
var getVariantStyles3 = (orientation, theme4, getRef) => {
  return {
    default: {
      [orientation === "horizontal" ? "borderBottom" : "borderRight"]: `2px solid ${theme4.fn.themeColor("gray", 2)}`,
      darkMode: {
        [orientation === "horizontal" ? "borderBottom" : "borderRight"]: `2px solid ${theme4.fn.themeColor("dark", 4)}`
      },
      [`& .${getRef("tabs")}`]: {
        [orientation === "horizontal" ? "marginBottom" : "marginRight"]: -2
      }
    },
    outline: {
      [orientation === "horizontal" ? "borderBottom" : "borderRight"]: `1px solid ${theme4.fn.themeColor("gray", 2)}`,
      darkMode: {
        [orientation === "horizontal" ? "borderBottom" : "borderRight"]: `1px solid ${theme4.fn.themeColor("dark", 4)}`
      },
      [`& .${getRef("tabs")}`]: {
        [orientation === "horizontal" ? "marginBottom" : "marginRight"]: -1
      }
    },
    pills: {
      marginRight: orientation === "vertical" ? "20" : "0"
    }
  };
};
var Tabs_styles_default = createStyles((theme4, { orientation, tabPadding }, getRef) => {
  return {
    root: {
      display: orientation === "vertical" ? "flex" : "block"
    },
    wrapper: {},
    tabs: {
      ref: getRef("tabs")
    },
    content: {
      [orientation === "horizontal" ? "paddingTop" : "paddingLeft"]: theme4.fn.size({
        size: tabPadding,
        sizes: theme4.space
      }),
      flex: orientation === "vertical" ? 1 : "none",
      display: "block"
    },
    ...getVariantStyles3(orientation, theme4, getRef)
  };
});

// node_modules/@svelteuidev/core/dist/components/Tabs/Tabs.svelte
var file44 = "node_modules/@svelteuidev/core/dist/components/Tabs/Tabs.svelte";
function create_default_slot_120(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[21],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[21],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_120.name,
    type: "slot",
    source: `(144:2) <Group    class={classes.tabs}    role=\\"tablist\\"    data-tabsid={tabsId}    direction={orientation === 'horizontal' ? 'row' : 'column'}    aria-orientation={orientation}    spacing={variant === 'pills' ? 5 : 0}    {position}    {grow}   >`,
    ctx: ctx8
  });
  return block;
}
function create_default_slot71(ctx8) {
  let div0;
  let group;
  let div0_class_value;
  let t;
  let div1;
  let div1_class_value;
  let current;
  group = new Group_default({
    props: {
      class: (
        /*classes*/
        ctx8[8].tabs
      ),
      role: "tablist",
      "data-tabsid": (
        /*tabsId*/
        ctx8[10]
      ),
      direction: (
        /*orientation*/
        ctx8[4] === "horizontal" ? "row" : "column"
      ),
      "aria-orientation": (
        /*orientation*/
        ctx8[4]
      ),
      spacing: (
        /*variant*/
        ctx8[6] === "pills" ? 5 : 0
      ),
      position: (
        /*position*/
        ctx8[5]
      ),
      grow: (
        /*grow*/
        ctx8[3]
      ),
      $$slots: { default: [create_default_slot_120] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div0 = element("div");
      create_component(group.$$.fragment);
      t = space();
      div1 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div0 = claim_element(nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(group.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach_dev);
      t = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { role: true, class: true });
      children(div1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = /*cx*/
      ctx8[9](
        /*classes*/
        ctx8[8].wrapper,
        /*classes*/
        ctx8[8][
          /*variant*/
          ctx8[6]
        ]
      ));
      add_location(div0, file44, 142, 1, 4796);
      attr_dev(div1, "role", "tabpanel");
      attr_dev(div1, "class", div1_class_value = /*cx*/
      ctx8[9](
        "tabs-content",
        /*classes*/
        ctx8[8].content
      ));
      add_location(div1, file44, 156, 1, 5121);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div0, anchor);
      mount_component(group, div0, null);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, div1, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const group_changes = {};
      if (dirty & /*classes*/
      256)
        group_changes.class = /*classes*/
        ctx9[8].tabs;
      if (dirty & /*orientation*/
      16)
        group_changes.direction = /*orientation*/
        ctx9[4] === "horizontal" ? "row" : "column";
      if (dirty & /*orientation*/
      16)
        group_changes["aria-orientation"] = /*orientation*/
        ctx9[4];
      if (dirty & /*variant*/
      64)
        group_changes.spacing = /*variant*/
        ctx9[6] === "pills" ? 5 : 0;
      if (dirty & /*position*/
      32)
        group_changes.position = /*position*/
        ctx9[5];
      if (dirty & /*grow*/
      8)
        group_changes.grow = /*grow*/
        ctx9[3];
      if (dirty & /*$$scope*/
      2097152) {
        group_changes.$$scope = { dirty, ctx: ctx9 };
      }
      group.$set(group_changes);
      if (!current || dirty & /*cx, classes, variant*/
      832 && div0_class_value !== (div0_class_value = /*cx*/
      ctx9[9](
        /*classes*/
        ctx9[8].wrapper,
        /*classes*/
        ctx9[8][
          /*variant*/
          ctx9[6]
        ]
      ))) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty & /*cx, classes*/
      768 && div1_class_value !== (div1_class_value = /*cx*/
      ctx9[9](
        "tabs-content",
        /*classes*/
        ctx9[8].content
      ))) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(group.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(group.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div0);
        detach_dev(t);
        detach_dev(div1);
      }
      destroy_component(group);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot71.name,
    type: "slot",
    source: "(142:0) <Box bind:element {use} class={cx(className, classes.root)} {...$$restProps}>",
    ctx: ctx8
  });
  return block;
}
function create_fragment96(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { use: (
      /*use*/
      ctx8[1]
    ) },
    {
      class: (
        /*cx*/
        ctx8[9](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[8].root
        )
      )
    },
    /*$$restProps*/
    ctx8[11]
  ];
  function box_element_binding(value) {
    ctx8[20](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot71] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*use, cx, className, classes, $$restProps*/
      2822 ? get_spread_update(box_spread_levels, [
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*cx, className, classes*/
        772 && {
          class: (
            /*cx*/
            ctx9[9](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[8].root
            )
          )
        },
        dirty & /*$$restProps*/
        2048 && get_spread_object(
          /*$$restProps*/
          ctx9[11]
        )
      ]) : {};
      if (dirty & /*$$scope, cx, classes, variant, orientation, position, grow*/
      2098040) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment96.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
var ctx6 = "Tabs";
function instance96($$self, $$props, $$invalidate) {
  let _active;
  let nextTabCode;
  let previousTabCode;
  let cx2;
  let classes;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "active",
    "color",
    "grow",
    "initialTab",
    "orientation",
    "position",
    "tabPadding",
    "variant"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $contextStore, $$unsubscribe_contextStore = noop, $$subscribe_contextStore = () => ($$unsubscribe_contextStore(), $$unsubscribe_contextStore = subscribe(contextStore, ($$value) => $$invalidate(18, $contextStore = $$value)), contextStore);
  $$self.$$.on_destroy.push(() => $$unsubscribe_contextStore());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tabs", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, active = -1, color = "blue", grow = false, initialTab = 0, orientation = "horizontal", position = "left", tabPadding = "xs", variant: variant2 = "default" } = $$props;
  const tabsId = randomID();
  let tabNodes;
  const dispatch = createEventDispatcher();
  onMount(() => {
    const children2 = element2.querySelectorAll(':scope > div > [role="tablist"] > .svelteui-Tab > div > .svelteui-Tab-content');
    tabNodes = Array.from(children2);
    setupTabs();
    calculateActive();
  });
  let contextStore = getContext(ctx6);
  validate_store(contextStore, "contextStore");
  $$subscribe_contextStore();
  if (!contextStore) {
    $$subscribe_contextStore(contextStore = writable({
      [tabsId]: {
        active: active === -1 ? initialTab : active,
        color,
        variant: variant2,
        orientation
      }
    }));
    setContext(ctx6, contextStore);
  }
  function setupTabs() {
    const tabs = element2.querySelectorAll(':scope > div > [role="tablist"] > .svelteui-Tab');
    for (let [index, tab] of Array.from(tabs).entries()) {
      const key3 = tab.getAttribute("data-key");
      tab.addEventListener("click", () => onTabClick(index, key3));
      tab.addEventListener("keydown", (event) => onTabKeyDown(event, index, key3));
    }
  }
  function calculateActive() {
    if (!element2)
      return;
    const content = element2.querySelector(":scope > .tabs-content");
    if (!content)
      return;
    const activeTab = Array.from(tabNodes)[_active];
    if (!activeTab)
      return;
    if (content.children.length > 0) {
      content.replaceChild(activeTab, content.children[0]);
    } else {
      content.appendChild(activeTab);
    }
  }
  function onTabClick(index, key3) {
    dispatch("change", { index, key: key3 });
    $$invalidate(17, _active = index);
    contextStore.set({
      ...$contextStore,
      [tabsId]: { ...$contextStore[tabsId], active: index }
    });
  }
  function onTabKeyDown(event, index, key3) {
    const tabs = element2.querySelectorAll(".svelteui-Tab");
    if (event.code === "Enter") {
      dispatch("change", { index, key: key3 });
      $$invalidate(17, _active = index);
      contextStore.set({
        ...$contextStore,
        [tabsId]: { ...$contextStore[tabsId], active: index }
      });
      return;
    }
    if (event.code === "Tab") {
      return;
    }
    let _index = _active;
    if (event.code === nextTabCode) {
      if (_index + 1 >= tabs.length)
        return;
      _index += 1;
    } else if (event.code === previousTabCode) {
      if (_index - 1 < 0)
        return;
      _index -= 1;
    }
    event.preventDefault();
    const selectedTab = Array.from(tabs)[_index];
    const selectedKey = selectedTab.getAttribute("data-key");
    dispatch("change", { index: _index, key: selectedKey });
    $$invalidate(17, _active = _index);
    contextStore.set({
      ...$contextStore,
      [tabsId]: { ...$contextStore[tabsId], active: _index }
    });
  }
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(12, override = $$new_props.override);
    if ("active" in $$new_props)
      $$invalidate(13, active = $$new_props.active);
    if ("color" in $$new_props)
      $$invalidate(14, color = $$new_props.color);
    if ("grow" in $$new_props)
      $$invalidate(3, grow = $$new_props.grow);
    if ("initialTab" in $$new_props)
      $$invalidate(15, initialTab = $$new_props.initialTab);
    if ("orientation" in $$new_props)
      $$invalidate(4, orientation = $$new_props.orientation);
    if ("position" in $$new_props)
      $$invalidate(5, position = $$new_props.position);
    if ("tabPadding" in $$new_props)
      $$invalidate(16, tabPadding = $$new_props.tabPadding);
    if ("variant" in $$new_props)
      $$invalidate(6, variant2 = $$new_props.variant);
    if ("$$scope" in $$new_props)
      $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    ctx: ctx6,
    createEventDispatcher,
    getContext,
    onMount,
    setContext,
    writable,
    randomID,
    Box: Box_default,
    Group: Group_default,
    useStyles: Tabs_styles_default,
    use,
    element: element2,
    className,
    override,
    active,
    color,
    grow,
    initialTab,
    orientation,
    position,
    tabPadding,
    variant: variant2,
    tabsId,
    tabNodes,
    dispatch,
    contextStore,
    setupTabs,
    calculateActive,
    onTabClick,
    onTabKeyDown,
    classes,
    cx: cx2,
    _active,
    previousTabCode,
    nextTabCode,
    $contextStore
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(12, override = $$new_props.override);
    if ("active" in $$props)
      $$invalidate(13, active = $$new_props.active);
    if ("color" in $$props)
      $$invalidate(14, color = $$new_props.color);
    if ("grow" in $$props)
      $$invalidate(3, grow = $$new_props.grow);
    if ("initialTab" in $$props)
      $$invalidate(15, initialTab = $$new_props.initialTab);
    if ("orientation" in $$props)
      $$invalidate(4, orientation = $$new_props.orientation);
    if ("position" in $$props)
      $$invalidate(5, position = $$new_props.position);
    if ("tabPadding" in $$props)
      $$invalidate(16, tabPadding = $$new_props.tabPadding);
    if ("variant" in $$props)
      $$invalidate(6, variant2 = $$new_props.variant);
    if ("tabNodes" in $$props)
      tabNodes = $$new_props.tabNodes;
    if ("contextStore" in $$props)
      $$subscribe_contextStore($$invalidate(7, contextStore = $$new_props.contextStore));
    if ("classes" in $$props)
      $$invalidate(8, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(9, cx2 = $$new_props.cx);
    if ("_active" in $$props)
      $$invalidate(17, _active = $$new_props._active);
    if ("previousTabCode" in $$props)
      previousTabCode = $$new_props.previousTabCode;
    if ("nextTabCode" in $$props)
      nextTabCode = $$new_props.nextTabCode;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*active, initialTab*/
    40960) {
      $:
        $$invalidate(17, _active = active === -1 ? initialTab : active);
    }
    if ($$self.$$.dirty & /*_active, color, variant, orientation*/
    147536) {
      $:
        set_store_value(
          contextStore,
          $contextStore[tabsId] = {
            active: _active,
            color,
            variant: variant2,
            orientation
          },
          $contextStore
        );
    }
    if ($$self.$$.dirty & /*orientation*/
    16) {
      $:
        nextTabCode = orientation === "horizontal" ? "ArrowRight" : "ArrowDown";
    }
    if ($$self.$$.dirty & /*orientation*/
    16) {
      $:
        previousTabCode = orientation === "horizontal" ? "ArrowLeft" : "ArrowUp";
    }
    if ($$self.$$.dirty & /*$contextStore, _active*/
    393216) {
      $:
        $contextStore, _active, calculateActive();
    }
    if ($$self.$$.dirty & /*orientation, tabPadding, override*/
    69648) {
      $:
        $$invalidate(9, { cx: cx2, classes } = Tabs_styles_default({ orientation, tabPadding }, { override, name: "Tabs" }), cx2, ($$invalidate(8, classes), $$invalidate(4, orientation), $$invalidate(16, tabPadding), $$invalidate(12, override)));
    }
  };
  return [
    element2,
    use,
    className,
    grow,
    orientation,
    position,
    variant2,
    contextStore,
    classes,
    cx2,
    tabsId,
    $$restProps,
    override,
    active,
    color,
    initialTab,
    tabPadding,
    _active,
    $contextStore,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Tabs = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance96, create_fragment96, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 12,
      active: 13,
      color: 14,
      grow: 3,
      initialTab: 15,
      orientation: 4,
      position: 5,
      tabPadding: 16,
      variant: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tabs",
      options,
      id: create_fragment96.name
    });
  }
  get use() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get grow() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set grow(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get initialTab() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initialTab(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get orientation() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orientation(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabPadding() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabPadding(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tabs_default = Tabs;

// node_modules/@svelteuidev/core/dist/components/Tabs/Tab/Tab.styles.js
var getVariantStyles4 = (color, orientation, theme4) => {
  return {
    "&.default": {
      transition: "border-color 150ms ease, color 150ms ease",
      color: theme4.colors.black.value,
      [orientation === "horizontal" ? "borderBottom" : "borderRight"]: "2px solid transparent",
      "&.active": {
        color: theme4.fn.themeColor(color, 7),
        [orientation === "horizontal" ? "borderBottomColor" : "borderRightColor"]: theme4.fn.themeColor(color, 7),
        darkMode: {
          color: theme4.fn.themeColor(color, 4),
          [orientation === "horizontal" ? "borderBottomColor" : "borderRightColor"]: theme4.fn.themeColor(color, 4)
        }
      }
    },
    "&.outline": {
      borderBottomLeftRadius: orientation === "vertical" ? theme4.radii.sm.value : "0",
      borderTopRightRadius: orientation === "horizontal" ? theme4.radii.sm.value : "0",
      borderTopLeftRadius: theme4.radii.sm.value,
      border: "1px solid transparent",
      borderBottom: orientation === "horizontal" ? "0" : "1px solid transparent",
      borderRight: orientation === "vertical" ? "0" : "1px solid transparent",
      color: theme4.fn.themeColor("gray", 7),
      "&.active": {
        color: theme4.colors.black.value,
        borderColor: theme4.fn.themeColor("gray", 2),
        background: theme4.colors.white.value,
        darkMode: {
          color: theme4.fn.themeColor("dark", 0),
          borderColor: theme4.fn.themeColor("dark", 4),
          background: theme4.fn.themeColor("dark", 7)
        }
      }
    },
    "&.pills": {
      borderRadius: theme4.radii.sm.value,
      backgroundColor: "transparent",
      color: theme4.fn.themeColor("gray", 7),
      fontSize: theme4.fontSizes.sm.value,
      height: "auto",
      padding: `${theme4.space.xsPX} ${theme4.space.lgPX}`,
      fontWeight: "500",
      "&:hover": {
        background: theme4.fn.themeColor("gray", 0),
        darkMode: {
          background: theme4.fn.themeColor("dark", 6)
        }
      },
      "&.active": {
        color: theme4.colors.white.value,
        background: theme4.fn.variant({ variant: "filled", color }).background[1],
        darkMode: {
          color: theme4.colors.white.value,
          background: theme4.fn.variant({ variant: "filled", color })
        },
        "&:hover": {
          background: theme4.fn.variant({ variant: "filled", color }).background[1]
        }
      }
    }
  };
};
var Tab_styles_default = createStyles((theme4, { color, orientation }) => {
  return {
    root: {
      WebkitTapHighlightColor: "transparent",
      boxSizing: "border-box",
      display: "block",
      height: 40,
      backgroundColor: "transparent",
      border: 0,
      padding: `0 ${theme4.space.mdPX}`,
      fontFamily: theme4.fonts.standard.value,
      fontSize: theme4.fontSizes.sm,
      cursor: "pointer",
      width: orientation === "vertical" ? "100%" : "auto",
      darkMode: {
        color: theme4.colors.white.value
      },
      ...getVariantStyles4(color, orientation, theme4),
      "&:disabled": {
        cursor: "not-allowed",
        color: theme4.fn.themeColor("gray", 5),
        darkMode: {
          color: theme4.fn.themeColor("dark", 3)
        }
      }
    },
    inner: {
      boxSizing: "border-box",
      display: "flex",
      alignItems: "center",
      justifyContent: orientation === "horizontal" ? "center" : "flex-start",
      lineHeight: 1,
      height: "100%"
    },
    icon: {
      "&:not(:only-child)": {
        marginRight: `${theme4.space.xs.value}px`
      },
      "& *": {
        display: "block"
      }
    },
    label: {},
    tabContent: {
      display: "none",
      "&.active": {
        display: "block"
      }
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Tabs/Tab/Tab.svelte
var file45 = "node_modules/@svelteuidev/core/dist/components/Tabs/Tab/Tab.svelte";
var get_label_slot_changes3 = (dirty) => ({});
var get_label_slot_context3 = (ctx8) => ({});
var get_icon_slot_spread_changes = (dirty) => dirty & /*iconProps*/
16;
var get_icon_slot_changes10 = (dirty) => ({ color: dirty & /*color*/
64 });
var get_icon_slot_context10 = (ctx8) => ({
  color: (
    /*color*/
    ctx8[6]
  ),
  .../*iconProps*/
  ctx8[4]
});
function create_if_block_121(ctx8) {
  let iconrenderer;
  let current;
  iconrenderer = new IconRenderer_default({
    props: {
      icon: (
        /*icon*/
        ctx8[3]
      ),
      iconProps: (
        /*iconProps*/
        ctx8[4]
      ),
      className: (
        /*classes*/
        ctx8[11].icon
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(iconrenderer.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconrenderer.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconrenderer, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const iconrenderer_changes = {};
      if (dirty & /*icon*/
      8)
        iconrenderer_changes.icon = /*icon*/
        ctx9[3];
      if (dirty & /*iconProps*/
      16)
        iconrenderer_changes.iconProps = /*iconProps*/
        ctx9[4];
      if (dirty & /*classes*/
      2048)
        iconrenderer_changes.className = /*classes*/
        ctx9[11].icon;
      iconrenderer.$set(iconrenderer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconrenderer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconrenderer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconrenderer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_121.name,
    type: "if",
    source: "(49:3) {#if icon}",
    ctx: ctx8
  });
  return block;
}
function fallback_block_15(ctx8) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*icon*/
    ctx8[3] && create_if_block_121(ctx8)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (
        /*icon*/
        ctx9[3]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
          if (dirty & /*icon*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_121(ctx9);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_15.name,
    type: "fallback",
    source: "(48:43)     ",
    ctx: ctx8
  });
  return block;
}
function create_if_block39(ctx8) {
  let div;
  let t;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*label*/
        ctx8[5]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*label*/
        ctx8[5]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*classes*/
      ctx8[11].label);
      add_location(div, file45, 54, 4, 2105);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*label*/
      32)
        set_data_dev(
          t,
          /*label*/
          ctx9[5]
        );
      if (dirty & /*classes*/
      2048 && div_class_value !== (div_class_value = /*classes*/
      ctx9[11].label)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block39.name,
    type: "if",
    source: "(54:3) {#if label}",
    ctx: ctx8
  });
  return block;
}
function fallback_block22(ctx8) {
  let if_block_anchor;
  let if_block = (
    /*label*/
    ctx8[5] && create_if_block39(ctx8)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx9, dirty) {
      if (
        /*label*/
        ctx9[5]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
        } else {
          if_block = create_if_block39(ctx9);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block22.name,
    type: "fallback",
    source: "(53:21)     ",
    ctx: ctx8
  });
  return block;
}
function create_default_slot72(ctx8) {
  let div1;
  let t0;
  let t1;
  let div0;
  let div0_class_value;
  let div1_class_value;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx8[23].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[25],
    get_icon_slot_context10
  );
  const icon_slot_or_fallback = icon_slot || fallback_block_15(ctx8);
  const label_slot_template = (
    /*#slots*/
    ctx8[23].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[25],
    get_label_slot_context3
  );
  const label_slot_or_fallback = label_slot || fallback_block22(ctx8);
  const default_slot_template = (
    /*#slots*/
    ctx8[23].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[25],
    null
  );
  const block = {
    c: function create() {
      div1 = element("div");
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.c();
      t0 = space();
      if (label_slot_or_fallback)
        label_slot_or_fallback.c();
      t1 = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      if (label_slot_or_fallback)
        label_slot_or_fallback.l(div1_nodes);
      t1 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = /*cx*/
      ctx8[12](
        "svelteui-Tab-content",
        /*classes*/
        ctx8[11].tabContent,
        { active: (
          /*_active*/
          ctx8[13]
        ) }
      ));
      add_location(div0, file45, 57, 2, 2167);
      attr_dev(div1, "class", div1_class_value = /*classes*/
      ctx8[11].inner);
      add_location(div1, file45, 46, 1, 1894);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(div1, null);
      }
      append_hydration_dev(div1, t0);
      if (label_slot_or_fallback) {
        label_slot_or_fallback.m(div1, null);
      }
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope, color, iconProps*/
        33554512)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[25],
            get_icon_slot_spread_changes(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[25]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx9[25],
              dirty,
              get_icon_slot_changes10
            ),
            get_icon_slot_context10
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty & /*icon, iconProps, classes*/
        2072)) {
          icon_slot_or_fallback.p(ctx9, !current ? -1 : dirty);
        }
      }
      if (label_slot) {
        if (label_slot.p && (!current || dirty & /*$$scope*/
        33554432)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[25]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx9[25],
              dirty,
              get_label_slot_changes3
            ),
            get_label_slot_context3
          );
        }
      } else {
        if (label_slot_or_fallback && label_slot_or_fallback.p && (!current || dirty & /*classes, label*/
        2080)) {
          label_slot_or_fallback.p(ctx9, !current ? -1 : dirty);
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[25]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[25],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*cx, classes, _active*/
      14336 && div0_class_value !== (div0_class_value = /*cx*/
      ctx9[12](
        "svelteui-Tab-content",
        /*classes*/
        ctx9[11].tabContent,
        { active: (
          /*_active*/
          ctx9[13]
        ) }
      ))) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty & /*classes*/
      2048 && div1_class_value !== (div1_class_value = /*classes*/
      ctx9[11].inner)) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot_or_fallback, local);
      transition_in(label_slot_or_fallback, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot_or_fallback, local);
      transition_out(label_slot_or_fallback, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.d(detaching);
      if (label_slot_or_fallback)
        label_slot_or_fallback.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot72.name,
    type: "slot",
    source: `(32:0) <Box  bind:element  {use}  class={cx('svelteui-Tab', className, classes.root, {   active: _active,   [_variant]: true  })}  root=\\"button\\"  role=\\"tab\\"  aria-selected={_active}  data-key={tabKey}  {disabled}  {title}  {...$$restProps} >`,
    ctx: ctx8
  });
  return block;
}
function create_fragment97(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { use: (
      /*use*/
      ctx8[1]
    ) },
    {
      class: (
        /*cx*/
        ctx8[12](
          "svelteui-Tab",
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[11].root,
          {
            active: (
              /*_active*/
              ctx8[13]
            ),
            [
              /*_variant*/
              ctx8[10]
            ]: true
          }
        )
      )
    },
    { root: "button" },
    { role: "tab" },
    { "aria-selected": (
      /*_active*/
      ctx8[13]
    ) },
    { "data-key": (
      /*tabKey*/
      ctx8[7]
    ) },
    { disabled: (
      /*disabled*/
      ctx8[8]
    ) },
    { title: (
      /*title*/
      ctx8[9]
    ) },
    /*$$restProps*/
    ctx8[15]
  ];
  function box_element_binding(value) {
    ctx8[24](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot72] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*use, cx, className, classes, _active, _variant, tabKey, disabled, title, $$restProps*/
      49030 ? get_spread_update(box_spread_levels, [
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*cx, className, classes, _active, _variant*/
        15364 && {
          class: (
            /*cx*/
            ctx9[12](
              "svelteui-Tab",
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[11].root,
              {
                active: (
                  /*_active*/
                  ctx9[13]
                ),
                [
                  /*_variant*/
                  ctx9[10]
                ]: true
              }
            )
          )
        },
        box_spread_levels[2],
        box_spread_levels[3],
        dirty & /*_active*/
        8192 && { "aria-selected": (
          /*_active*/
          ctx9[13]
        ) },
        dirty & /*tabKey*/
        128 && { "data-key": (
          /*tabKey*/
          ctx9[7]
        ) },
        dirty & /*disabled*/
        256 && { disabled: (
          /*disabled*/
          ctx9[8]
        ) },
        dirty & /*title*/
        512 && { title: (
          /*title*/
          ctx9[9]
        ) },
        dirty & /*$$restProps*/
        32768 && get_spread_object(
          /*$$restProps*/
          ctx9[15]
        )
      ]) : {};
      if (dirty & /*$$scope, classes, cx, _active, label, icon, iconProps, color*/
      33568888) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment97.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance97($$self, $$props, $$invalidate) {
  let _active;
  let _color;
  let _orientation;
  let _variant;
  let cx2;
  let classes;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "active",
    "icon",
    "iconProps",
    "label",
    "color",
    "variant",
    "orientation",
    "tabKey",
    "disabled",
    "title"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $state;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tab", slots, ["icon", "label", "default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, active = void 0, icon = void 0, iconProps = void 0, label = void 0, color = void 0, variant: variant2 = void 0, orientation = void 0, tabKey = void 0, disabled = false, title = void 0 } = $$props;
  const state = getContext(ctx6);
  validate_store(state, "state");
  component_subscribe($$self, state, (value) => $$invalidate(22, $state = value));
  function calculateActive() {
    if (!element2)
      return;
    const children2 = element2.parentNode.children;
    const tabsId = element2.parentElement.getAttribute("data-tabsid");
    const index = Array.prototype.indexOf.call(children2, element2);
    $$invalidate(13, _active = active !== void 0 ? active : $state[tabsId].active === index);
    $$invalidate(21, _color = color !== void 0 ? color : $state[tabsId].color);
    $$invalidate(20, _orientation = orientation !== void 0 ? orientation : $state[tabsId].orientation);
    $$invalidate(10, _variant = variant2 !== void 0 ? variant2 : $state[tabsId].variant);
  }
  onMount(() => calculateActive());
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(16, override = $$new_props.override);
    if ("active" in $$new_props)
      $$invalidate(17, active = $$new_props.active);
    if ("icon" in $$new_props)
      $$invalidate(3, icon = $$new_props.icon);
    if ("iconProps" in $$new_props)
      $$invalidate(4, iconProps = $$new_props.iconProps);
    if ("label" in $$new_props)
      $$invalidate(5, label = $$new_props.label);
    if ("color" in $$new_props)
      $$invalidate(6, color = $$new_props.color);
    if ("variant" in $$new_props)
      $$invalidate(18, variant2 = $$new_props.variant);
    if ("orientation" in $$new_props)
      $$invalidate(19, orientation = $$new_props.orientation);
    if ("tabKey" in $$new_props)
      $$invalidate(7, tabKey = $$new_props.tabKey);
    if ("disabled" in $$new_props)
      $$invalidate(8, disabled = $$new_props.disabled);
    if ("title" in $$new_props)
      $$invalidate(9, title = $$new_props.title);
    if ("$$scope" in $$new_props)
      $$invalidate(25, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    onMount,
    Box: Box_default,
    IconRenderer: IconRenderer_default,
    ctx: ctx6,
    useStyles: Tab_styles_default,
    use,
    element: element2,
    className,
    override,
    active,
    icon,
    iconProps,
    label,
    color,
    variant: variant2,
    orientation,
    tabKey,
    disabled,
    title,
    state,
    calculateActive,
    _orientation,
    _color,
    classes,
    cx: cx2,
    _variant,
    _active,
    $state
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(16, override = $$new_props.override);
    if ("active" in $$props)
      $$invalidate(17, active = $$new_props.active);
    if ("icon" in $$props)
      $$invalidate(3, icon = $$new_props.icon);
    if ("iconProps" in $$props)
      $$invalidate(4, iconProps = $$new_props.iconProps);
    if ("label" in $$props)
      $$invalidate(5, label = $$new_props.label);
    if ("color" in $$props)
      $$invalidate(6, color = $$new_props.color);
    if ("variant" in $$props)
      $$invalidate(18, variant2 = $$new_props.variant);
    if ("orientation" in $$props)
      $$invalidate(19, orientation = $$new_props.orientation);
    if ("tabKey" in $$props)
      $$invalidate(7, tabKey = $$new_props.tabKey);
    if ("disabled" in $$props)
      $$invalidate(8, disabled = $$new_props.disabled);
    if ("title" in $$props)
      $$invalidate(9, title = $$new_props.title);
    if ("_orientation" in $$props)
      $$invalidate(20, _orientation = $$new_props._orientation);
    if ("_color" in $$props)
      $$invalidate(21, _color = $$new_props._color);
    if ("classes" in $$props)
      $$invalidate(11, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(12, cx2 = $$new_props.cx);
    if ("_variant" in $$props)
      $$invalidate(10, _variant = $$new_props._variant);
    if ("_active" in $$props)
      $$invalidate(13, _active = $$new_props._active);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*active*/
    131072) {
      $:
        $$invalidate(13, _active = active);
    }
    if ($$self.$$.dirty & /*color, _color*/
    2097216) {
      $:
        $$invalidate(21, _color = color !== void 0 ? color : _color);
    }
    if ($$self.$$.dirty & /*orientation, _orientation*/
    1572864) {
      $:
        $$invalidate(20, _orientation = orientation !== void 0 ? orientation : _orientation);
    }
    if ($$self.$$.dirty & /*variant, _variant*/
    263168) {
      $:
        $$invalidate(10, _variant = variant2 !== void 0 ? variant2 : _variant);
    }
    if ($$self.$$.dirty & /*$state*/
    4194304) {
      $:
        $state, calculateActive();
    }
    if ($$self.$$.dirty & /*_color, _orientation, override*/
    3211264) {
      $:
        $$invalidate(12, { cx: cx2, classes } = Tab_styles_default({ color: _color, orientation: _orientation }, { override, name: "Tab" }), cx2, ($$invalidate(11, classes), $$invalidate(21, _color), $$invalidate(20, _orientation), $$invalidate(16, override), $$invalidate(6, color), $$invalidate(19, orientation)));
    }
  };
  return [
    element2,
    use,
    className,
    icon,
    iconProps,
    label,
    color,
    tabKey,
    disabled,
    title,
    _variant,
    classes,
    cx2,
    _active,
    state,
    $$restProps,
    override,
    active,
    variant2,
    orientation,
    _orientation,
    _color,
    $state,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Tab = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance97, create_fragment97, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 16,
      active: 17,
      icon: 3,
      iconProps: 4,
      label: 5,
      color: 6,
      variant: 18,
      orientation: 19,
      tabKey: 7,
      disabled: 8,
      title: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tab",
      options,
      id: create_fragment97.name
    });
  }
  get use() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconProps() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconProps(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get orientation() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orientation(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabKey() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabKey(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tab_default = Tab;

// node_modules/@svelteuidev/core/dist/components/Tabs/combinator.js
Tabs_default.Tab = Tab_default;
var Tabs2 = Tabs_default;

// node_modules/@svelteuidev/core/dist/components/Timeline/Timeline.styles.js
var Timeline_styles_default = createStyles((_, { align, bulletSize, lineWidth }) => {
  return {
    root: {
      paddingLeft: align === "left" ? bulletSize / 2 + lineWidth / 2 : 0,
      paddingRight: align === "left" ? 0 : bulletSize / 2 + lineWidth / 2
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Timeline/Timeline.svelte
function create_default_slot73(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[17],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        131072)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[17]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[17],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot73.name,
    type: "slot",
    source: "(59:0) <Box bind:element {use} class={cx(className, classes.root)} {...$$restProps}>",
    ctx: ctx8
  });
  return block;
}
function create_fragment98(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { use: (
      /*use*/
      ctx8[1]
    ) },
    {
      class: (
        /*cx*/
        ctx8[4](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[3].root
        )
      )
    },
    /*$$restProps*/
    ctx8[6]
  ];
  function box_element_binding(value) {
    ctx8[16](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot73] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*use, cx, className, classes, $$restProps*/
      94 ? get_spread_update(box_spread_levels, [
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*cx, className, classes*/
        28 && {
          class: (
            /*cx*/
            ctx9[4](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[3].root
            )
          )
        },
        dirty & /*$$restProps*/
        64 && get_spread_object(
          /*$$restProps*/
          ctx9[6]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      131072) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment98.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
var ctx7 = "Timeline";
function instance98($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "active",
    "align",
    "bulletSize",
    "radius",
    "color",
    "lineWidth",
    "reverseActive"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $contextStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Timeline", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, active = -1, align = "left", bulletSize = 20, radius: radius2 = "xl", color = "blue", lineWidth = 4, reverseActive = false } = $$props;
  const contextStore = writable({
    active,
    reverseActive,
    align,
    bulletSize,
    radius: radius2,
    color,
    lineWidth
  });
  validate_store(contextStore, "contextStore");
  component_subscribe($$self, contextStore, (value) => $$invalidate(18, $contextStore = value));
  setContext(ctx7, contextStore);
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(7, override = $$new_props.override);
    if ("active" in $$new_props)
      $$invalidate(8, active = $$new_props.active);
    if ("align" in $$new_props)
      $$invalidate(9, align = $$new_props.align);
    if ("bulletSize" in $$new_props)
      $$invalidate(10, bulletSize = $$new_props.bulletSize);
    if ("radius" in $$new_props)
      $$invalidate(11, radius2 = $$new_props.radius);
    if ("color" in $$new_props)
      $$invalidate(12, color = $$new_props.color);
    if ("lineWidth" in $$new_props)
      $$invalidate(13, lineWidth = $$new_props.lineWidth);
    if ("reverseActive" in $$new_props)
      $$invalidate(14, reverseActive = $$new_props.reverseActive);
    if ("$$scope" in $$new_props)
      $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    ctx: ctx7,
    setContext,
    writable,
    Box: Box_default,
    useStyles: Timeline_styles_default,
    use,
    element: element2,
    className,
    override,
    active,
    align,
    bulletSize,
    radius: radius2,
    color,
    lineWidth,
    reverseActive,
    contextStore,
    classes,
    cx: cx2,
    $contextStore
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(7, override = $$new_props.override);
    if ("active" in $$props)
      $$invalidate(8, active = $$new_props.active);
    if ("align" in $$props)
      $$invalidate(9, align = $$new_props.align);
    if ("bulletSize" in $$props)
      $$invalidate(10, bulletSize = $$new_props.bulletSize);
    if ("radius" in $$props)
      $$invalidate(11, radius2 = $$new_props.radius);
    if ("color" in $$props)
      $$invalidate(12, color = $$new_props.color);
    if ("lineWidth" in $$props)
      $$invalidate(13, lineWidth = $$new_props.lineWidth);
    if ("reverseActive" in $$props)
      $$invalidate(14, reverseActive = $$new_props.reverseActive);
    if ("classes" in $$props)
      $$invalidate(3, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(4, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*active, reverseActive, align, bulletSize, radius, color, lineWidth*/
    32512) {
      $:
        set_store_value(
          contextStore,
          $contextStore = {
            active,
            reverseActive,
            align,
            bulletSize,
            radius: radius2,
            color,
            lineWidth
          },
          $contextStore
        );
    }
    if ($$self.$$.dirty & /*align, bulletSize, lineWidth, override*/
    9856) {
      $:
        $$invalidate(4, { cx: cx2, classes } = Timeline_styles_default({ align, bulletSize, lineWidth }, { override, name: "Timeline" }), cx2, ($$invalidate(3, classes), $$invalidate(9, align), $$invalidate(10, bulletSize), $$invalidate(13, lineWidth), $$invalidate(7, override)));
    }
  };
  return [
    element2,
    use,
    className,
    classes,
    cx2,
    contextStore,
    $$restProps,
    override,
    active,
    align,
    bulletSize,
    radius2,
    color,
    lineWidth,
    reverseActive,
    slots,
    box_element_binding,
    $$scope
  ];
}
var Timeline = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance98, create_fragment98, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 7,
      active: 8,
      align: 9,
      bulletSize: 10,
      radius: 11,
      color: 12,
      lineWidth: 13,
      reverseActive: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Timeline",
      options,
      id: create_fragment98.name
    });
  }
  get use() {
    throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bulletSize() {
    throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bulletSize(value) {
    throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineWidth() {
    throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineWidth(value) {
    throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get reverseActive() {
    throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set reverseActive(value) {
    throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Timeline_default = Timeline;

// node_modules/@svelteuidev/core/dist/components/Timeline/TimelineItem/TimelineItem.styles.js
var TimelineItem_styles_default = createStyles((theme4, { align, bulletSize, radius: radius2, color, lineVariant, lineWidth }, getRef) => {
  const colors2 = vFunc(color).filled;
  return {
    root: {
      position: "relative",
      boxSizing: "border-box",
      color: theme4.colors.black.value,
      paddingLeft: align === "left" ? theme4.space.xlPX.value : 0,
      paddingRight: align === "right" ? theme4.space.xlPX.value : 0,
      textAlign: align,
      fontFamily: theme4.fonts.standard.value,
      darkMode: {
        color: theme4.fn.themeColor("dark", 0)
      },
      "&:not(:last-of-type)::before": {
        display: "block"
      },
      "&:not(:first-of-type)": {
        marginTop: theme4.space.xlPX.value
      },
      "&::before": {
        boxSizing: "border-box",
        position: "absolute",
        top: 0,
        bottom: `${-theme4.space.xl.value}px`,
        left: align === "left" ? -lineWidth : "auto",
        right: align === "right" ? -lineWidth : "auto",
        borderLeft: `${lineWidth}px ${lineVariant} ${theme4.fn.themeColor("gray", 3)}`,
        content: '""',
        display: "none",
        darkMode: {
          borderLeft: `${lineWidth}px ${lineVariant} ${theme4.fn.themeColor("dark", 4)}`
        }
      },
      "&.lineActive": {
        "&::before": {
          borderLeftColor: colors2.backgroundColor
        }
      },
      [`&.active .${getRef("bulletContainer")}`]: {
        borderColor: colors2.backgroundColor,
        backgroundColor: theme4.colors.white.value
      },
      [`&.active .${getRef("bulletContainerWithChild")}`]: {
        backgroundColor: colors2.backgroundColor,
        color: theme4.colors.white.value
      }
    },
    bulletContainer: {
      ref: getRef("bulletContainer"),
      boxSizing: "border-box",
      width: bulletSize,
      height: bulletSize,
      borderRadius: theme4.fn.radius(radius2),
      border: `${lineWidth}px solid ${theme4.fn.themeColor("gray", 3)}`,
      backgroundColor: theme4.colors.white.value,
      position: "absolute",
      top: 0,
      left: align === "left" ? -bulletSize / 2 - lineWidth / 2 : "auto",
      right: align === "right" ? -bulletSize / 2 - lineWidth / 2 : "auto",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      color: theme4.colors.white.value,
      darkMode: {
        border: `${lineWidth}px solid ${theme4.fn.themeColor("dark", 4)}`,
        backgroundColor: theme4.fn.themeColor("dark", 7)
      }
    },
    bulletContainerWithChild: {
      ref: getRef("bulletContainerWithChild"),
      borderWidth: 1,
      backgroundColor: theme4.fn.themeColor("gray", 3),
      color: theme4.colors.black.value,
      darkMode: {
        backgroundColor: theme4.fn.themeColor("dark", 4),
        color: theme4.fn.themeColor("dark", 0)
      }
    },
    bullet: {},
    container: {},
    title: {
      fontWeight: 500,
      lineHeight: 1,
      marginBottom: `${+theme4.space.xs.value / 2}px`,
      textAlign: align
    },
    content: {
      textAlign: align
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Timeline/TimelineItem/TimelineItem.svelte
var file46 = "node_modules/@svelteuidev/core/dist/components/Timeline/TimelineItem/TimelineItem.svelte";
var get_bullet_slot_changes = (dirty) => ({});
var get_bullet_slot_context = (ctx8) => ({});
function create_if_block_123(ctx8) {
  let iconrenderer;
  let current;
  iconrenderer = new IconRenderer_default({
    props: {
      icon: (
        /*bullet*/
        ctx8[3]
      ),
      className: (
        /*classes*/
        ctx8[7].bullet
      ),
      iconSize: (
        /*bulletSize*/
        ctx8[4]
      ),
      color: (
        /*color*/
        ctx8[5]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(iconrenderer.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(iconrenderer.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(iconrenderer, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const iconrenderer_changes = {};
      if (dirty & /*bullet*/
      8)
        iconrenderer_changes.icon = /*bullet*/
        ctx9[3];
      if (dirty & /*classes*/
      128)
        iconrenderer_changes.className = /*classes*/
        ctx9[7].bullet;
      if (dirty & /*bulletSize*/
      16)
        iconrenderer_changes.iconSize = /*bulletSize*/
        ctx9[4];
      if (dirty & /*color*/
      32)
        iconrenderer_changes.color = /*color*/
        ctx9[5];
      iconrenderer.$set(iconrenderer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconrenderer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconrenderer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(iconrenderer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_123.name,
    type: "if",
    source: "(61:3) {#if bullet}",
    ctx: ctx8
  });
  return block;
}
function fallback_block23(ctx8) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*bullet*/
    ctx8[3] && create_if_block_123(ctx8)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (
        /*bullet*/
        ctx9[3]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
          if (dirty & /*bullet*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_123(ctx9);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block23.name,
    type: "fallback",
    source: "(60:22)     ",
    ctx: ctx8
  });
  return block;
}
function create_if_block40(ctx8) {
  let text_1;
  let current;
  text_1 = new Text_default({
    props: {
      class: (
        /*classes*/
        ctx8[7].title
      ),
      $$slots: { default: [create_default_slot_121] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(text_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(text_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(text_1, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const text_1_changes = {};
      if (dirty & /*classes*/
      128)
        text_1_changes.class = /*classes*/
        ctx9[7].title;
      if (dirty & /*$$scope, title*/
      268435520) {
        text_1_changes.$$scope = { dirty, ctx: ctx9 };
      }
      text_1.$set(text_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(text_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block40.name,
    type: "if",
    source: "(67:2) {#if title}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_121(ctx8) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*title*/
        ctx8[6]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*title*/
        ctx8[6]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty & /*title*/
      64)
        set_data_dev(
          t,
          /*title*/
          ctx9[6]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_121.name,
    type: "slot",
    source: "(68:3) <Text class={classes.title}>",
    ctx: ctx8
  });
  return block;
}
function create_default_slot74(ctx8) {
  let div0;
  let div0_class_value;
  let t0;
  let div2;
  let t1;
  let div1;
  let div1_class_value;
  let div2_class_value;
  let current;
  const bullet_slot_template = (
    /*#slots*/
    ctx8[26].bullet
  );
  const bullet_slot = create_slot(
    bullet_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[28],
    get_bullet_slot_context
  );
  const bullet_slot_or_fallback = bullet_slot || fallback_block23(ctx8);
  let if_block = (
    /*title*/
    ctx8[6] && create_if_block40(ctx8)
  );
  const default_slot_template = (
    /*#slots*/
    ctx8[26].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[28],
    null
  );
  const block = {
    c: function create() {
      div0 = element("div");
      if (bullet_slot_or_fallback)
        bullet_slot_or_fallback.c();
      t0 = space();
      div2 = element("div");
      if (if_block)
        if_block.c();
      t1 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div0 = claim_element(nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (bullet_slot_or_fallback)
        bullet_slot_or_fallback.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(nodes);
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (if_block)
        if_block.l(div2_nodes);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (default_slot)
        default_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = /*cx*/
      ctx8[8](
        /*classes*/
        ctx8[7].bulletContainer,
        /*bullet*/
        ctx8[3] && /*classes*/
        ctx8[7].bulletContainerWithChild
      ));
      add_location(div0, file46, 58, 1, 2192);
      attr_dev(div1, "class", div1_class_value = /*classes*/
      ctx8[7].content);
      add_location(div1, file46, 69, 2, 2539);
      attr_dev(div2, "class", div2_class_value = /*classes*/
      ctx8[7].container);
      add_location(div2, file46, 65, 1, 2437);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div0, anchor);
      if (bullet_slot_or_fallback) {
        bullet_slot_or_fallback.m(div0, null);
      }
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div2, anchor);
      if (if_block)
        if_block.m(div2, null);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (bullet_slot) {
        if (bullet_slot.p && (!current || dirty & /*$$scope*/
        268435456)) {
          update_slot_base(
            bullet_slot,
            bullet_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[28]
            ) : get_slot_changes(
              bullet_slot_template,
              /*$$scope*/
              ctx9[28],
              dirty,
              get_bullet_slot_changes
            ),
            get_bullet_slot_context
          );
        }
      } else {
        if (bullet_slot_or_fallback && bullet_slot_or_fallback.p && (!current || dirty & /*bullet, classes, bulletSize, color*/
        184)) {
          bullet_slot_or_fallback.p(ctx9, !current ? -1 : dirty);
        }
      }
      if (!current || dirty & /*cx, classes, bullet*/
      392 && div0_class_value !== (div0_class_value = /*cx*/
      ctx9[8](
        /*classes*/
        ctx9[7].bulletContainer,
        /*bullet*/
        ctx9[3] && /*classes*/
        ctx9[7].bulletContainerWithChild
      ))) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (
        /*title*/
        ctx9[6]
      ) {
        if (if_block) {
          if_block.p(ctx9, dirty);
          if (dirty & /*title*/
          64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block40(ctx9);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        268435456)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[28]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[28],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classes*/
      128 && div1_class_value !== (div1_class_value = /*classes*/
      ctx9[7].content)) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*classes*/
      128 && div2_class_value !== (div2_class_value = /*classes*/
      ctx9[7].container)) {
        attr_dev(div2, "class", div2_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(bullet_slot_or_fallback, local);
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(bullet_slot_or_fallback, local);
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div0);
        detach_dev(t0);
        detach_dev(div2);
      }
      if (bullet_slot_or_fallback)
        bullet_slot_or_fallback.d(detaching);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot74.name,
    type: "slot",
    source: "(50:0) <Box  bind:element  {use}  class={cx(className, classes.root, {   lineActive: _lineActive,   active: _active  })}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment99(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    { use: (
      /*use*/
      ctx8[1]
    ) },
    {
      class: (
        /*cx*/
        ctx8[8](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[7].root,
          {
            lineActive: (
              /*_lineActive*/
              ctx8[9]
            ),
            active: (
              /*_active*/
              ctx8[10]
            )
          }
        )
      )
    },
    /*$$restProps*/
    ctx8[12]
  ];
  function box_element_binding(value) {
    ctx8[27](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot74] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*use, cx, className, classes, _lineActive, _active, $$restProps*/
      6022 ? get_spread_update(box_spread_levels, [
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*cx, className, classes, _lineActive, _active*/
        1924 && {
          class: (
            /*cx*/
            ctx9[8](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[7].root,
              {
                lineActive: (
                  /*_lineActive*/
                  ctx9[9]
                ),
                active: (
                  /*_active*/
                  ctx9[10]
                )
              }
            )
          )
        },
        dirty & /*$$restProps*/
        4096 && get_spread_object(
          /*$$restProps*/
          ctx9[12]
        )
      ]) : {};
      if (dirty & /*$$scope, classes, title, cx, bullet, bulletSize, color*/
      268435960) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment99.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance99($$self, $$props, $$invalidate) {
  let _active;
  let _lineActive;
  let _align;
  let _color;
  let _radius;
  let _bulletSize;
  let _lineWidth;
  let cx2;
  let classes;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "active",
    "align",
    "bullet",
    "bulletSize",
    "radius",
    "color",
    "lineActive",
    "lineVariant",
    "lineWidth",
    "title"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $state;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TimelineItem", slots, ["bullet", "default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, active = void 0, align = void 0, bullet = void 0, bulletSize = void 0, radius: radius2 = void 0, color = void 0, lineActive = void 0, lineVariant = "solid", lineWidth = void 0, title = void 0 } = $$props;
  const state = getContext(ctx7);
  validate_store(state, "state");
  component_subscribe($$self, state, (value) => $$invalidate(25, $state = value));
  function calculateActive() {
    if (!element2)
      return;
    const children2 = element2.parentNode.children;
    const index = Array.prototype.indexOf.call(children2, element2);
    $$invalidate(10, _active = active !== void 0 ? active : $state.reverseActive ? $state.active >= children2.length - index - 1 : $state.active >= index);
    $$invalidate(9, _lineActive = lineActive !== void 0 ? lineActive : $state.reverseActive ? $state.active >= children2.length - index - 1 : $state.active - 1 >= index);
  }
  onMount(() => calculateActive());
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(13, override = $$new_props.override);
    if ("active" in $$new_props)
      $$invalidate(14, active = $$new_props.active);
    if ("align" in $$new_props)
      $$invalidate(15, align = $$new_props.align);
    if ("bullet" in $$new_props)
      $$invalidate(3, bullet = $$new_props.bullet);
    if ("bulletSize" in $$new_props)
      $$invalidate(4, bulletSize = $$new_props.bulletSize);
    if ("radius" in $$new_props)
      $$invalidate(16, radius2 = $$new_props.radius);
    if ("color" in $$new_props)
      $$invalidate(5, color = $$new_props.color);
    if ("lineActive" in $$new_props)
      $$invalidate(17, lineActive = $$new_props.lineActive);
    if ("lineVariant" in $$new_props)
      $$invalidate(18, lineVariant = $$new_props.lineVariant);
    if ("lineWidth" in $$new_props)
      $$invalidate(19, lineWidth = $$new_props.lineWidth);
    if ("title" in $$new_props)
      $$invalidate(6, title = $$new_props.title);
    if ("$$scope" in $$new_props)
      $$invalidate(28, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    onMount,
    Box: Box_default,
    IconRenderer: IconRenderer_default,
    Text: Text_default,
    ctx: ctx7,
    useStyles: TimelineItem_styles_default,
    use,
    element: element2,
    className,
    override,
    active,
    align,
    bullet,
    bulletSize,
    radius: radius2,
    color,
    lineActive,
    lineVariant,
    lineWidth,
    title,
    state,
    calculateActive,
    _lineWidth,
    _color,
    _radius,
    _bulletSize,
    _align,
    classes,
    cx: cx2,
    _lineActive,
    _active,
    $state
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(13, override = $$new_props.override);
    if ("active" in $$props)
      $$invalidate(14, active = $$new_props.active);
    if ("align" in $$props)
      $$invalidate(15, align = $$new_props.align);
    if ("bullet" in $$props)
      $$invalidate(3, bullet = $$new_props.bullet);
    if ("bulletSize" in $$props)
      $$invalidate(4, bulletSize = $$new_props.bulletSize);
    if ("radius" in $$props)
      $$invalidate(16, radius2 = $$new_props.radius);
    if ("color" in $$props)
      $$invalidate(5, color = $$new_props.color);
    if ("lineActive" in $$props)
      $$invalidate(17, lineActive = $$new_props.lineActive);
    if ("lineVariant" in $$props)
      $$invalidate(18, lineVariant = $$new_props.lineVariant);
    if ("lineWidth" in $$props)
      $$invalidate(19, lineWidth = $$new_props.lineWidth);
    if ("title" in $$props)
      $$invalidate(6, title = $$new_props.title);
    if ("_lineWidth" in $$props)
      $$invalidate(20, _lineWidth = $$new_props._lineWidth);
    if ("_color" in $$props)
      $$invalidate(21, _color = $$new_props._color);
    if ("_radius" in $$props)
      $$invalidate(22, _radius = $$new_props._radius);
    if ("_bulletSize" in $$props)
      $$invalidate(23, _bulletSize = $$new_props._bulletSize);
    if ("_align" in $$props)
      $$invalidate(24, _align = $$new_props._align);
    if ("classes" in $$props)
      $$invalidate(7, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(8, cx2 = $$new_props.cx);
    if ("_lineActive" in $$props)
      $$invalidate(9, _lineActive = $$new_props._lineActive);
    if ("_active" in $$props)
      $$invalidate(10, _active = $$new_props._active);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*active*/
    16384) {
      $:
        $$invalidate(10, _active = active);
    }
    if ($$self.$$.dirty & /*lineActive*/
    131072) {
      $:
        $$invalidate(9, _lineActive = lineActive);
    }
    if ($$self.$$.dirty & /*align, $state*/
    33587200) {
      $:
        $$invalidate(24, _align = align !== void 0 ? align : $state.align);
    }
    if ($$self.$$.dirty & /*color, $state*/
    33554464) {
      $:
        $$invalidate(21, _color = color !== void 0 ? color : $state.color);
    }
    if ($$self.$$.dirty & /*radius, $state*/
    33619968) {
      $:
        $$invalidate(22, _radius = radius2 !== void 0 ? radius2 : $state.radius);
    }
    if ($$self.$$.dirty & /*bulletSize, $state*/
    33554448) {
      $:
        $$invalidate(23, _bulletSize = bulletSize !== void 0 ? bulletSize : $state.bulletSize);
    }
    if ($$self.$$.dirty & /*lineWidth, $state*/
    34078720) {
      $:
        $$invalidate(20, _lineWidth = lineWidth !== void 0 ? lineWidth : $state.lineWidth);
    }
    if ($$self.$$.dirty & /*$state*/
    33554432) {
      $:
        $state, calculateActive();
    }
    if ($$self.$$.dirty & /*_align, _bulletSize, _radius, _color, lineVariant, _lineWidth, override*/
    32776192) {
      $:
        $$invalidate(
          8,
          { cx: cx2, classes } = TimelineItem_styles_default(
            {
              align: _align,
              bulletSize: _bulletSize,
              radius: _radius,
              color: _color,
              lineVariant,
              lineWidth: _lineWidth
            },
            { override, name: "TimelineItem" }
          ),
          cx2,
          ($$invalidate(7, classes), $$invalidate(24, _align), $$invalidate(23, _bulletSize), $$invalidate(22, _radius), $$invalidate(21, _color), $$invalidate(18, lineVariant), $$invalidate(20, _lineWidth), $$invalidate(13, override), $$invalidate(15, align), $$invalidate(25, $state), $$invalidate(4, bulletSize), $$invalidate(16, radius2), $$invalidate(5, color), $$invalidate(19, lineWidth))
        );
    }
  };
  return [
    element2,
    use,
    className,
    bullet,
    bulletSize,
    color,
    title,
    classes,
    cx2,
    _lineActive,
    _active,
    state,
    $$restProps,
    override,
    active,
    align,
    radius2,
    lineActive,
    lineVariant,
    lineWidth,
    _lineWidth,
    _color,
    _radius,
    _bulletSize,
    _align,
    $state,
    slots,
    box_element_binding,
    $$scope
  ];
}
var TimelineItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance99, create_fragment99, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 13,
      active: 14,
      align: 15,
      bullet: 3,
      bulletSize: 4,
      radius: 16,
      color: 5,
      lineActive: 17,
      lineVariant: 18,
      lineWidth: 19,
      title: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TimelineItem",
      options,
      id: create_fragment99.name
    });
  }
  get use() {
    throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bullet() {
    throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bullet(value) {
    throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bulletSize() {
    throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bulletSize(value) {
    throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineActive() {
    throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineActive(value) {
    throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineVariant() {
    throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineVariant(value) {
    throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineWidth() {
    throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineWidth(value) {
    throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<TimelineItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<TimelineItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TimelineItem_default = TimelineItem;

// node_modules/@svelteuidev/core/dist/components/Timeline/combinator.js
Timeline_default.Item = TimelineItem_default;
var Timeline2 = Timeline_default;

// node_modules/@svelteuidev/core/dist/components/Title/Title.styles.js
var titleSizes = {
  1: {
    fontSize: 34,
    lineHeight: 1.3
  },
  2: {
    fontSize: 26,
    lineHeight: 1.35
  },
  3: {
    fontSize: 22,
    lineHeight: 1.4
  },
  4: {
    fontSize: 18,
    lineHeight: 1.45
  },
  5: {
    fontSize: 16,
    lineHeight: 1.5
  },
  6: {
    fontSize: 14,
    lineHeight: 1.5
  }
};
var Title_styles_default = createStyles(() => {
  return {
    root: {
      margin: 0
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Title/Title.svelte
function create_default_slot75(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[10],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[10],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot75.name,
    type: "slot",
    source: "(25:0) <Text  bind:element  class={cx(className, classes.root)}  root={node}  size={titleSizes[order].fontSize}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment100(ctx8) {
  let text_1;
  let updating_element;
  let current;
  const text_1_spread_levels = [
    {
      class: (
        /*cx*/
        ctx8[5](
          /*className*/
          ctx8[1],
          /*classes*/
          ctx8[4].root
        )
      )
    },
    { root: (
      /*node*/
      ctx8[3]
    ) },
    {
      size: titleSizes[
        /*order*/
        ctx8[2]
      ].fontSize
    },
    /*$$restProps*/
    ctx8[6]
  ];
  function text_1_element_binding(value) {
    ctx8[9](value);
  }
  let text_1_props = {
    $$slots: { default: [create_default_slot75] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < text_1_spread_levels.length; i2 += 1) {
    text_1_props = assign(text_1_props, text_1_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    text_1_props.element = /*element*/
    ctx8[0];
  }
  text_1 = new Text_default({ props: text_1_props, $$inline: true });
  binding_callbacks.push(() => bind(text_1, "element", text_1_element_binding));
  const block = {
    c: function create() {
      create_component(text_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(text_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(text_1, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const text_1_changes = dirty & /*cx, className, classes, node, order, $$restProps*/
      126 ? get_spread_update(text_1_spread_levels, [
        dirty & /*cx, className, classes*/
        50 && {
          class: (
            /*cx*/
            ctx9[5](
              /*className*/
              ctx9[1],
              /*classes*/
              ctx9[4].root
            )
          )
        },
        dirty & /*node*/
        8 && { root: (
          /*node*/
          ctx9[3]
        ) },
        dirty & /*order*/
        4 && {
          size: titleSizes[
            /*order*/
            ctx9[2]
          ].fontSize
        },
        dirty & /*$$restProps*/
        64 && get_spread_object(
          /*$$restProps*/
          ctx9[6]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      1024) {
        text_1_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        text_1_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      text_1.$set(text_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(text_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(text_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(text_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment100.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance100($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  const omit_props_names = ["element", "class", "override", "order"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Title", slots, ["default"]);
  let { element: element2 = void 0, class: className = "", override = {}, order = 1 } = $$props;
  let node;
  function text_1_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(7, override = $$new_props.override);
    if ("order" in $$new_props)
      $$invalidate(2, order = $$new_props.order);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    useStyles: Title_styles_default,
    Text: Text_default,
    titleSizes,
    element: element2,
    className,
    override,
    order,
    node,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(7, override = $$new_props.override);
    if ("order" in $$props)
      $$invalidate(2, order = $$new_props.order);
    if ("node" in $$props)
      $$invalidate(3, node = $$new_props.node);
    if ("classes" in $$props)
      $$invalidate(4, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(5, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*order*/
    4) {
      $:
        $$invalidate(3, node = `h${order}`);
    }
    if ($$self.$$.dirty & /*override*/
    128) {
      $:
        $$invalidate(5, { cx: cx2, classes } = Title_styles_default(null, { override, name: "Title" }), cx2, ($$invalidate(4, classes), $$invalidate(7, override)));
    }
  };
  return [
    element2,
    className,
    order,
    node,
    classes,
    cx2,
    $$restProps,
    override,
    slots,
    text_1_element_binding,
    $$scope
  ];
}
var Title = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance100, create_fragment100, safe_not_equal, {
      element: 0,
      class: 1,
      override: 7,
      order: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Title",
      options,
      id: create_fragment100.name
    });
  }
  get element() {
    throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get order() {
    throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set order(value) {
    throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Title_default = Title;

// node_modules/@svelteuidev/core/dist/components/Tooltip/Tooltip.styles.js
var Tooltip_styles_default = createStyles((theme4, { color, radius: radius2 }) => {
  return {
    root: {
      display: "inline-block"
    },
    body: {
      darkMode: {
        backgroundColor: theme4.fn.themeColor(color, 3),
        color: theme4.fn.themeColor("dark", 9)
      },
      backgroundColor: theme4.fn.themeColor(color, 9),
      lineHeight: theme4.lineHeights.md,
      fontSize: theme4.fontSizes.sm,
      fontFamily: theme4.fonts.standard.value,
      borderRadius: theme4.radii[radius2].value,
      padding: `${+theme4.space.xs.value / 2}px ${theme4.space.xs.value}px`,
      color: "white",
      position: "relative",
      overflow: "hidden",
      textOverflow: "ellipsis"
    },
    arrow: {
      darkMode: {
        backgroundColor: theme4.fn.themeColor(color, 3)
      },
      background: theme4.fn.themeColor(color, 9),
      zIndex: 0
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/Tooltip/Tooltip.svelte
var file47 = "node_modules/@svelteuidev/core/dist/components/Tooltip/Tooltip.svelte";
var get_label_slot_changes4 = (dirty) => ({});
var get_label_slot_context4 = (ctx8) => ({});
function create_else_block17(ctx8) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*label*/
        ctx8[5]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*label*/
        ctx8[5]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*label*/
      32)
        set_data_dev(
          t,
          /*label*/
          ctx9[5]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block17.name,
    type: "else",
    source: "(86:3) {:else}",
    ctx: ctx8
  });
  return block;
}
function create_if_block_311(ctx8) {
  let current;
  const label_slot_template = (
    /*#slots*/
    ctx8[33].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[39],
    get_label_slot_context4
  );
  const block = {
    c: function create() {
      if (label_slot)
        label_slot.c();
    },
    l: function claim(nodes) {
      if (label_slot)
        label_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (label_slot) {
        label_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty[1] & /*$$scope*/
        256)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[39],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[39]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx9[39],
              dirty,
              get_label_slot_changes4
            ),
            get_label_slot_context4
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (label_slot)
        label_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_311.name,
    type: "if",
    source: "(84:27) ",
    ctx: ctx8
  });
  return block;
}
function create_if_block_214(ctx8) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*label*/
        ctx8[5]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*label*/
        ctx8[5]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*label*/
      32)
        set_data_dev(
          t,
          /*label*/
          ctx9[5]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_214.name,
    type: "if",
    source: "(82:39) ",
    ctx: ctx8
  });
  return block;
}
function create_if_block_124(ctx8) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*label*/
        ctx8[5]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*label*/
        ctx8[5]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*label*/
      32)
        set_data_dev(
          t,
          /*label*/
          ctx9[5]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_124.name,
    type: "if",
    source: "(80:39) ",
    ctx: ctx8
  });
  return block;
}
function create_if_block41(ctx8) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*label*/
    ctx8[5]
  );
  function switch_props(ctx9, dirty) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx8));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (dirty[0] & /*label*/
      32 && switch_value !== (switch_value = /*label*/
      ctx9[5])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx9, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block41.name,
    type: "if",
    source: "(78:3) {#if typeof label === 'function'}",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_210(ctx8) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block41,
    create_if_block_124,
    create_if_block_214,
    create_if_block_311,
    create_else_block17
  ];
  const if_blocks = [];
  function select_block_type(ctx9, dirty) {
    if (typeof /*label*/
    ctx9[5] === "function")
      return 0;
    if (typeof /*label*/
    ctx9[5] === "string")
      return 1;
    if (typeof /*label*/
    ctx9[5] === "number")
      return 2;
    if (
      /*$$slots*/
      ctx9[25].label
    )
      return 3;
    return 4;
  }
  current_block_type_index = select_block_type(ctx8, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx8);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx9, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx9, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx9);
          if_block.c();
        } else {
          if_block.p(ctx9, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_210.name,
    type: "slot",
    source: "(69:2) <Box    bind:this={tooltipRef}    class={classes.body}    css={{     pointerEvents: allowPointerEvents ? 'all' : 'none',     whiteSpace: wrapLines ? 'normal' : 'nowrap',     width    }}   >",
    ctx: ctx8
  });
  return block;
}
function create_default_slot_122(ctx8) {
  let box;
  let current;
  let box_props = {
    class: (
      /*classes*/
      ctx8[19].body
    ),
    css: {
      pointerEvents: (
        /*allowPointerEvents*/
        ctx8[9] ? "all" : "none"
      ),
      whiteSpace: (
        /*wrapLines*/
        ctx8[8] ? "normal" : "nowrap"
      ),
      width: (
        /*width*/
        ctx8[7]
      )
    },
    $$slots: { default: [create_default_slot_210] },
    $$scope: { ctx: ctx8 }
  };
  box = new Box_default({ props: box_props, $$inline: true });
  ctx8[34](box);
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const box_changes = {};
      if (dirty[0] & /*classes*/
      524288)
        box_changes.class = /*classes*/
        ctx9[19].body;
      if (dirty[0] & /*allowPointerEvents, wrapLines, width*/
      896)
        box_changes.css = {
          pointerEvents: (
            /*allowPointerEvents*/
            ctx9[9] ? "all" : "none"
          ),
          whiteSpace: (
            /*wrapLines*/
            ctx9[8] ? "normal" : "nowrap"
          ),
          width: (
            /*width*/
            ctx9[7]
          )
        };
      if (dirty[0] & /*label, $$slots*/
      33554464 | dirty[1] & /*$$scope*/
      256) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx8[34](null);
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_122.name,
    type: "slot",
    source: "(56:1) <Popper   {transitionOptions}   {position}   {placement}   {gutter}   {withArrow}   {arrowSize}   {zIndex}   arrowClassName={classes.arrow}   reference={tooltipRefElement}   mounted={visible}   arrowDistance={3}  >",
    ctx: ctx8
  });
  return block;
}
function create_default_slot76(ctx8) {
  let popper;
  let t;
  let span;
  let current;
  popper = new Popper_default({
    props: {
      transitionOptions: (
        /*transitionOptions*/
        ctx8[16]
      ),
      position: (
        /*position*/
        ctx8[12]
      ),
      placement: (
        /*placement*/
        ctx8[13]
      ),
      gutter: (
        /*gutter*/
        ctx8[14]
      ),
      withArrow: (
        /*withArrow*/
        ctx8[15]
      ),
      arrowSize: (
        /*arrowSize*/
        ctx8[6]
      ),
      zIndex: (
        /*zIndex*/
        ctx8[11]
      ),
      arrowClassName: (
        /*classes*/
        ctx8[19].arrow
      ),
      reference: (
        /*tooltipRefElement*/
        ctx8[17]
      ),
      mounted: (
        /*visible*/
        ctx8[21]
      ),
      arrowDistance: 3,
      $$slots: { default: [create_default_slot_122] },
      $$scope: { ctx: ctx8 }
    },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx8[33].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[39],
    null
  );
  const block = {
    c: function create() {
      create_component(popper.$$.fragment);
      t = space();
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      claim_component(popper.$$.fragment, nodes);
      t = claim_space(nodes);
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file47, 90, 1, 2665);
    },
    m: function mount(target, anchor) {
      mount_component(popper, target, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      ctx8[35](span);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const popper_changes = {};
      if (dirty[0] & /*transitionOptions*/
      65536)
        popper_changes.transitionOptions = /*transitionOptions*/
        ctx9[16];
      if (dirty[0] & /*position*/
      4096)
        popper_changes.position = /*position*/
        ctx9[12];
      if (dirty[0] & /*placement*/
      8192)
        popper_changes.placement = /*placement*/
        ctx9[13];
      if (dirty[0] & /*gutter*/
      16384)
        popper_changes.gutter = /*gutter*/
        ctx9[14];
      if (dirty[0] & /*withArrow*/
      32768)
        popper_changes.withArrow = /*withArrow*/
        ctx9[15];
      if (dirty[0] & /*arrowSize*/
      64)
        popper_changes.arrowSize = /*arrowSize*/
        ctx9[6];
      if (dirty[0] & /*zIndex*/
      2048)
        popper_changes.zIndex = /*zIndex*/
        ctx9[11];
      if (dirty[0] & /*classes*/
      524288)
        popper_changes.arrowClassName = /*classes*/
        ctx9[19].arrow;
      if (dirty[0] & /*tooltipRefElement*/
      131072)
        popper_changes.reference = /*tooltipRefElement*/
        ctx9[17];
      if (dirty[0] & /*visible*/
      2097152)
        popper_changes.mounted = /*visible*/
        ctx9[21];
      if (dirty[0] & /*classes, allowPointerEvents, wrapLines, width, tooltipRef, label, $$slots*/
      34079650 | dirty[1] & /*$$scope*/
      256) {
        popper_changes.$$scope = { dirty, ctx: ctx9 };
      }
      popper.$set(popper_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[39],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[39]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[39],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(popper.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(popper.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(span);
      }
      destroy_component(popper, detaching);
      if (default_slot)
        default_slot.d(detaching);
      ctx8[35](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot76.name,
    type: "slot",
    source: "(45:0) <Box  bind:element  on:pointerenter={(event) => handleOpen(event)}  on:pointerleave={(event) => handleClose(event)}  on:focus!capture={handleOpen}  on:blur!capture={handleClose}  class={cx(className, classes.root, getStyles({ css: override }))}  {use}  id={tooltipId}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment101(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    {
      class: (
        /*cx*/
        ctx8[20](
          /*className*/
          ctx8[3],
          /*classes*/
          ctx8[19].root,
          /*getStyles*/
          ctx8[18]({ css: (
            /*override*/
            ctx8[4]
          ) })
        )
      )
    },
    { use: (
      /*use*/
      ctx8[2]
    ) },
    { id: (
      /*tooltipId*/
      ctx8[10]
    ) },
    /*$$restProps*/
    ctx8[24]
  ];
  function box_element_binding(value) {
    ctx8[36](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot76] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  box.$on(
    "pointerenter",
    /*pointerenter_handler*/
    ctx8[37]
  );
  box.$on(
    "pointerleave",
    /*pointerleave_handler*/
    ctx8[38]
  );
  box.$on(
    "focus!capture",
    /*handleOpen*/
    ctx8[22]
  );
  box.$on(
    "blur!capture",
    /*handleClose*/
    ctx8[23]
  );
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, dirty) {
      const box_changes = dirty[0] & /*cx, className, classes, getStyles, override, use, tooltipId, $$restProps*/
      18613276 ? get_spread_update(box_spread_levels, [
        dirty[0] & /*cx, className, classes, getStyles, override*/
        1835032 && {
          class: (
            /*cx*/
            ctx9[20](
              /*className*/
              ctx9[3],
              /*classes*/
              ctx9[19].root,
              /*getStyles*/
              ctx9[18]({ css: (
                /*override*/
                ctx9[4]
              ) })
            )
          )
        },
        dirty[0] & /*use*/
        4 && { use: (
          /*use*/
          ctx9[2]
        ) },
        dirty[0] & /*tooltipId*/
        1024 && { id: (
          /*tooltipId*/
          ctx9[10]
        ) },
        dirty[0] & /*$$restProps*/
        16777216 && get_spread_object(
          /*$$restProps*/
          ctx9[24]
        )
      ]) : {};
      if (dirty[0] & /*tooltipRefElement, transitionOptions, position, placement, gutter, withArrow, arrowSize, zIndex, classes, visible, allowPointerEvents, wrapLines, width, tooltipRef, label, $$slots*/
      36436962 | dirty[1] & /*$$scope*/
      256) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty[0] & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment101.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance101($$self, $$props, $$invalidate) {
  let visible2;
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = [
    "use",
    "element",
    "class",
    "override",
    "label",
    "opened",
    "openDelay",
    "closeDelay",
    "color",
    "radius",
    "disabled",
    "arrowSize",
    "width",
    "wrapLines",
    "allowPointerEvents",
    "tooltipRef",
    "tooltipId",
    "zIndex",
    "position",
    "placement",
    "gutter",
    "withArrow",
    "transitionOptions"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tooltip", slots, ["label", "default"]);
  const $$slots = compute_slots(slots);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, label = void 0, opened = null, openDelay = 0, closeDelay = 0, color = "gray", radius: radius2 = "sm", disabled = false, arrowSize = 2, width = "auto", wrapLines = false, allowPointerEvents = false, tooltipRef = null, tooltipId = null, zIndex = 300, position = "top", placement = "center", gutter = 5, withArrow = false, transitionOptions = { duration: 100 } } = $$props;
  const dispatch = createEventDispatcher();
  let openTimeoutRef, closeTimeoutRef;
  let _opened = false;
  let tooltipRefElement = null;
  const handleOpen = (event) => {
    window.clearTimeout(closeTimeoutRef);
    if (openDelay !== 0) {
      openTimeoutRef = window.setTimeout(
        () => {
          $$invalidate(32, _opened = true);
        },
        openDelay
      );
    } else {
      $$invalidate(32, _opened = true);
    }
    dispatch("mouseenter", event);
  };
  const handleClose = (event) => {
    window.clearTimeout(openTimeoutRef);
    if (closeDelay !== 0) {
      closeTimeoutRef = window.setTimeout(
        () => {
          $$invalidate(32, _opened = false);
        },
        closeDelay
      );
    } else {
      $$invalidate(32, _opened = false);
    }
    dispatch("mouseleave", event);
  };
  onMount(() => {
    window.clearTimeout(openTimeoutRef);
    window.clearTimeout(closeTimeoutRef);
  });
  function box_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      tooltipRef = $$value;
      $$invalidate(1, tooltipRef);
    });
  }
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      tooltipRefElement = $$value;
      $$invalidate(17, tooltipRefElement);
    });
  }
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  const pointerenter_handler = (event) => handleOpen(event);
  const pointerleave_handler = (event) => handleClose(event);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(24, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(4, override = $$new_props.override);
    if ("label" in $$new_props)
      $$invalidate(5, label = $$new_props.label);
    if ("opened" in $$new_props)
      $$invalidate(26, opened = $$new_props.opened);
    if ("openDelay" in $$new_props)
      $$invalidate(27, openDelay = $$new_props.openDelay);
    if ("closeDelay" in $$new_props)
      $$invalidate(28, closeDelay = $$new_props.closeDelay);
    if ("color" in $$new_props)
      $$invalidate(29, color = $$new_props.color);
    if ("radius" in $$new_props)
      $$invalidate(30, radius2 = $$new_props.radius);
    if ("disabled" in $$new_props)
      $$invalidate(31, disabled = $$new_props.disabled);
    if ("arrowSize" in $$new_props)
      $$invalidate(6, arrowSize = $$new_props.arrowSize);
    if ("width" in $$new_props)
      $$invalidate(7, width = $$new_props.width);
    if ("wrapLines" in $$new_props)
      $$invalidate(8, wrapLines = $$new_props.wrapLines);
    if ("allowPointerEvents" in $$new_props)
      $$invalidate(9, allowPointerEvents = $$new_props.allowPointerEvents);
    if ("tooltipRef" in $$new_props)
      $$invalidate(1, tooltipRef = $$new_props.tooltipRef);
    if ("tooltipId" in $$new_props)
      $$invalidate(10, tooltipId = $$new_props.tooltipId);
    if ("zIndex" in $$new_props)
      $$invalidate(11, zIndex = $$new_props.zIndex);
    if ("position" in $$new_props)
      $$invalidate(12, position = $$new_props.position);
    if ("placement" in $$new_props)
      $$invalidate(13, placement = $$new_props.placement);
    if ("gutter" in $$new_props)
      $$invalidate(14, gutter = $$new_props.gutter);
    if ("withArrow" in $$new_props)
      $$invalidate(15, withArrow = $$new_props.withArrow);
    if ("transitionOptions" in $$new_props)
      $$invalidate(16, transitionOptions = $$new_props.transitionOptions);
    if ("$$scope" in $$new_props)
      $$invalidate(39, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    onMount,
    Box: Box_default,
    Popper: Popper_default,
    useStyles: Tooltip_styles_default,
    use,
    element: element2,
    className,
    override,
    label,
    opened,
    openDelay,
    closeDelay,
    color,
    radius: radius2,
    disabled,
    arrowSize,
    width,
    wrapLines,
    allowPointerEvents,
    tooltipRef,
    tooltipId,
    zIndex,
    position,
    placement,
    gutter,
    withArrow,
    transitionOptions,
    dispatch,
    openTimeoutRef,
    closeTimeoutRef,
    _opened,
    tooltipRefElement,
    handleOpen,
    handleClose,
    getStyles,
    classes,
    cx: cx2,
    visible: visible2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(4, override = $$new_props.override);
    if ("label" in $$props)
      $$invalidate(5, label = $$new_props.label);
    if ("opened" in $$props)
      $$invalidate(26, opened = $$new_props.opened);
    if ("openDelay" in $$props)
      $$invalidate(27, openDelay = $$new_props.openDelay);
    if ("closeDelay" in $$props)
      $$invalidate(28, closeDelay = $$new_props.closeDelay);
    if ("color" in $$props)
      $$invalidate(29, color = $$new_props.color);
    if ("radius" in $$props)
      $$invalidate(30, radius2 = $$new_props.radius);
    if ("disabled" in $$props)
      $$invalidate(31, disabled = $$new_props.disabled);
    if ("arrowSize" in $$props)
      $$invalidate(6, arrowSize = $$new_props.arrowSize);
    if ("width" in $$props)
      $$invalidate(7, width = $$new_props.width);
    if ("wrapLines" in $$props)
      $$invalidate(8, wrapLines = $$new_props.wrapLines);
    if ("allowPointerEvents" in $$props)
      $$invalidate(9, allowPointerEvents = $$new_props.allowPointerEvents);
    if ("tooltipRef" in $$props)
      $$invalidate(1, tooltipRef = $$new_props.tooltipRef);
    if ("tooltipId" in $$props)
      $$invalidate(10, tooltipId = $$new_props.tooltipId);
    if ("zIndex" in $$props)
      $$invalidate(11, zIndex = $$new_props.zIndex);
    if ("position" in $$props)
      $$invalidate(12, position = $$new_props.position);
    if ("placement" in $$props)
      $$invalidate(13, placement = $$new_props.placement);
    if ("gutter" in $$props)
      $$invalidate(14, gutter = $$new_props.gutter);
    if ("withArrow" in $$props)
      $$invalidate(15, withArrow = $$new_props.withArrow);
    if ("transitionOptions" in $$props)
      $$invalidate(16, transitionOptions = $$new_props.transitionOptions);
    if ("openTimeoutRef" in $$props)
      openTimeoutRef = $$new_props.openTimeoutRef;
    if ("closeTimeoutRef" in $$props)
      closeTimeoutRef = $$new_props.closeTimeoutRef;
    if ("_opened" in $$props)
      $$invalidate(32, _opened = $$new_props._opened);
    if ("tooltipRefElement" in $$props)
      $$invalidate(17, tooltipRefElement = $$new_props.tooltipRefElement);
    if ("getStyles" in $$props)
      $$invalidate(18, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(19, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(20, cx2 = $$new_props.cx);
    if ("visible" in $$props)
      $$invalidate(21, visible2 = $$new_props.visible);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*opened*/
    67108864 | $$self.$$.dirty[1] & /*_opened, disabled*/
    3) {
      $:
        $$invalidate(21, visible2 = (typeof opened === "boolean" ? opened : _opened) && !disabled);
    }
    if ($$self.$$.dirty[0] & /*color, radius*/
    1610612736) {
      $:
        $$invalidate(20, { cx: cx2, classes, getStyles } = Tooltip_styles_default({ color, radius: radius2 }, { name: "Tooltip" }), cx2, ($$invalidate(19, classes), $$invalidate(29, color), $$invalidate(30, radius2)), ($$invalidate(18, getStyles), $$invalidate(29, color), $$invalidate(30, radius2)));
    }
  };
  return [
    element2,
    tooltipRef,
    use,
    className,
    override,
    label,
    arrowSize,
    width,
    wrapLines,
    allowPointerEvents,
    tooltipId,
    zIndex,
    position,
    placement,
    gutter,
    withArrow,
    transitionOptions,
    tooltipRefElement,
    getStyles,
    classes,
    cx2,
    visible2,
    handleOpen,
    handleClose,
    $$restProps,
    $$slots,
    opened,
    openDelay,
    closeDelay,
    color,
    radius2,
    disabled,
    _opened,
    slots,
    box_binding,
    span_binding,
    box_element_binding,
    pointerenter_handler,
    pointerleave_handler,
    $$scope
  ];
}
var Tooltip = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance101,
      create_fragment101,
      safe_not_equal,
      {
        use: 2,
        element: 0,
        class: 3,
        override: 4,
        label: 5,
        opened: 26,
        openDelay: 27,
        closeDelay: 28,
        color: 29,
        radius: 30,
        disabled: 31,
        arrowSize: 6,
        width: 7,
        wrapLines: 8,
        allowPointerEvents: 9,
        tooltipRef: 1,
        tooltipId: 10,
        zIndex: 11,
        position: 12,
        placement: 13,
        gutter: 14,
        withArrow: 15,
        transitionOptions: 16
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tooltip",
      options,
      id: create_fragment101.name
    });
  }
  get use() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opened() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opened(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get openDelay() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set openDelay(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeDelay() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeDelay(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radius() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radius(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get arrowSize() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set arrowSize(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrapLines() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrapLines(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get allowPointerEvents() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set allowPointerEvents(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipRef() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipRef(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tooltipId() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tooltipId(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placement() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placement(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gutter() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gutter(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withArrow() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withArrow(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionOptions() {
    throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionOptions(value) {
    throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tooltip_default = Tooltip;

// node_modules/@svelteuidev/core/dist/components/TypographyProvider/TypographyProvider.styles.js
var headingTheme = {
  spacing: {
    xs: 10,
    sm: 12,
    md: 16,
    lg: 20,
    xl: 24
  },
  headings: {
    fontFamily: "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji",
    fontWeight: 700,
    sizes: {
      h1: { fontSize: 34, lineHeight: 1.3 },
      h2: { fontSize: 26, lineHeight: 1.35 },
      h3: { fontSize: 22, lineHeight: 1.4 },
      h4: { fontSize: 18, lineHeight: 1.45 },
      h5: { fontSize: 16, lineHeight: 1.5 },
      h6: { fontSize: 14, lineHeight: 1.5 }
    }
  }
};
var headings = Object.keys(headingTheme.headings.sizes).reduce((acc, h) => {
  acc[`& ${h}`] = {
    fontFamily: headingTheme.headings.fontFamily,
    fontWeight: headingTheme.headings.fontWeight,
    marginTop: headingTheme.spacing.xl * headingTheme.headings.sizes[h].lineHeight,
    marginBottom: headingTheme.spacing.sm,
    ...headingTheme.headings.sizes[h],
    "@media (max-width: 755px)": {
      fontSize: typeof headingTheme.headings.sizes[h].fontSize === "number" && headingTheme.headings.sizes[h].fontSize / 1.3
    }
  };
  return acc;
}, {});
var TypographyProvider_styles_default = createStyles((theme4, { primaryColor, underline }) => {
  return {
    root: {
      [`${theme4.dark} &`]: {
        color: theme4.fn.themeColor("dark", 0),
        "& hr": {
          borderTop: `1px dashed ${theme4.fn.themeColor("gray", 4)}`
        },
        "& a": {
          color: theme4.fn.themeColor(primaryColor, 4)
        },
        "& pre": {
          backgroundColor: theme4.fn.themeColor("dark", 8)
        },
        "& code": {
          color: theme4.fn.themeColor("dark", 0),
          backgroundColor: theme4.fn.themeColor("dark", 5),
          border: `1px solid ${theme4.fn.themeColor("dark", 3)}`
        },
        "& caption": {
          color: theme4.fn.themeColor("gray", 6)
        },
        "& th": {
          color: theme4.fn.themeColor("dark", 0)
        },
        "& thead th": {
          borderBottom: `1px solid ${theme4.fn.themeColor("dark", 4)}`
        },
        "& tfoot th": {
          borderTop: `1px solid ${theme4.fn.themeColor("dark", 4)}`
        },
        "& td": {
          padding: "7px 10px",
          borderBottom: `1px solid ${theme4.fn.themeColor("dark", 4)}`,
          fontSize: 14
        },
        "& blockquote": {
          color: theme4.fn.themeColor("dark", 0),
          "& cite": {
            color: theme4.fn.themeColor("dark", 2)
          }
        }
      },
      fontFamily: theme4.fonts.standard.value ?? "sans-serif",
      color: "black",
      lineHeight: theme4.lineHeights.md.value,
      fontSize: theme4.fontSizes.md.value,
      "@media (max-width: 755px)": {
        fontSize: theme4.fontSizes.sm.value
      },
      ...headings,
      "& img": {
        maxWidth: "100%",
        marginBottom: +theme4.space.xs.value
      },
      "& p": {
        marginTop: 0,
        marginBottom: +theme4.space.lg.value
      },
      "& hr": {
        marginTop: +theme4.space.md.value,
        marginBottom: +theme4.space.sm.value,
        borderBottom: 0,
        borderLeft: 0,
        borderRight: 0,
        borderTop: `1px dashed ${theme4.fn.themeColor("gray", 4)}`
      },
      "& a": {
        focusRing: "auto",
        color: theme4.fn.themeColor(primaryColor, 6),
        textDecoration: "none",
        "&:hover": {
          textDecoration: underline ? "underline" : "none"
        }
      },
      "& pre": {
        padding: +theme4.space.xs.value,
        lineHeight: theme4.lineHeights.md.value,
        margin: 0,
        marginTop: +theme4.space.md.value,
        marginBottom: +theme4.space.md.value,
        overflowX: "auto",
        fontFamily: theme4.fonts.mono.value,
        fontSize: theme4.fontSizes.sm,
        borderRadius: theme4.radii.sm.value,
        backgroundColor: theme4.fn.themeColor("gray", 0)
      },
      "& code": {
        lineHeight: theme4.lineHeights.md.value,
        padding: `0px ${+theme4.space.xs.value / 2}px`,
        borderRadius: theme4.radii.sm.value,
        color: "black",
        backgroundColor: theme4.fn.themeColor("dark", 0),
        fontFamily: theme4.fonts.mono.value,
        border: `1px solid ${theme4.fn.themeColor("gray", 3)}`,
        whiteSpace: "nowrap",
        fontSize: ".9rem",
        background: "#f4f5f7"
      },
      "& ul, & ol": {
        marginBottom: +theme4.space.md.value,
        paddingLeft: +theme4.space.lg.value * 2,
        "& li": {
          marginTop: +theme4.space.xs.value
        }
      },
      "& table": {
        width: "100%",
        borderCollapse: "collapse",
        captionSide: "bottom",
        marginBottom: +theme4.space.md.value,
        "& caption": {
          marginTop: +theme4.space.xs.value,
          fontSize: theme4.fontSizes.sm,
          color: theme4.fn.themeColor("dark", 2)
        },
        "& th": {
          textAlign: "left",
          fontWeight: "bold",
          color: theme4.fn.themeColor("gray", 7),
          fontSize: 14,
          padding: "7px 10px"
        },
        "& thead th": {
          borderBottom: `1px solid ${theme4.fn.themeColor("gray", 3)}`
        },
        "& tfoot th": {
          borderTop: `1px solid ${theme4.fn.themeColor("gray", 3)}`
        },
        "& td": {
          padding: "7px 10px",
          borderBottom: `1px solid ${theme4.fn.themeColor("gray", 3)}`,
          fontSize: 14
        },
        "& tr:last-of-type td": {
          borderBottom: "none"
        }
      },
      "& blockquote": {
        fontSize: theme4.fontSizes.lg.value,
        lineHeight: theme4.lineHeights.md.value,
        margin: `${theme4.space.md.value}px 0`,
        borderTopRightRadius: theme4.radii.sm.value,
        borderBottomRightRadius: theme4.radii.sm.value,
        padding: `${theme4.space.md.value}px ${theme4.space.lg.value}px`,
        color: "black",
        "& cite": {
          display: "block",
          fontSize: theme4.fontSizes.sm,
          marginTop: +theme4.space.xs.value,
          color: theme4.fn.themeColor("gray", 6),
          overflow: "hidden",
          textOverflow: "ellipsis"
        }
      }
    }
  };
});

// node_modules/@svelteuidev/core/dist/components/TypographyProvider/TypographyProvider.svelte
function create_default_slot77(ctx8) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx8[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx8,
    /*$$scope*/
    ctx8[12],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx9, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx9,
            /*$$scope*/
            ctx9[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx9[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx9[12],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot77.name,
    type: "slot",
    source: "(8:0) <Box  bind:element  class={cx(className, classes.root, getStyles({ css: override }))}  {use}  {...$$restProps} >",
    ctx: ctx8
  });
  return block;
}
function create_fragment102(ctx8) {
  let box;
  let updating_element;
  let current;
  const box_spread_levels = [
    {
      class: (
        /*cx*/
        ctx8[6](
          /*className*/
          ctx8[2],
          /*classes*/
          ctx8[5].root,
          /*getStyles*/
          ctx8[4]({ css: (
            /*override*/
            ctx8[3]
          ) })
        )
      )
    },
    { use: (
      /*use*/
      ctx8[1]
    ) },
    /*$$restProps*/
    ctx8[7]
  ];
  function box_element_binding(value) {
    ctx8[11](value);
  }
  let box_props = {
    $$slots: { default: [create_default_slot77] },
    $$scope: { ctx: ctx8 }
  };
  for (let i2 = 0; i2 < box_spread_levels.length; i2 += 1) {
    box_props = assign(box_props, box_spread_levels[i2]);
  }
  if (
    /*element*/
    ctx8[0] !== void 0
  ) {
    box_props.element = /*element*/
    ctx8[0];
  }
  box = new Box_default({ props: box_props, $$inline: true });
  binding_callbacks.push(() => bind(box, "element", box_element_binding));
  const block = {
    c: function create() {
      create_component(box.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(box.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(box, target, anchor);
      current = true;
    },
    p: function update(ctx9, [dirty]) {
      const box_changes = dirty & /*cx, className, classes, getStyles, override, use, $$restProps*/
      254 ? get_spread_update(box_spread_levels, [
        dirty & /*cx, className, classes, getStyles, override*/
        124 && {
          class: (
            /*cx*/
            ctx9[6](
              /*className*/
              ctx9[2],
              /*classes*/
              ctx9[5].root,
              /*getStyles*/
              ctx9[4]({ css: (
                /*override*/
                ctx9[3]
              ) })
            )
          )
        },
        dirty & /*use*/
        2 && { use: (
          /*use*/
          ctx9[1]
        ) },
        dirty & /*$$restProps*/
        128 && get_spread_object(
          /*$$restProps*/
          ctx9[7]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      4096) {
        box_changes.$$scope = { dirty, ctx: ctx9 };
      }
      if (!updating_element && dirty & /*element*/
      1) {
        updating_element = true;
        box_changes.element = /*element*/
        ctx9[0];
        add_flush_callback(() => updating_element = false);
      }
      box.$set(box_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(box.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(box.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(box, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment102.name,
    type: "component",
    source: "",
    ctx: ctx8
  });
  return block;
}
function instance102($$self, $$props, $$invalidate) {
  let cx2;
  let classes;
  let getStyles;
  const omit_props_names = ["use", "element", "class", "override", "primaryColor", "underline"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TypographyProvider", slots, ["default"]);
  let { use = [], element: element2 = void 0, class: className = "", override = {}, primaryColor = "blue", underline = true } = $$props;
  function box_element_binding(value) {
    element2 = value;
    $$invalidate(0, element2);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$new_props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("override" in $$new_props)
      $$invalidate(3, override = $$new_props.override);
    if ("primaryColor" in $$new_props)
      $$invalidate(8, primaryColor = $$new_props.primaryColor);
    if ("underline" in $$new_props)
      $$invalidate(9, underline = $$new_props.underline);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Box: Box_default,
    useStyles: TypographyProvider_styles_default,
    use,
    element: element2,
    className,
    override,
    primaryColor,
    underline,
    getStyles,
    classes,
    cx: cx2
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(0, element2 = $$new_props.element);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("override" in $$props)
      $$invalidate(3, override = $$new_props.override);
    if ("primaryColor" in $$props)
      $$invalidate(8, primaryColor = $$new_props.primaryColor);
    if ("underline" in $$props)
      $$invalidate(9, underline = $$new_props.underline);
    if ("getStyles" in $$props)
      $$invalidate(4, getStyles = $$new_props.getStyles);
    if ("classes" in $$props)
      $$invalidate(5, classes = $$new_props.classes);
    if ("cx" in $$props)
      $$invalidate(6, cx2 = $$new_props.cx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*primaryColor, underline*/
    768) {
      $:
        $$invalidate(6, { cx: cx2, classes, getStyles } = TypographyProvider_styles_default({ primaryColor, underline }, { name: "TypographyProvider" }), cx2, ($$invalidate(5, classes), $$invalidate(8, primaryColor), $$invalidate(9, underline)), ($$invalidate(4, getStyles), $$invalidate(8, primaryColor), $$invalidate(9, underline)));
    }
  };
  return [
    element2,
    use,
    className,
    override,
    getStyles,
    classes,
    cx2,
    $$restProps,
    primaryColor,
    underline,
    slots,
    box_element_binding,
    $$scope
  ];
}
var TypographyProvider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance102, create_fragment102, safe_not_equal, {
      use: 1,
      element: 0,
      class: 2,
      override: 3,
      primaryColor: 8,
      underline: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TypographyProvider",
      options,
      id: create_fragment102.name
    });
  }
  get use() {
    throw new Error("<TypographyProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<TypographyProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<TypographyProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<TypographyProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TypographyProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TypographyProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get override() {
    throw new Error("<TypographyProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set override(value) {
    throw new Error("<TypographyProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get primaryColor() {
    throw new Error("<TypographyProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set primaryColor(value) {
    throw new Error("<TypographyProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get underline() {
    throw new Error("<TypographyProvider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set underline(value) {
    throw new Error("<TypographyProvider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TypographyProvider_default = TypographyProvider;
export {
  Accordion2 as Accordion,
  ActionIcon_default as ActionIcon,
  ActionIcon_errors_exports as ActionIconErrors,
  Affix_default as Affix,
  Alert_default as Alert,
  Anchor_default as Anchor,
  AppShell_default as AppShell,
  Aside_default as Aside,
  AspectRatio_default as AspectRatio,
  BackgroundImage_default as BackgroundImage,
  Badge_default as Badge,
  Bars_default as Bars,
  Blockquote_default as Blockquote,
  Box_default as Box,
  Breadcrumbs2 as Breadcrumbs,
  Burger_default as Burger,
  Button_default as Button,
  Button_errors_exports as ButtonErrors,
  Card2 as Card,
  Center_default as Center,
  Checkbox_default as Checkbox,
  CheckboxGroup_default as CheckboxGroup,
  Chip_default as Chip,
  ChipGroup_default as ChipGroup,
  Circle_default as Circle,
  CloseButton_default as CloseButton,
  CloseIcon_default as CloseIcon,
  Code_default as Code,
  Code_errors_exports as CodeErrors,
  Collapse_default as Collapse,
  Container_default as Container,
  CopyIcon_default as CopyIcon,
  Divider_default as Divider,
  Divider_errors_exports as DividerErrors,
  Dots_default as Dots,
  ENVIRONMENT,
  Error_default as Error,
  FileUpload_default as FileUpload,
  Flex_default as Flex,
  Footer_default as Footer,
  Grid2 as Grid,
  Group_default as Group,
  Header_default as Header,
  IconRenderer_default as IconRenderer,
  Image_default as Image,
  ImageIcon_default as ImageIcon,
  Input_default as Input,
  Input_errors_exports as InputErrors,
  InputWrapper_default as InputWrapper,
  JsonInput_default as JsonInput,
  Kbd_default as Kbd,
  Loader_default as Loader,
  Mark_default as Mark,
  MediaQuery_default as MediaQuery,
  Menu2 as Menu,
  MenuIcon_default as MenuIcon,
  Modal_default as Modal,
  NativeSelect_default as NativeSelect,
  Navbar_default as Navbar,
  NormalizeCSS,
  Notification_default as Notification,
  NumberInput_default as NumberInput,
  ObserverRender_default as ObserverRender,
  OptionalPortal_default as OptionalPortal,
  Overlay_default as Overlay,
  Paper_default as Paper,
  PasswordInput_default as PasswordInput,
  Popper_default as Popper,
  Portal_default as Portal,
  Progress_default as Progress,
  Radio_default as Radio,
  RadioGroup_default as RadioGroup,
  Ripple_default as Ripple,
  Seo_default as Seo,
  Section_default as ShellSection,
  SimpleGrid_default as SimpleGrid,
  Skeleton_default as Skeleton,
  Space_default as Space,
  Stack_default as Stack,
  Stack_errors_exports as StackErrors,
  SvelteUIGlobalCSS,
  SvelteUIProvider_default as SvelteUIProvider,
  Switch_default as Switch,
  Tabs2 as Tabs,
  Text_default as Text,
  Text_errors_exports as TextErrors,
  TextInput_default as TextInput,
  Textarea_default as Textarea,
  ThemeIcon_default as ThemeIcon,
  Timeline2 as Timeline,
  Title_default as Title,
  Tooltip_default as Tooltip,
  TypographyProvider_default as TypographyProvider,
  UnstyledButton_default as UnstyledButton,
  UserException,
  calculateArrowPlacement,
  clipboard,
  colorNameMap,
  colorScheme,
  colors,
  config,
  createEventForwarder,
  createStyles,
  createTheme,
  css,
  cssFactory,
  dark,
  errorCtx,
  exception,
  fns,
  getCssText,
  getSize,
  getSortedBreakpoints2 as getSortedBreakpoints,
  getTransition,
  globalCss,
  globalStyles,
  key,
  keyframes,
  mergeTheme,
  prepareStylesSSR,
  randomID,
  rem,
  reset,
  size2 as size,
  theme,
  toRgba,
  useActions,
  useSvelteUIDefaultProps,
  useSvelteUITheme,
  useSvelteUIThemeContext,
  vFunc
};
//# sourceMappingURL=@svelteuidev_core.js.map
